/*!
 * uu5g04 library with basic visual components
 * Copyright (C) 2021 Unicorn a.s.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see Licenses - GNU Project <https://gnu.org/licenses/>.
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("module"), require("uu5g04"), require("enzyme"), require("react"), require("react-dom"), require("react-dom/test-utils"));
	else if(typeof define === 'function' && define.amd)
		define("uu5g04-test", ["module", "uu5g04", "enzyme", "react", "react-dom", "react-dom/test-utils"], factory);
	else if(typeof exports === 'object')
		exports["uu5g04-test"] = factory(require("module"), require("uu5g04"), require("enzyme"), require("react"), require("react-dom"), require("react-dom/test-utils"));
	else
		root["UU5"] = root["UU5"] || {}, root["UU5"]["Test"] = factory(root["undefined"], root["UU5"], root["Enzyme"], root["React"], root["React"]["Dom"], root["React"]["Dom"]);
})(this, (__WEBPACK_EXTERNAL_MODULE_module__, __WEBPACK_EXTERNAL_MODULE_uu5g04__, __WEBPACK_EXTERNAL_MODULE_enzyme__, __WEBPACK_EXTERNAL_MODULE_react__, __WEBPACK_EXTERNAL_MODULE_react_dom__, __WEBPACK_EXTERNAL_MODULE_react_dom_test_utils__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./test/mixin-props.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MixinProps": () => (/* binding */ MixinProps),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const MixinProps = {
  "UU5.Common.BaseMixin": {
    id: {
      values: ["myId"]
    },
    name: {
      values: ["myName"]
    },
    tooltip: {
      values: ["My Tooltip"]
    },
    className: {
      values: ["my-classname"]
    },
    style: {
      values: ["padding:8px; borderRadius: 2px", {
        backgroundColor: "red",
        color: "blue"
      }]
    },
    mainAttrs: {
      style: [{
        backgroundColor: "red",
        color: "blue"
      }]
    },
    noIndex: {
      values: [true, false]
    }
  },
  "UU5.Common.ColorSchemaMixin": {
    colorSchema: {
      values: ["default", "red", "red-rich", "green", "green-rich", "yellow", "yellow-rich", "purple", "purple-rich", "brown", "brown-rich", "orange", "orange-rich", "cyan", "cyan-rich", "grey", "grey-rich", "pink", "pink-rich"]
    }
  },
  "UU5.Common.ElementaryMixin": {
    hidden: {
      values: [true, false]
    },
    disabled: {
      values: [true, false]
    },
    selected: {
      values: [true, false]
    },
    controlled: {
      values: [true, false]
    }
  },
  "UU5.Common.ContentMixin": {
    content: {
      values: [12345, "This is Content from ContentMixin"]
    },
    ignoreHTML: {
      values: [true, false]
    },
    checkSpaces: {
      values: [true, false]
    },
    checkGrammar: {
      values: [true, false]
    },
    checkHighlight: {
      values: [true, false]
    },
    textCorrector: {
      values: [true, false]
    },
    dynamic: {
      values: [true, false]
    }
  },
  "UU5.Common.NestingLevelMixin": {
    nestingLevel: {
      values: [
      // "spa",
      // "container",
      // "page",
      "bigBoxCollection", "bigBox", "boxCollection", "box", "smallBoxCollection", "smallBox", "inline"]
    }
  },
  "UU5.Common.PureRenderMixin": {
    pureRender: {
      values: [true, false]
    }
  },
  "UU5.Common.CcrWriterMixin": {
    ccrKey: {
      values: ["<UU5.Parrot.Page ccrKey='UU5.Parrot.Page' />"]
    }
  },
  "UU5.Common.SectionMixin": {
    header: {
      values: [Uu5g05.Utils.Element.create("div", null, "Header of section")]
    },
    footer: {
      values: [Uu5g05.Utils.Element.create("div", null, "Footer of section")]
    },
    underline: {
      values: [true, false]
    }
  },
  "UU5.Common.LevelMixin": {
    level: {
      values: [0, 1, 2, 3, 4, 5, 6, "0", "1", "2", "3", "4", "5", "6"]
    }
  },
  "UU5.Common.SwipeMixin": {
    swiped: {
      values: ["up", "right", "down", "left", "upRight", "downRight", "upLeft", "downLeft"]
    },
    swipedLong: {
      values: [null, true, false]
    },
    swipedFast: {
      values: [null, true, false]
    }
  },
  "UU5.Common.LsiMixin": {
    language: {
      values: ["cs", "en", "en-gb", "en-us", "fr", "de", "ru", "sk", "es", "uk"]
    }
  },
  "UU5.Common.ScreenSizeMixin": {
    //Mixin has not props only ifc
  },
  "UU5.Bricks.DraggableMixin": {
    //Mixin has not props only ifc
  },
  "UU5.Common.CcrReaderMixin": {
    //Mixin has not props only ifc
  },
  "UU5.Forms.TextInputMixin": {
    placeholder: {
      values: ["např.: +420 000 000 000", "Prosím vyplňte požadované pole .."]
    },
    required: {
      values: [true, false]
    },
    requiredMessage: {
      values: ["Bez tohoto pole se nehnete dál."]
    },
    //onFocus
    //onBlur
    //onEnter
    //validateOnChange
    focusMessage: {
      values: ["Bedlivě hlídám co píšete."]
    },
    patternMessage: {
      values: ["Hodnota inputu není validní."]
    },
    autocompleteItems: {
      array: ["Uchazeč(ka)", "Nasazení", "Přínos"]
    }
  },
  "UU5.Forms.InputMixin": {
    label: {
      values: ["Your personal email"]
    },
    message: {
      values: ["Your password is too short!"]
    },
    feedback: {
      values: ["initial", "success", "warning", "error", "loading"]
    },
    readOnly: {
      values: [true, false]
    },
    size: {
      values: ["s", "m", "l"]
    },
    labelColWidth: {
      values: ["xs12 s3", "xs12 s6 m4 l3"]
    },
    inputColWidth: {
      values: ["xs12 s9", "xs12 s6 m8 l9"]
    },
    inputAttrs: {
      values: [{
        type: "email",
        width: "150px"
      }]
    },
    labelAlignment: {
      values: ["xs-left s-right", "xs-right s-left"]
    }
    //onChange
    //onValidate
    //onChangeFeedback
  },

  "UU5.Forms.ChoiceMixin": {
    placeholder: {
      values: ["Vyplňte jméno včetně titulů"]
    },
    required: {
      values: [true, false]
    },
    requiredMessage: {
      values: ["Vyberte alespoň jednu možnost."]
    },
    iconOpen: {
      values: ["mdi-chevron-up"]
    },
    iconClosed: {
      values: ["mdi-chevron-down"]
    },
    buttonHidden: {
      values: [true, false]
    }
  },
  "UU5.Forms.ControlsMixin": {
    //Mixin does not have props only ifc
  },
  "UU5.Forms.FormMixin": {
    values: {
      values: [{
        input0: "Jan"
      }]
    },
    progressIndicator: {
      values: ["Libovolný vstup pro progressIndicator."]
    },
    saveOnEnter: {
      values: [true, false]
    }
    // onInit
    // onSave
    // onSaveDone
    // onSaveFail
    // onSaveByKey
    // onValidate
    // onReset
    // onCancel
  },

  "UU5.Forms.GroupMixin": {
    value: {
      array: [{
        label: "První možnost",
        name: "a1"
      }, {
        label: "Druhá možnost",
        name: "a2"
      }]
    },
    required: {
      values: [true, false]
    },
    requiredMessage: {
      values: ["Položka je povinná!"]
    },
    icon: {
      values: ["mdi-ok"]
    },
    inline: {
      values: [true, false]
    },
    labelPosition: {
      values: ["left", "right"]
    }
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MixinProps);

/***/ }),

/***/ "./test/mock-app-client.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./test/tools.js");


// TODO Mocking UuApp Client should be somewhere else (uu_appg01-test?).
// NOTE All root scope variables/functions must have prefix "mock" so that babel-jest doesn't complain.
let mockClient;
function mockThrowErrorFn(method) {
  return uri => {
    let error = new Error(`Unmocked call detected - Client.${method}(${JSON.stringify(uri)}). This is by default disabled. You should mock remote calls (see testing guideline) or, if it was really intended to make unmocked call, then use \`jest.unmock("uu_appg01");\` in the root scope of your test file. Note that this could also happen if your component performs more calls than you mocked.`);
    error.stack = _tools_js__WEBPACK_IMPORTED_MODULE_0__.cleanupErrorStack ? (0,_tools_js__WEBPACK_IMPORTED_MODULE_0__.cleanupErrorStack)(error.message, error.stack) : error.stack;
    throw error;
  };
}
try {
  // NOTE Mocking uu_appg01 via jest.doMock can be done only if that module is actually
  // installed. If it is not, Jest resolver will throw an error which has no code so
  // we would have to check the message to identify this scenario (this is the case if the module
  // is re-mapped via moduleNameMapper)
  //   => instead try to resolve the module's package.json which will throw standard error
  // with code MODULE_NOT_FOUND and skip mocking in such case.
  /*require.resolve*/("../../node_modules/uu_appg01/package.json");
  jest.doMock("uu_appg01", () => {
    let real = jest.requireActual("uu_appg01");
    mockClient = {
      ...real.Client,
      get: jest.fn(mockThrowErrorFn("get")),
      post: jest.fn(mockThrowErrorFn("post"))
    };
    return {
      ...real,
      Client: mockClient
    };
  });
} catch (e) {
  if (e.code !== "MODULE_NOT_FOUND") throw e;
}
beforeEach(() => {
  mockClient && mockClient.get.mockImplementation(mockThrowErrorFn("get"));
  mockClient && mockClient.post.mockImplementation(mockThrowErrorFn("post"));
});
afterEach(() => {
  mockClient && mockClient.get.mockRestore();
  mockClient && mockClient.post.mockRestore();
});

/***/ }),

/***/ "./test/mock-app-oidc.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/uu_appg01_devkit/node_modules/@babel/runtime/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _session_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./test/session.js");
/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./test/tools.js");




// TODO Mocking UuApp Session should be somewhere else (uu_appg01-test?).
try {
  // NOTE Mocking uu_appg01_oidc via jest.doMock can be done only if that module is actually
  // installed. If it is not, Jest resolver will throw an error which has no code so
  // we would have to check the message to identify this scenario (this is the case if the module
  // is re-mapped via moduleNameMapper)
  //   => instead try to resolve the module's package.json which will throw standard error
  // with code MODULE_NOT_FOUND and skip mocking in such case.
  /*require.resolve*/("../../node_modules/uu_appg01_oidc/package.json");
  jest.doMock("uu_appg01_oidc", () => {
    var _class;
    let Oidc = jest.requireActual("uu_appg01_oidc");

    // INFO
    // 1. MockAuthenticationService uses instance of Session. These store mocked state of authentication.
    // 2. Then there is MockSession which conforms to uu5g04 requirements about session (IdentityMixin, SessionMixin).
    //    From the point of view of uu_appg01_oidc this is "legacyApi" and is forwarded to classes in point 1.
    // 3. Additionally, MockSession has API for managing session state in tests as needed by uu5g04-test.

    class MockAuthenticationService {
      static getServiceName() {
        return "oidcg02";
      }
      static restoreSession() {
        return this.initPromise;
      }
      static isRestoringSession() {
        return !this.initComplete;
      }
      static addListener(eventName, listener) {
        if (!this._listeners[eventName]) this._listeners[eventName] = [];
        this._listeners[eventName].push(listener);
        return this.removeListener.bind(this, eventName, listener);
      }
      static removeListener(eventName, listener) {
        let listeners = this._listeners[eventName];
        if (listeners) this._listeners[eventName] = listeners.filter(fn => fn !== listener);
      }
      static async authenticate() {
        await _tools__WEBPACK_IMPORTED_MODULE_2__["default"].act(() => this.initPromise);
        this._triggerEvent("sessionChanged", oidcSession);
        return oidcSession;
      }
      static isAuthenticating() {
        return !this._initComplete;
      }
      static getCurrentSession() {
        return oidcSession;
      }
      static isSessionExpiring() {
        return !!this._expiring;
      }
      static _triggerEvent(eventName, payload) {
        let listeners = this._listeners[eventName];
        if (listeners) {
          _tools__WEBPACK_IMPORTED_MODULE_2__["default"].act(() => {
            let event = {
              type: eventName,
              data: payload
            };
            listeners.forEach(fn => fn(event));
          });
        }
      }
    }
    _class = MockAuthenticationService;
    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(MockAuthenticationService, "_listeners", {});
    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(MockAuthenticationService, "_expiresAt", 0);
    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(MockAuthenticationService, "_expiring", false);
    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(MockAuthenticationService, "initComplete", false);
    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(MockAuthenticationService, "initPromise", new Promise((resolve, reject) => {
      _class._initPromiseResolve = resolve;
      _class._initPromiseReject = reject;
    }));
    for (let k of Object.getOwnPropertyNames(Oidc.AuthenticationService)) {
      if (MockAuthenticationService[k] === undefined) {
        let origFn = Oidc.AuthenticationService[k];
        if (typeof origFn !== "function" || k === "constructor") continue;
        MockAuthenticationService[k] = jest.fn();
      }
    }
    // override real method on real AuthnSvc because uu_appg01_oidc automatically performs
    // restoreSession() on its own
    Oidc.AuthenticationService.restoreSession = async () => oidcSession;
    class Session {
      constructor() {
        this._identity = null;
        this._attributes = {};
        this._idToken = "token-for-tests";
      }

      // getId() {}
      // getAuthenticationId() {}
      // getAuthenticationTime() {}
      getAuthenticationLevelOfAssurance() {
        return this._identity ? this._identity.loginLevelOfAssurance : null;
      }
      getIdentity() {
        if (!this._identity) return this._identity;
        return new Identity(this._identity.uuIdentity, this._identity);
      }
      getClientIdentity() {}
      getApplicationIdentity() {}
      isAuthenticated() {
        return !!this._identity;
      }
      getCallTokenScope() {}
      async getCallToken(scope, opts = {}) {
        return (opts && opts.excludeAuthenticationType ? "" : "Bearer ") + this._idToken;
      }
      async close() {
        this._identity = null;
        return MockAuthenticationService._triggerEvent("sessionChanged", this);
      }
      assertTrustiness() {}
      getAttribute(name) {
        if (!this._identity) return;
        let map = {
          email: this._identity.email,
          sub: this._identity.id,
          loa: this._identity.levelOfAssurance
          // loginLevelOfAssurance: supportedAcrValues.indexOf(this._identity.levelOfAssurance),
        };

        return map[name];
      }
      getLogoutUri() {}
      getAuthenticationContext() {}
      getExpiresAt() {
        return MockAuthenticationService._expiresAt;
      }
      getState() {}
    }
    class Identity {
      constructor(uuIdentity, data) {
        this._uuIdentity = uuIdentity;
        if (typeof data === "string") {
          this._name = data;
        } else if (data) {
          this._name = data.name;
          this._type = data.type;
          this._levelOfAssurance = data.levelOfAssurance;
          this._loginLevelOfAssurance = data.loginLevelOfAssurance;
        }
      }
      getUuIdentity() {
        return this._uuIdentity;
      }
      getName() {
        return this._name;
      }
      getType() {
        return this._type;
      }
      getLevelOfAssurance() {
        return this._levelOfAssurance;
      }

      // TODO Only for backward compatibility, drop for "1.0.0" release
      getUUIdentity() {
        return this.getUuIdentity();
      }
    }

    // addLegacyAPI methods (copied from uu_appg01_oidc's oidcg01-session-wrapper.js)
    Object.defineProperty(Session, "currentSession", {
      get() {
        return mockSession;
      }
    });
    Object.defineProperty(Session, "initComplete", {
      get() {
        return !MockAuthenticationService.isRestoringSession();
      }
    });
    Object.defineProperty(Session, "initPromise", {
      get() {
        return MockAuthenticationService.restoreSession().then(() => mockSession);
      }
    });
    function addLegacyApi(session, AuthenticationService) {
      Object.defineProperty(session, "initComplete", {
        get() {
          return !AuthenticationService.isRestoringSession();
        }
      });
      Object.defineProperty(session, "initPromise", {
        get() {
          return AuthenticationService.restoreSession().then(() => session);
        }
      });

      // NOTE In optimal case this wrapper would always use AuthenticationService.getCurrentSession().
      // However that's not possible if we're finishing session restore because the "sessionChanged" event
      // is triggerred sooner than AuthnService._primaryProvider gets updated. So if an app uses
      // e.g. getIdentity() inside of the sessionChanged event handler, we would forward it to AS.getCurrentSession()
      // which would return empty session / session from not-yet-updated _primaryProvider.
      // => during events use the g02 session instance which was sent to the event, otherwise use getCurrentSession()
      let runningG02Session = null;
      const getG02Session = () => runningG02Session || AuthenticationService.getCurrentSession();
      session.getIdentity = function () {
        let g02Session = getG02Session();
        let identity = g02Session.getIdentity();
        if (!identity) return identity;
        identity.id = g02Session.getAttribute("sub");
        identity.name = identity.getName();
        identity.type = identity.getType();
        identity.email = g02Session.getAttribute("email");
        identity.uuIdentity = identity.getUuIdentity();
        identity.levelOfAssurance = identity.getLevelOfAssurance();
        identity.loginLevelOfAssurance = g02Session.getAuthenticationLevelOfAssurance();
        return identity;
      };
      session.getClaims = function () {
        return getG02Session()._attributes;
      };
      session.getCallToken = function (scope = null, opts = {}) {
        if (typeof scope === "string" || Array.isArray(scope)) {
          return getG02Session().getCallToken(scope, opts);
        } else {
          // If scope was not defined, return legacy value
          let session = getG02Session();
          return {
            token: session._idToken,
            tokenType: session._idToken ? "Bearer" : null
          };
        }
      };
      session.isExpiring = function () {
        return AuthenticationService.isSessionExpiring();
      };
      session.isAuthenticated = function () {
        return getG02Session().isAuthenticated();
      };
      session.login = function (options) {
        let opts = {
          ...options
        };
        let authnSvcOpts = {};
        if (opts.access_token && opts.token_type_hint === "urn:ietf:params:oauth:token-type:jwt-uuos8") {
          authnSvcOpts = {
            os8Token: opts.access_token
          };
          delete opts.access_token;
          delete opts.token_type_hint;
        }
        Object.assign(authnSvcOpts, opts);
        return AuthenticationService.authenticate(authnSvcOpts).then(() => session);
      };
      session.logout = function () {
        return getG02Session().close();
      };
      let _legacyListeners = {};
      session.addListener = function (eventType, listenerFn) {
        if (eventType === "identityChange") eventType = "sessionChanged";
        let unregFn = AuthenticationService.addListener(eventType, ({
          type,
          data
        }) => {
          let origRunningG02Session = runningG02Session;
          if (data instanceof Session) runningG02Session = data;
          try {
            let g01Type = type;
            let g01Data = data instanceof Session ? session : data;
            if (type === "sessionChanged") {
              g01Type = "identityChange";
              g01Data = session.getIdentity();
            }
            let legacyEvent = {
              type: g01Type,
              data: g01Data
            };
            return listenerFn(legacyEvent);
          } finally {
            runningG02Session = origRunningG02Session;
          }
        });
        let map = _legacyListeners[eventType];
        if (!map) map = _legacyListeners[eventType] = new Map();
        map.set(listenerFn, unregFn);
        return unregFn;
      };
      session.removeListener = function (eventType, listenerFn) {
        if (eventType === "identityChange") eventType = "sessionChanged";
        let map = _legacyListeners[eventType];
        let unregFn = map ? map.get(listenerFn) : null;
        if (!unregFn) return false;
        map.delete(listenerFn);
        return unregFn();
      };
      let _legacyIdentityChangeListeners = new Map();
      session.addIdentityChangeListener = function (listenerFn) {
        let unregFn = session.addListener("identityChange", e => listenerFn(e.data));
        _legacyIdentityChangeListeners.set(listenerFn, unregFn);
        return unregFn;
      };
      session.removeIdentityChangeListener = function (listenerFn) {
        let unregFn = _legacyIdentityChangeListeners.get(listenerFn);
        if (!unregFn) return false;
        _legacyIdentityChangeListeners.delete(listenerFn);
        return unregFn();
      };
      session.getAuthenticationContext = function () {
        return getG02Session().getAuthenticationContext();
      };
    }

    // mock Session with extra API for manipulating with session state
    class MockSession extends Session {
      mockSetPending() {
        MockAuthenticationService.initComplete = false;
        MockAuthenticationService.initPromise = new Promise((resolve, reject) => {
          MockAuthenticationService._initPromiseResolve = resolve;
          MockAuthenticationService._initPromiseReject = reject;
        });
        oidcSession._identity = null;
        MockAuthenticationService._expiring = false;
        MockAuthenticationService._expiresAt = 0;
      }
      async mockSetIdentity(identity) {
        oidcSession._identity = identity;
        MockAuthenticationService._triggerEvent("sessionChanged", oidcSession);
        if (!MockAuthenticationService.initComplete) {
          MockAuthenticationService.initComplete = true;
          MockAuthenticationService._initPromiseResolve(this);
          // have to wait for this because IdentityMixin might be waiting for initPromise and we want
          // such listeners to be finished when we return from this fn
          await _tools__WEBPACK_IMPORTED_MODULE_2__["default"].act(() => MockAuthenticationService.initPromise);
        }
      }
      mockSetExpiring(expiring) {
        if (!oidcSession._identity && expiring) {
          console.warn("Cannot set 'expiring' flag on session - use Session.mockSetIdentity(...) first.");
          return;
        }
        MockAuthenticationService._expiring = expiring;
        MockAuthenticationService._expiresAt = expiring ? Date.now() + 5 * 60 * 1000 : Date.now() + 12 * 60 * 60 * 1000;
        if (expiring) {
          MockAuthenticationService._triggerEvent("sessionExpiring", {
            expiresAt: MockAuthenticationService._expiresAt
          });
        } else if (oidcSession._identity) {
          MockAuthenticationService._triggerEvent("sessionExtended", {
            expiresAt: MockAuthenticationService._expiresAt
          });
        }
      }
      mockReset() {
        MockAuthenticationService.initComplete = false;
        MockAuthenticationService.initPromise = new Promise((resolve, reject) => {
          MockAuthenticationService._initPromiseResolve = resolve;
          MockAuthenticationService._initPromiseReject = reject;
        });
        oidcSession._identity = null;
        MockAuthenticationService._listeners = {};
        MockAuthenticationService._expiring = false;
        MockAuthenticationService._expiresAt = 0;
      }
    }
    let oidcSession = new Session();
    let mockSession = new MockSession();
    addLegacyApi(mockSession, MockAuthenticationService);
    _session_js__WEBPACK_IMPORTED_MODULE_1__.Session.instance = mockSession;
    return {
      ...Oidc,
      AuthenticationService: MockAuthenticationService,
      Session: Session
    };
  });
} catch (e) {
  if (e.code !== "MODULE_NOT_FOUND") throw e;
}

/***/ }),

/***/ "./test/session.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Session": () => (/* binding */ Session)
/* harmony export */ });
/* harmony import */ var uu5g04__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("uu5g04");
/* harmony import */ var uu5g04__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uu5g04__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./test/tools.js");


const TEST_IDENTITY = {
  id: "a8c5f13c239f820003dd4aff",
  // JWT claim "sub"
  name: "Test User",
  type: "uuPerson",
  uuIdentity: "1-9999",
  email: "test.user@example.org",
  // JWT claim "email"
  levelOfAssurance: 0,
  // JWT claim "loa"
  loginLevelOfAssurance: 1 // index of "loa" in supported acr values
};

// minimal Session class (copying API of OIDC Session)
class MockSession {
  constructor() {
    this.mockReset();
  }
  async login(opts) {
    await _tools__WEBPACK_IMPORTED_MODULE_1__["default"].act(() => this.initPromise);
    this._triggerEvent("identityChange", this.getIdentity());
    return this;
  }
  async logout() {
    await _tools__WEBPACK_IMPORTED_MODULE_1__["default"].act(() => Promise.resolve());
    this._identity = null;
    this._triggerEvent("identityChange", this.getIdentity());
  }
  isAuthenticated() {
    return this._identity != null;
  }
  isExpiring() {
    return this._expiring;
  }
  getIdentity() {
    return this._identity;
  }
  getCallToken() {
    return {
      token: "token-for-tests",
      type: "Bearer"
    };
  }
  addListener(eventName, listener) {
    if (!this._listeners[eventName]) this._listeners[eventName] = [];
    this._listeners[eventName].push(listener);
  }
  removeListener(eventName, listener) {
    let listeners = this._listeners[eventName];
    if (listeners) this._listeners[eventName] = listeners.filter(fn => fn !== listener);
  }
  _triggerEvent(eventName, payload) {
    let listeners = this._listeners[eventName];
    if (listeners) {
      _tools__WEBPACK_IMPORTED_MODULE_1__["default"].act(() => {
        let event = {
          type: eventName,
          data: payload
        };
        listeners.forEach(fn => fn(event));
      });
    }
  }

  // extra mock methods for controlling the session state
  mockSetPending() {
    this.initComplete = false;
    this.initPromise = new Promise((resolve, reject) => {
      this._initPromiseResolve = resolve;
      this._initPromiseReject = reject;
    });
    this._identity = null;
    this._expiring = false;
    this._expiresAt = 0;
  }
  async mockSetIdentity(identity) {
    this._identity = identity;
    this._triggerEvent("identityChange", this._identity);
    if (!this.initComplete) {
      this.initComplete = true;
      this._initPromiseResolve(this);
      // have to wait for this because IdentityMixin might be waiting for initPromise and we want
      // such listeners to be finished when we return from this fn
      await _tools__WEBPACK_IMPORTED_MODULE_1__["default"].act(() => this.initPromise);
    }
  }
  mockSetExpiring(expiring) {
    if (!this._identity && expiring) {
      console.warn("Cannot set 'expiring' flag on session - use Session.mockSetIdentity(...) first.");
      return;
    }
    this._expiring = expiring;
    this._expiresAt = expiring ? Date.now() + 5 * 60 * 1000 : Date.now() + 12 * 60 * 60 * 1000;
    if (expiring) this._triggerEvent("sessionExpiring", {
      expiresAt: this._expiresAt
    });else if (this._identity) this._triggerEvent("sessionExtended", {
      expiresAt: this._expiresAt
    });
  }
  mockReset() {
    this.initComplete = false;
    this.initPromise = new Promise((resolve, reject) => {
      this._initPromiseResolve = resolve;
      this._initPromiseReject = reject;
    });
    this._identity = null;
    this._listeners = {};
    this._expiring = false;
    this._expiresAt = 0;
  }
}
MockSession.currentSession = new MockSession();
const Session = {
  TEST_IDENTITY,
  instance: MockSession.currentSession,
  setPending() {
    return Session.instance.mockSetPending();
  },
  // must be async because we need to wait for Session.initPromise
  async setIdentity(identity) {
    return Session.instance.mockSetIdentity(identity);
  },
  setExpiring(expiring = true) {
    return Session.instance.mockSetExpiring(expiring);
  },
  reset() {
    return Session.instance.mockReset();
  }
};
beforeEach(async () => {
  await Session.setIdentity(Session.TEST_IDENTITY);
  (uu5g04__WEBPACK_IMPORTED_MODULE_0___default().Environment.session) = Session.instance;
});
afterEach(async () => {
  (uu5g04__WEBPACK_IMPORTED_MODULE_0___default().Environment.session) = null;
  Session.reset();
  let {
    _events
  } = (uu5g04__WEBPACK_IMPORTED_MODULE_0___default().Environment.EventListener);
  if (_events) _events.delete(Session.instance);
});

/***/ }),

/***/ "./test/test-build.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Session": () => (/* reexport safe */ _test_js__WEBPACK_IMPORTED_MODULE_1__.Session),
/* harmony export */   "Tools": () => (/* reexport safe */ _test_js__WEBPACK_IMPORTED_MODULE_1__.Tools),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var uu5g04__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("uu5g04");
/* harmony import */ var uu5g04__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uu5g04__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _test_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./test/test.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_test_js__WEBPACK_IMPORTED_MODULE_1__);

// merge into UU5
// NOTE "uu5g04" must ensure that the key already exists there, otherwise following usage wouldn't work:
//   import * as UU5 from "uu5g04";
//   import "uu5g04-test";
//   console.log(UU5.Test.TextArea);
for (var k in _test_js__WEBPACK_IMPORTED_MODULE_1__) (uu5g04__WEBPACK_IMPORTED_MODULE_0___default().Test)[k] = _test_js__WEBPACK_IMPORTED_MODULE_1__[k];

/***/ }),

/***/ "./test/test.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Session": () => (/* reexport safe */ _session_js__WEBPACK_IMPORTED_MODULE_0__.Session),
/* harmony export */   "Tools": () => (/* reexport safe */ _tools_js__WEBPACK_IMPORTED_MODULE_3__.Tools)
/* harmony export */ });
/* harmony import */ var _session_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./test/session.js");
/* harmony import */ var _mock_app_oidc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./test/mock-app-oidc.js");
/* harmony import */ var _mock_app_client_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./test/mock-app-client.js");
/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./test/tools.js");
// NOTE We need "afterEach" hook of Session to be registered
// before "afterEach" hook of Tools (so that during tests the Tools' one is run first and Session's
// is run second - Tools' one performs unmounts and some components need to have Session still
// available at that time).




(0,_tools_js__WEBPACK_IMPORTED_MODULE_3__.initTest)();



/***/ }),

/***/ "./test/tools.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Tools": () => (/* binding */ Tools),
/* harmony export */   "cleanupErrorStack": () => (/* binding */ cleanupErrorStack),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initTest": () => (/* binding */ initTest)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/uu_appg01_devkit/node_modules/@babel/runtime/helpers/extends.js");
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var enzyme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("enzyme");
/* harmony import */ var enzyme__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(enzyme__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("react-dom");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react_dom_test_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("react-dom/test-utils");
/* harmony import */ var react_dom_test_utils__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_dom_test_utils__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _mixin_props_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./test/mixin-props.js");






const DEFAULT_TIMEOUT = 100;
let setTimeout = __webpack_require__.g.setTimeout;
let clearTimeout = __webpack_require__.g.clearTimeout;
const cleanupErrorStack = (message, stack) => {
  // remove stacktrace rows containing tools.js & regenerator-runtime so that Jest
  // displays source code portion from which the Tools method has been called.
  let lines = stack.split(/\n/);
  let i = 0;
  while (i < lines.length && !lines[i].match(/^\s*at\s+/)) i++; // skip 1st/few lines (error message)
  let messageLines = lines.slice(0, i);
  while (i < lines.length && lines[i].match(/(src|uu5g04[/\\]dist[^/\\]*)[/\\]test[/\\][^.]+\.js:|regenerator-runtime|\(<anonymous>\)|node_modules[/\\]jest-mock[/\\]/)) i++;
  return [...messageLines, ...lines.slice(i)].join("\n");
};
function withSnapshotComment(value, comment) {
  let result = {
    comment,
    value
  };
  result[SYMBOL_SNAPSHOT_WITH_COMMENT] = true;
  return result;
}
// !!! Modify both takeSnaphot & takeSnapshotAsync. !!!
function takeSnapshot(component, comment, opt = {}) {
  let wrapper = Tools.shallow(component, opt.shallowOpt);
  let snapshotValue = comment ? withSnapshotComment(wrapper, comment) : wrapper;
  expect(snapshotValue).toMatchSnapshot();
  let snapshotString = toStringSerializer ? toStringSerializer.lastSnapshotString : null;
  return {
    wrapper,
    snapshotString
  };
}
async function takeSnapshotAsync(component, comment, opt = {}) {
  let wrapper = Tools.shallow(component, opt.shallowOpt);
  await Tools.wait();
  let snapshotValue = comment ? withSnapshotComment(wrapper, comment) : wrapper;
  expect(snapshotValue).toMatchSnapshot();
  let snapshotString = toStringSerializer ? toStringSerializer.lastSnapshotString : null;
  return {
    wrapper,
    snapshotString
  };
}
function toSafeJson(value) {
  if (typeof value === "function" && typeof value.toJSON !== "function") return "[Function]";
  try {
    return JSON.stringify(value);
  } catch (e) {
    return value != null ? value + "" : value;
  }
}
let toStringSerializer;
const SYMBOL_SNAPSHOT_STRING = Symbol.for("UU5.Test.Tools.SNAPSHOT_STRING");
const ERROR_MESSAGE_SNAPSHOT_STRING_PREFIX = "UU5.Test.Tools.getSnapshotStringErrorMessage";
class SnapshotToStringSerializer {
  constructor() {
    toStringSerializer = this;
  }
  getSnapshotString(wrapper, opt = {}) {
    let value = {
      value: wrapper
    };
    value[SYMBOL_SNAPSHOT_STRING] = true;
    value.preventSnapshotStore = true;
    try {
      expect(value).toMatchSnapshot();
      return "";
    } catch (e) {
      if (!e || !e.message || !e.message.startsWith(ERROR_MESSAGE_SNAPSHOT_STRING_PREFIX)) throw e;
      return e.message.substr(ERROR_MESSAGE_SNAPSHOT_STRING_PREFIX.length);
    }
  }
  print(val, serialize, ...rest) {
    this._nested = true;
    try {
      if (!val || typeof val !== "object" || !(SYMBOL_SNAPSHOT_STRING in val)) {
        val = {
          value: val,
          preventSnapshotStore: false
        };
      }
      let snapshotString = serialize(val.value);
      if (val.preventSnapshotStore) {
        throw new Error(ERROR_MESSAGE_SNAPSHOT_STRING_PREFIX + snapshotString);
      }
      this.lastSnapshotString = snapshotString;
      return snapshotString;
    } finally {
      this._nested = false;
    }
  }
  test(val) {
    return !this._nested;
  }
}
const SYMBOL_SNAPSHOT_WITH_COMMENT = Symbol.for("UU5.Test.Tools.SNAPSHOT_WITH_COMMENT");
class SnapshotCommentSerializer {
  print(val, serialize, ...rest) {
    return `/* ${val.comment} */\n` + serialize(val.value);
  }
  test(val) {
    return val && typeof val === "object" && SYMBOL_SNAPSHOT_WITH_COMMENT in val;
  }
}
const HookOuterComponent = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2___default().forwardRef(({
  children,
  initialHookParams,
  hook
}, ref) => {
  let [hookParams, setHookParams] = react__WEBPACK_IMPORTED_MODULE_2___default().useState(() => initialHookParams);
  react__WEBPACK_IMPORTED_MODULE_2___default().useImperativeHandle(ref, () => ({
    setHookParams
  }), []);
  let result = hook(...hookParams);
  // NOTE Using HookInnerComponent to measure render counts of subtrees (hooks are allowed to change their state during render
  // because it results in re-calling of the Component but not of its subtree - we don't want to measure these
  // shallow re-renders).
  // NOTE This also means that we'll collect only "committed" hook results.
  return Uu5g05.Utils.Element.create(HookInnerComponent, {
    result: result
  }, children);
});
const HookInnerComponent = ({
  children,
  result
}) => children(result);

// unmount components after each test
let container;
let lastWrapper;
let inTest = false;
function initTest() {
  afterEach(() => {
    if (lastWrapper && lastWrapper.length === 1) lastWrapper.unmount();
    if (container) react_dom__WEBPACK_IMPORTED_MODULE_3___default().unmountComponentAtNode(container);
    lastWrapper = null;
  });
  beforeEach(() => {
    inTest = true;
  });
  afterEach(() => {
    inTest = false;
  });
}
const Tools = {
  SnapshotCommentSerializer,
  SnapshotToStringSerializer,
  mount(jsx, options) {
    // NOTE Condition for inTest - UU5.Bricks.Page uses shallow outside of test to get an instance of Page component
    // and to pass it in "parent" prop => use minimal mount/shallow (and don't auto-unmount it)
    if (inTest) {
      if (!container) {
        container = document.createElement("div");
        document.body.appendChild(container);
      } else {
        react_dom__WEBPACK_IMPORTED_MODULE_3___default().unmountComponentAtNode(container);
        lastWrapper = null;
      }
    }
    let wrapper = (0,enzyme__WEBPACK_IMPORTED_MODULE_1__.mount)(jsx, {
      attachTo: container,
      ...options
    });
    if (inTest) lastWrapper = wrapper;
    return wrapper;
  },
  shallow(jsx, options) {
    // NOTE Condition for inTest - UU5.Bricks.Page uses shallow outside of test to get an instance of Page component
    // and to pass it in "parent" prop => use minimal mount/shallow (and don't auto-unmount it)
    if (lastWrapper) lastWrapper.unmount();
    let wrapper = (0,enzyme__WEBPACK_IMPORTED_MODULE_1__.shallow)(jsx, options);
    if (inTest) lastWrapper = wrapper;
    return wrapper;
  },
  act(fn, {
    updateWrapper = true
  } = {}) {
    // call react-dom's act() and update wrapper (if any)
    let originalSyncStack = new Error().stack;
    let actResult = react_dom_test_utils__WEBPACK_IMPORTED_MODULE_4___default().act(() => {
      let fnResult = fn();
      if (fnResult !== undefined && (!fnResult || typeof fnResult.then !== "function")) {
        // enforce proper behaviour (React logs just warning)
        let error = new Error(`The callback passed to act(...) function must return undefined, or a Promise. You returned ${fnResult}`);
        error.code = "INVALID_ARGUMENTS";
        error.stack = cleanupErrorStack(error.message, originalSyncStack);
        throw error;
      }
      return fnResult;
    });
    if (actResult && typeof actResult.then === "function") {
      // NOTE We don't want to access actResult.then() right away because react-dom has
      // overridden this particular "then" to provide warning in case that no-one is doing "await".
      // (And we don't want to do it via simple Promise.resolve().then(...) because that would enqueue
      // it for processing in the next tick and call "then" automatically.)
      let runPromise = () => new Promise((resolve, reject) => {
        actResult.then(v => {
          if (updateWrapper && lastWrapper) lastWrapper.update();
          resolve(v);
        }, e => {
          if (updateWrapper && lastWrapper) lastWrapper.update();
          reject(e);
        });
      });
      return {
        then: (onResolve, onReject) => runPromise().then(onResolve, onReject),
        catch: onReject => runPromise().catch(onReject)
      };
    } else {
      if (updateWrapper && lastWrapper) lastWrapper.update();
    }
    return actResult;
  },
  renderHook(hook, ...initialHookParams) {
    let {
      HookComponent,
      ...result
    } = Tools.initHookRenderer(hook, ...initialHookParams);
    let wrapper = Tools.mount(Uu5g05.Utils.Element.create(HookComponent, null));
    return {
      wrapper,
      ...result
    };
  },
  initHookRenderer(hook, ...initialHookParams) {
    if (typeof hook !== "function") {
      let error = new Error(`Invalid value used as a hook: ${hook}. Are you passing hook parameters but forgot to pass the hook?
Example:
  const { lastResult } = renderHook(useLsi, { "cs": "Ahoj", "en": "Hello" });
  const { lastResult } = initHookRenderer(useLsi, { "cs": "Ahoj", "en": "Hello" });`);
      error.code = "INVALID_ARGUMENTS";
      error.stack = cleanupErrorStack(error.message, error.stack);
      throw error;
    }
    if (typeof hook.name === "string" && !hook.name.match(/^use[A-Z]/)) {
      let error = new Error(`Invalid value used as a hook (hook name must start with 'use' followed by uppercase letter): "${hook.name}". Are you passing hook parameters but forgot to pass the hook?
Example:
  const { lastResult } = renderHook(useLsi, { "cs": "Ahoj", "en": "Hello" });
  const { lastResult } = initHookRenderer(useLsi, { "cs": "Ahoj", "en": "Hello" });`);
      error.code = "INVALID_ARGUMENTS";
      error.stack = cleanupErrorStack(error.message, error.stack);
      throw error;
    }
    let hookResults = [];
    let hookOuterComponentRef = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2___default().createRef();
    let HookComponent = ({
      children
    }) => Uu5g05.Utils.Element.create(HookOuterComponent, {
      ref: hookOuterComponentRef,
      initialHookParams: initialHookParams,
      hook: hook
    }, lastHookResult => {
      hookResults.push(lastHookResult);
      let child;
      if (typeof children === "function") child = children(lastHookResult);else if (children !== undefined) child = children;else child = Uu5g05.Utils.Element.create("div", null);
      return child;
    });
    return {
      HookComponent,
      lastResult: () => hookResults[hookResults.length - 1],
      allResults: () => [...hookResults],
      renderCount: () => hookResults.length,
      rerender: (...newHookParams) => {
        if (!hookOuterComponentRef.current) {
          throw new Error("Cannot re-render hook component because it wasn't mounted yet (or is already unmounted)!");
        }
        Tools.act(() => hookOuterComponentRef.current.setHookParams(newHookParams));
      }
    };
  },
  async waitUntilCalled(callbackFn, {
    timeout = DEFAULT_TIMEOUT,
    updateWrapper = true
  } = {}) {
    return Tools.waitUntilCalledTimes(callbackFn, 1, {
      timeout,
      updateWrapper
    });
  },
  async waitUntilCalledTimes(callbackFn, times, {
    timeout = DEFAULT_TIMEOUT,
    updateWrapper = true
  } = {}) {
    let originalSyncStack = new Error().stack;
    if (callbackFn.mock) {
      let now = Date.now();
      while (Date.now() - now < timeout) {
        if (callbackFn.mock.calls.length >= times) break;
        await Tools.wait({
          timeout: 2,
          updateWrapper: false
        });
      }
      if (callbackFn.mock.calls.length < times) {
        let error = new Error(`Mock function should have been called ${times} time(s) but was called only ${callbackFn.mock.calls.length} time(s) within specified timeout (${timeout}ms).`);
        error.code = "CALL_COUNT_TOO_LOW";
        error.stack = cleanupErrorStack(error.message, originalSyncStack);
        throw error;
      }
    }
    if (updateWrapper && lastWrapper) lastWrapper.update();
  },
  // wait() or wait(100) or wait({ timeout: 100, updateWrapper: true })
  async wait(...args) {
    let timeout, updateWrapper;
    if (typeof args[0] === "number") timeout = args.shift();else timeout = (args[0] || {}).timeout || 0;
    ({
      updateWrapper = true
    } = args[0] || {});
    if (timeout >= 0) {
      await Tools.act(() => new Promise(resolve => setTimeout(resolve, timeout)), {
        updateWrapper
      });
    }
  },
  async waitWhile(conditionFn, {
    timeout = DEFAULT_TIMEOUT,
    updateWrapper = true
  } = {}) {
    let originalSyncStack = new Error().stack;
    let now = Date.now();
    while (Date.now() - now < timeout) {
      let lastResult;
      await Tools.act(async () => lastResult = conditionFn(), {
        updateWrapper: false
      });
      if (!(await lastResult)) break;
      await Tools.wait({
        timeout: 2,
        updateWrapper
      });
    }
    if (Date.now() - now >= timeout) {
      let error = new Error(`Conditional wait did not finish within specified timeout (${timeout}ms).`);
      error.code = "TIMED_OUT";
      error.stack = cleanupErrorStack(error.message, originalSyncStack);
      throw error;
    }
    if (updateWrapper && lastWrapper) lastWrapper.update();
  },
  setInputValue(wrapper, value, focusBeforeSetting = true, blurAfterSetting = true) {
    let input = wrapper.type() === "input" ? wrapper : wrapper.find("input").first();
    if (input && input.length === 1) {
      if (focusBeforeSetting) {
        Tools.act(() => {
          input.simulate("focus");
        });
      }
      input.getDOMNode().value = value;
      Tools.act(() => {
        input.simulate("change");
      });
      if (blurAfterSetting) {
        Tools.act(() => {
          document.body.dispatchEvent(new MouseEvent("mousedown"));
        });
        Tools.act(() => {
          input.simulate("blur");
        });
        Tools.act(() => {
          document.body.dispatchEvent(new MouseEvent("mouseup"));
        });
        Tools.act(() => {
          document.body.dispatchEvent(new MouseEvent("click"));
        });
      }
    } else {
      let error = new Error("Input not found in specified wrapper.");
      error.code = "INPUT_NOT_FOUND";
      error.stack = cleanupErrorStack(error.message, error.stack);
      throw error;
    }
  },
  testProperty(Component, propName, values, requiredProps = null, opt = {}) {
    let originalSyncStack = new Error().stack;
    !Array.isArray(values) && (values = [values]);
    let {
      skip,
      wait
    } = opt;
    values.forEach((value, i) => {
      let testFn = skip ? it.skip : it;
      testFn(`${propName}=${toSafeJson(value)}`, async () => {
        let props = Object.assign({}, requiredProps);
        props[propName] = value;

        // NOTE Distinguishing here so that sync variant is really sync.
        let {
          wrapper,
          snapshotString
        } = wait || wait === undefined ? await takeSnapshotAsync(Uu5g05.Utils.Element.create(Component, _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({
          id: "uuID"
        }, props)), null, opt) : takeSnapshot(Uu5g05.Utils.Element.create(Component, _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({
          id: "uuID"
        }, props)), null, opt);
        let nextValue = values[values.length - 1 > i ? i + 1 : i === 0 ? values.length : i - 1];
        if (nextValue === undefined && requiredProps) nextValue = requiredProps[propName];
        if (nextValue !== undefined && nextValue !== value) {
          wrapper.setProps({
            [propName]: nextValue
          });
          if (wait || wait === undefined) await Tools.wait();
          wrapper.setProps({
            [propName]: value
          });
          if (wait || wait === undefined) await Tools.wait();
          let snapshotString2 = toStringSerializer ? toStringSerializer.getSnapshotString(wrapper, opt) : null;
          if (snapshotString2 !== snapshotString) {
            let chainProp = `${propName}=${toSafeJson(value)} --> ${propName}=${toSafeJson(nextValue)} --> ${propName}=${toSafeJson(value)}`;
            let simpleProp = `${propName}=${toSafeJson(value)}`;
            // TODO Use some diff to show differences.
            let error = new Error(`Changing props dynamically from ${chainProp} results in different snapshot than if simply using ${simpleProp}!
/* ${chainProp} */
${snapshotString2}

/* ${simpleProp} */
${snapshotString}`);
            error.code = "PROP_CHANGE_PRODUCES_DIFFERENT_SNAPSHOT";
            error.stack = cleanupErrorStack(error.message, originalSyncStack);
            throw error;
          }
        }
      });
    });
  },
  testProperties(Component, config) {
    // guard against most common error
    if (typeof Component === "string") {
      let error = new Error("Invalid arguments to testProperties - 1st argument must be a component class but it is string.");
      error.code = "INVALID_ARGUMENTS";
      error.stack = cleanupErrorStack(error.message, error.stack);
      throw error;
    }
    test(`default props`, async () => {
      // NOTE Distinguishing here so that sync variant is really sync.
      if (!config.opt || config.opt.wait === undefined || config.opt.wait) {
        await takeSnapshotAsync(Uu5g05.Utils.Element.create(Component, _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({
          id: "uuID"
        }, config.requiredProps)), null, config.opt);
      } else {
        takeSnapshot(Uu5g05.Utils.Element.create(Component, _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({
          id: "uuID"
        }, config.requiredProps)), null, config.opt);
      }
    });
    if (config.mixins) {
      config.mixins.forEach(mixinName => {
        let mixinProps = _mixin_props_js__WEBPACK_IMPORTED_MODULE_5__["default"][mixinName];
        if (mixinProps) {
          for (let propName in mixinProps) {
            if (propName in config.props) continue;
            let requiredProps = {
              ...config.requiredProps,
              ...mixinProps[propName].requiredProps
            };
            Tools.testProperty(Component, propName, mixinProps[propName].values, requiredProps, {
              ...config.opt,
              ...mixinProps[propName].opt
            });
          }
        }
      });
    }
    for (let propName in config.props) {
      let requiredProps = {
        ...config.requiredProps,
        ...config.props[propName].requiredProps
      };
      Tools.testProperty(Component, propName, config.props[propName].values, requiredProps, {
        ...config.opt,
        ...config.props[propName].opt
      });
    }
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tools);

/***/ }),

/***/ "../target/webpack-tmp/test/test-build.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mod = __webpack_require__("module");
var isDoc = typeof document !== "undefined";
var uri = ((mod ? mod.uri : isDoc && (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName("script"), -1)[0] || {}).src) || "").toString();
uri = uri.split(/\//).slice(0, -1).join("/") + "/"; // runtime publicPath configuration required for proper linking of styles, background images, ...
var floatingVersion = "/1.0.0/";
if (uri.substr(-floatingVersion.length) === floatingVersion) uri = uri.substr(0, uri.length - floatingVersion.length) + "/1.58.8/";
__webpack_require__.p = (typeof process !== "undefined" && process.env && (process.env.NODE_ENV) || "development") === "test" && uri === "/" ? "file://" + eval("__filename").replace(/[^/\\]*$/, "") : uri;
module.exports = __webpack_require__("./test/test-build.js");
var ex = module.exports;
if (ex && typeof ex === "object") {
  if (!("version" in ex)) Object.defineProperty(ex, "version", {
    configurable: true,
    value: "1.58.8"
  });
  if (!("name" in ex)) Object.defineProperty(ex, "name", {
    configurable: true,
    value: "uu5g04-test".split(/[\/\\]/).pop()
  });
  if (!("namespace" in ex)) Object.defineProperty(ex, "namespace", {
    configurable: true,
    value: "UU5.Test"
  });
}

/***/ }),

/***/ "enzyme":
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_enzyme__;

/***/ }),

/***/ "module":
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_module__;

/***/ }),

/***/ "react":
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_react__;

/***/ }),

/***/ "react-dom":
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_react_dom__;

/***/ }),

/***/ "react-dom/test-utils":
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_react_dom_test_utils__;

/***/ }),

/***/ "uu5g04":
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_uu5g04__;

/***/ }),

/***/ "../../node_modules/uu_appg01_devkit/node_modules/@babel/runtime/helpers/defineProperty.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toPropertyKey = __webpack_require__("../../node_modules/uu_appg01_devkit/node_modules/@babel/runtime/helpers/toPropertyKey.js");
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../../node_modules/uu_appg01_devkit/node_modules/@babel/runtime/helpers/extends.js":
/***/ ((module) => {

function _extends() {
  module.exports = _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _extends.apply(this, arguments);
}
module.exports = _extends, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../../node_modules/uu_appg01_devkit/node_modules/@babel/runtime/helpers/toPrimitive.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__("../../node_modules/uu_appg01_devkit/node_modules/@babel/runtime/helpers/typeof.js")["default"]);
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
module.exports = _toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../../node_modules/uu_appg01_devkit/node_modules/@babel/runtime/helpers/toPropertyKey.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__("../../node_modules/uu_appg01_devkit/node_modules/@babel/runtime/helpers/typeof.js")["default"]);
var toPrimitive = __webpack_require__("../../node_modules/uu_appg01_devkit/node_modules/@babel/runtime/helpers/toPrimitive.js");
function _toPropertyKey(arg) {
  var key = toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../../node_modules/uu_appg01_devkit/node_modules/@babel/runtime/helpers/typeof.js":
/***/ ((module) => {

function _typeof(obj) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "../../node_modules/uu_appg01/package.json":
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"uu_appg01","version":"5.20.1","description":"The uuAppServer is the standardized solution for creating the server side of applications in the uuApp Framework.","license":"UAF","namespace":"UuApp","spec":"lib; uu_appg01_devkit@4.0.1","dependencies":{"uu_appg01_core":"^5.17.0","uu_appg01_oidc":"^3.7.0","uu_appg01_server-client":"^5.17.0"},"uuBuildSettings":{"transpileDependencies":true,"externals":{"uu_appg01_server-client":false}},"devDependencies":{"uu_appg01_devkit":"^5.14.0"},"engines":{"node":">=14.0.0"},"scripts":{"clean":"uu_appg01_devkit clean","test":"uu_appg01_devkit test","testBrowser":"uu_appg01_devkit testBrowser","build":"uu_appg01_devkit build","package":"uu_appg01_devkit package","start":"uu_appg01_devkit start","deploy":"uu_appg01_devkit deploy","uuAppDevKitUpgrade":"uu_appg01_devkit uuAppDevKitUpgrade"},"main":"./src/index.js","prettier":{"printWidth":120},"homepage":"https://cdn.plus4u.net/uu-appg01/4.6.0/doc/index.html","browser":"index-browser.js"}');

/***/ }),

/***/ "../../node_modules/uu_appg01_oidc/package.json":
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"uu_appg01_oidc","version":"3.9.0","description":"The uuAppServer is the standardized solution for creating the server side of applications in the uuApp Framework.","license":"UAF","namespace":"UuApp.Oidc","spec":"lib; uu_appg01_devkit@4.0.1","dependencies":{"jsrsasign":"^10.5.1","opn":"^5.4.0","uu_appg01_core-appclient":"^5.0.0","uu_appg01_core-authentication":"^5.3.0","uu_appg01_cache":"^0.9.1","uu_appg01_core-logging":"^5.0.0","uu_appg01_core-uri":"^5.0.0","uu_appg01_core-utils":"^5.0.0"},"uuBuildSettings":{"transpileDependencies":true,"externals":{"uu_appg01_core":"UuApp"}},"devDependencies":{"uu_appg01_core":"^5.0.0","uu_appg01_core-test":"^5.0.0","uu_appg01_devkit":"^5.14.0"},"engines":{"node":">=12.17.0"},"scripts":{"clean":"uu_appg01_devkit clean","test":"uu_appg01_devkit test","testBrowser":"uu_appg01_devkit testBrowser","build":"uu_appg01_devkit build","package":"uu_appg01_devkit package","start":"uu_appg01_devkit start","deploy":"uu_appg01_devkit deploy","uuAppDevKitUpgrade":"uu_appg01_devkit uuAppDevKitUpgrade"},"main":"src/index.js","prettier":{"printWidth":120},"browser":"index-browser.js","homepage":"https://cdn.plus4u.net/uu-appg01-oidc/0.0.0/doc/index.html","peerDependencies":{"uu_appg01_core":"^5.0.0","uu_appg01_core-appserver":"^5.0.0"}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "";
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("../target/webpack-tmp/test/test-build.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});