/*!
 * UAF COMMERCIAL LICENSE
 * ----------------------
 * 1. PREAMBLE and Definitions
 *   1.1 These UAF Commercial License Terms ("UAF CLT") govern licensing of the Unicorn Application Framework (UAF).
 *     The Customer and Unicorn concluded an agreement for the provision of Solution that is using UAF or its parts
 *     (the "Agreement").
 *   1.2 The provisions of these UAF CLT shall govern the relationship between the Customer and Unicorn regarding
 *     the UAF License granted under the Agreement. For the avoidance of doubt, in case of any conflict between these
 *     UAF CLT and the Agreement, the provisions of the Agreement always prevail.
 *   1.3 The "UAF Components", and each of them individually as "UAF Component", shall mean the components of the Unicorn
 *     Application Framework, which are listed and described in the Attachment I to these UAF CLT.
 *   1.4 "UAF" shall mean the Unicorn Application Framework the scope of which is described in Attachment I, including all
 *     associated documentation and preparatory design materials, in particular blueprints, models, user manuals,
 *     training materials, comprehensive instructions and guidelines for drafting, production, operation and maintenance of
 *     software solutions, reference architecture, ready-made components and tools, use cases and tutorials.
 *   1.5 The "Knowledge Base" shall mean the online materials, internet fora and other resources made available by Unicorn
 *     online with regard to the UAF, intended for the broad customer and developer community.
 *   1.6 The "License" shall mean the binding terms and conditions for use of the UAF by the Customer. The License is
 *     described in Clause 2 and may be further specified or modified by the Agreement.
 *   1.7 The "Solution" shall mean any product or service developed under the Agreement using the UAF or any of
 *     UAF Components or its other parts, further specified in the Agreement.
 * 2. LICENSE GRANT
 *   2.1 The Customer shall be hereby granted a non-exclusive and non-transferable worldwide license to use the UAF for
 *     the purpose of the Solution described in the Agreement. For this purpose, the Customer shall be entitled to modify
 *     the UAF and create derivative works based on the UAF.
 *   2.2 The Customer is entitled to grant third parties a sub-license allowing them to use the UAF or any derivative works
 *     based on the UAF under commercial terms of its choice, provided that:
 *     2.2.1 use of the UAF and any derivative works based on the UAF by third parties is limited to testing, handover and
 *       operation of the Solution or its use as a service,
 *     2.2.2 third parties are not entitled to use the UAF or any derivative works based on the UAF independently of
 *       the Solution,
 *     2.2.3 third parties are not provided access to source code of the UAF unless such right is granted by the Agreement
 *       or if they conclude a commercial license agreement with Unicorn.
 *   2.3 The Solution or its parts based on the UAF shall bear a prominent copyright notice "Based on Unicorn Application
 *     Framework Copyright (c) Unicorn" integrated
 *     2.3.1 in the graphical user interface of the Solution or its relevant part or
 *     2.3.2 in accompanying file if the Solution or its relevant part do not have graphical user interface or
 *     2.3.3 in Solution's documentation.
 *   2.4 The License shall be valid for the whole duration of copyright to the UAF, unless other duration of the License is
 *     specified in the Agreement.
 *   2.5 The Customer is entitled to access the Knowledge Base only if expressly agreed in the Agreement.
 *   2.6 The Unicorn retains all rights to the UAF not covered by the provisions of this Clause 2. Unless explicitly
 *     permitted by applicable law, the Customer may not use the UAF in any other way than provided by the provisions of
 *     this Clause 2 and may not allow such use on its behalf by any of its employees or agents.
 *   2.7 The price for the License is included in the price stipulated in the Agreement.
 * 3. MODIFICATIONS
 *   3.1 The Customer explicitly acknowledges that the UAF is under continuous development and any UAF Component or other
 *     part of the UAF may be modified, replaced or removed by the Unicorn from the UAF in any of its future versions.
 *   3.2 This License covers also any new version of UAF if some parts of the UAF are modified or replaced.
 *   3.3 If any part of the UAF is removed by Unicorn in any of its future versions, the License for such version of
 *     the UAF is reduced appropriately and covers only the remaining parts of UAF. Sub-licenses previously granted to
 *     third parties in accordance with Clause 2.2 remain unaffected.
 * 4. THIRD PARTY LICENSE TERMS
 *   4.1 UAF is using third party software tools (the "Third Party Software") that is an integral part of the UAF. Some of
 *     these tools are free software or open-source SW.
 *   4.2 The list of Third Party Software used in the UAF including its license terms and authors is provided as part of
 *     Attachment I to these UAF CLT.
 *   4.3 For the use of the above mentioned Third Party Software, the Customer acknowledges its license terms referred to
 *     in Attachment I to these UAF CLT.
 * 5. NO TRADEMARK OR PATENT LICENSE
 *   5.1 These UAF CLT cover only copyright use of the UAF. If not expressly agreed otherwise, the Customer shall not be
 *     granted any trademark and/or patent license here under and nothing in these UAF CLT shall be interpreted in a way it
 *     does so.
 * 6. LIMITED WARRANTY
 *   6.1 IF NOT STIPULATED OTHER WISE OR REQUIRED BY APPLICABLE LAW, THE UAF IS PROVIDED ON "AS IS" BASIS,
 *     WITH NO WARRANTY OF, INCLUDING WITHOUT LIMITATION, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE
 *     RISK AS TO THE QUALITY AND PERFORMANCE OF THE UAF IS CARRIED SOLELY BY THE CUSTOMER, UNLESS OTHERWISE AGREED BETWEEN
 *     THE UNICORN AND THE CUSTOMER IN THE AGREEMENT.
 * 7. LIMITATION OF LIABILITY
 *   7.1 TO THE EXTENT PERMITTED BY APPLICABLE LAW, THE UNICORN WILL NOT BE HELD LIABLE FOR ANY DAMAGES CAUSED BY
 *     THE DISTRIBUTION OR USE OF THE UAF. THIS ALSO INCLUDES ANY CONSEQUENTIAL AND/OR INCIDENTAL DAMAGES, MONETARY OR NOT,
 *     THAT ARE CONNECTED WITH THE DISTRIBUTION OR USE OF THE UAF, UNLESS OTHERWISE AGREED BETWEEN THE UNICORN AND
 *     THE CUSTOMER IN THE AGREEMENT.
 * 8. THIRD PARTY CLAIMS
 *   8.1 The Unicorn will defend or settle, at its option and expense, any action brought against the Customer in a member
 *     state of the European Union which concerns an allegation that the UAF provided infringes a patent or copyright or
 *     misappropriates a trade secret in such jurisdiction. The Unicorn shall pay costs and damages finally awarded against
 *     the Customer that are attributable to such action. The Customer declares to understand and agrees that following
 *     conditions must be fulfilled in order to make Unicorn's obligations under this Clause 8 effective and enforceable:
 *     The Customer must (a) notify Unicorn promptly in writing of the action or any reasonable threat of it,
 *     (b) provide the Unicorn with all reasonable information and assistance it will request to settle or defend the action, and
 *     (c) grant the Unicorn sole authority and control of the defense or settlement of the action.
 *   8.2 If a claim is made under Clause 8.1 the Unicorn may, at its sole option and expense:
 *     (a) replace or modify the UAF so that it becomes non-infringing,
 *     (b) procure for the Customer the right to continue using the UAF unmodified.
 *   8.3 The Unicorn shall not be held liable to the Customer if the action is based on:
 *     (a) the combination of UAF with any product not provided by Unicorn,
 *     (b) the modification of the UAF other than by Unicorn,
 *     (c) the use of other than a current unaltered release of the UAF,
 *     (d) a product that the Customer makes, uses, or sells,
 *     (e) infringement by the Customer that is deemed willful. In the case under (e) the Customer shall reimburse
 *     the Unicorn for its reasonable attorney fees and other costs related to the action.
 *   8.4 THIS CLAUSE IS SUBJECT TO CLAUSE 7 AND STATES UNICORN'S ENTIRE LIABILITY, CUSTOMER'S SOLE AND EXCLUSIVE REMEDY,
 *     FOR DEFENSE, SETTLEMENT AND DAMAGES, WITH RESPECT TO ANY ALLEGED PATENT OR COPYRIGHT INFRINGEMENT OR TRADE SECRET
 *     MISAPPROPRIATION BY ANY ITEM PROVIDED UNDER THESE TERMS, UNLESS OTHERWISE AGREEMENT BETWEEN UNICORN AND THE CUSTOMER
 *     IN THE AGREEMENT.
 * 9. GENERAL PROVISIONS
 *   9.1 By entering into the Agreement, the Customer signifies its assent to and acceptance of these UAF CLT.
 *   9.2 The License is effective from the moment of execution of the Agreement, if the Agreement does not specify later
 *     date. Where the provisions of the Agreement regarding the License and provisions of these UAF CLT differ, provisions
 *     of the Agreement shall prevail.
 *   9.3 If any provision of the Agreement regarding the License or these UAF CLT is held by a court of competent
 *     jurisdiction to be void, invalid, unenforceable or illegal, such provision shall be severed from the Agreement or
 *     these UAF CLT and the remaining provisions will remain in full force and effect.
 *   9.4 The provisions of Clauses 7 and 8 shall survive any expiration or termination of the Agreement.
 *   9.5 All rights and obligations between the Unicorn and the Customer arising on the basis of these UAF CLT or
 *     in connection with them are governed by the laws of the Czech Republic with the exclusion of both the rules on
 *     the conflict of laws and the United Nations Convention on Contracts for the International Sale of Goods (CISG).
 *   9.6 The resolution of all disputes arising from or connected here to shall be under sole jurisdiction of the courts of
 *     the Czech Republic.
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("module"));
	else if(typeof define === 'function' && define.amd)
		define("uu5stringg01", ["module"], factory);
	else if(typeof exports === 'object')
		exports["uu5stringg01"] = factory(require("module"));
	else
		root["Uu5String"] = factory(root["undefined"]);
})(this, (__WEBPACK_EXTERNAL_MODULE_module__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  get Uu5String() {
    return __webpack_require__("./uu5-string.js");
  },
  get Uu5Json() {
    return __webpack_require__("./uu5-json.js");
  },
  get Uu5Data() {
    return __webpack_require__("./uu5-data.js");
  }
};
if (typeof window !== "undefined" && (typeof process !== "undefined" && process.env && (process.env.NODE_ENV) || "development") !== "test") {
  console.log(`${"uu5stringg01"}-${"1.9.1"} © Unicorn\nTerms of Use: https://unicorn.com/tou/${"uu5stringg01"}`);
}

/***/ }),

/***/ "./internal/constants.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright (C) 2019 Unicorn a.s.
 *
 * This program is free software; you can use it under the terms of the UAF Open License v01 or
 * any later version. The text of the license is available in the file LICENSE or at www.unicorn.com.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See LICENSE for more details.
 *
 * You may contact Unicorn a.s. at address: V Kapslovne 2767/2, Praha 3, Czech Republic or
 * at the email: info@unicorn.com.
 */

const {
  REGEXP
} = __webpack_require__("./internal/uu5-common-tools.js");
const UU5STRING_REGEXP = REGEXP.uu5string;
const UU5JSON_REGEXP = REGEXP.uu5json;
const UU5DATA_REGEXP = REGEXP.uu5data;
const JSCODE_REGEXP = REGEXP.jsCode;
const FORBIDDEN_TAGS_REGEXP = /^(applet|base|body|embed|form|frame|frameset|iframe|head|html|link|meta|noframes|object|script|template)$/i;
const FORBIDDEN_TAGS_REGEXP2 = /^(?!uu5string\.[^.]*$).*\.[a-z][^.]*$/; // forbidden, if last tag segment starts with lowercase (for multi-segment tags), except for "uu5string.*", e.g. "uu5string.pre"
const FORBIDDEN_ATTRS_REGEXP = /^(dangerouslySetInnerHTML)$/i;
const COMPONENT_NAME = String.raw`[-\w.]+(_g\d\dv\d+)?`;
const ATTR = String.raw`(\s+)([-\w]+)(?:(\s*=\s*)("(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|([^"'>\s/][^>\s/]*)))?`; // groups: attr separator, attr name, value separator, attr value, indication whether without quotes
const TAG = String.raw`<(${COMPONENT_NAME})((?:${ATTR})*)\s*(/)?>|</(${COMPONENT_NAME})>`; // groups: comp name, comp name suffix, attrs, -, -, -, self-closing, closing tag
const ATTR_REGEXP = new RegExp(ATTR); // groups: see ATTR
const ATTR_VALUE_TYPE_REGEXP = new RegExp(String.raw`(${REGEXP.uu5json.source})|(${REGEXP.uu5string.source})|(${REGEXP.uu5data.source})|`); // groups: uu5json, uu5string, uu5data
const BROKEN_DOUBLE_QUOTED_VALUE = String.raw`("(?:\\.|[^"\\])*)"(?:\\.|[^\\>=])*"`;
const BROKEN_SINGLE_QUOTED_VALUE = String.raw`('(?:\\.|[^'\\])*)'(?:\\.|[^\\>=])*'`;
const BROKEN_ATTR_WITH_QUOTE = String.raw`(\s+[-\w]+\s*=\s*)(?:${BROKEN_DOUBLE_QUOTED_VALUE}|${BROKEN_SINGLE_QUOTED_VALUE})`;
const TAG_WITH_MAYBE_BROKEN_ATTR_WITH_QUOTE = String.raw`(<(${COMPONENT_NAME}))((?:${ATTR}|${BROKEN_ATTR_WITH_QUOTE})*)\s*(/)?>|</(${COMPONENT_NAME})>`;
const TEMPLATE_REG_EXP = new RegExp(REGEXP.uu5stringTemplate.source, "g");
const CHECK_IS_TEMPLATE = new RegExp(`^${REGEXP.uu5stringTemplate.source}$`);
const DEFAULT_SEPARATOR = " ";
const DEFAULT_BOUNDARIES = '"';
const DEFAULT_VALUE_DELIMITER = "=";

// if longer than this, Safari won't parse attribute with such uu5string properly, probably due to regexp buffer limit
const UU5STRING_LENGTH_LIMIT = 950000;
module.exports = {
  UU5STRING_REGEXP,
  UU5JSON_REGEXP,
  UU5DATA_REGEXP,
  JSCODE_REGEXP,
  FORBIDDEN_TAGS_REGEXP,
  FORBIDDEN_TAGS_REGEXP2,
  FORBIDDEN_ATTRS_REGEXP,
  COMPONENT_NAME,
  ATTR,
  TAG,
  BROKEN_ATTR_WITH_QUOTE,
  TAG_WITH_MAYBE_BROKEN_ATTR_WITH_QUOTE,
  ATTR_REGEXP,
  ATTR_VALUE_TYPE_REGEXP,
  TEMPLATE_REG_EXP,
  CHECK_IS_TEMPLATE,
  DEFAULT_SEPARATOR,
  DEFAULT_BOUNDARIES,
  DEFAULT_VALUE_DELIMITER,
  UU5STRING_LENGTH_LIMIT
};

/***/ }),

/***/ "./internal/factory.js":
/***/ ((module) => {

let Uu5String;
let Uu5StringObject;
let Uu5StringProps;

// NOTE This serves as classes factory. uu5g04 uses its own (because g04 uses different method APIs
// for Uu5String, Uu5StringObject and Uu5StringProps). The factory is injected into classes via options
// (_factory field) where needed.
// If uu5g04 is no longer supported, this can be removed together with _factory fields.
module.exports = class Factory {
  static init(Uu5String0, Uu5StringObject0, Uu5StringProps0) {
    // initializes variables (prevents cyclic dependencies); should be called on 1st use
    Uu5String = Uu5String0;
    Uu5StringObject = Uu5StringObject0;
    Uu5StringProps = Uu5StringProps0;
  }
  static createString(...args) {
    return new Uu5String(...args);
  }
  static createObject(...args) {
    return new Uu5StringObject(...args);
  }
  static createProps(...args) {
    return new Uu5StringProps(...args);
  }
};

/***/ }),

/***/ "./internal/symbols.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright (C) 2019 Unicorn a.s.
 *
 * This program is free software; you can use it under the terms of the UAF Open License v01 or
 * any later version. The text of the license is available in the file LICENSE or at www.unicorn.com.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See LICENSE for more details.
 *
 * You may contact Unicorn a.s. at address: V Kapslovne 2767/2, Praha 3, Czech Republic or
 * at the email: info@unicorn.com.
 */

const Tools = __webpack_require__("./internal/uu5-common-tools.js");
const SYMBOLS = {
  now: () => {
    let date = new Date(Date.now());
    return date.toISOString();
  },
  idHex32: defValue => defValue || Tools.generateId(32),
  idHex64: defValue => defValue || Tools.generateId(64)
};
module.exports = SYMBOLS;

/***/ }),

/***/ "./internal/text-entity-map.js":
/***/ ((module) => {

/**
 * Copyright (C) 2019 Unicorn a.s.
 *
 * This program is free software; you can use it under the terms of the UAF Open License v01 or
 * any later version. The text of the license is available in the file LICENSE or at www.unicorn.com.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See LICENSE for more details.
 *
 * You may contact Unicorn a.s. at address: V Kapslovne 2767/2, Praha 3, Czech Republic or
 * at the email: info@unicorn.com.
 */

const HtmlEntityMap = {
  re: /(&#?[a-z0-9]+;)/g,
  items: {
    "&amp;": "&",
    "&#38;": "&",
    "&apos;": "'",
    "&#39;": "'",
    "&quot;": '"',
    "&#34;": '"',
    "&lt;": "<",
    "&#060;": "<",
    "&gt;": ">",
    "&#062;": ">",
    "&hellip;": "…",
    "&#133;": "…",
    "&mdash;": "—",
    "&#8212;": "—",
    "&pi;": "π",
    "&#8719;": "π",
    "&reg;": "®",
    "&#174;": "®",
    "&#8730;": "√",
    "&radic;": "√",
    "&#8734;": "∞",
    "&infin;": "∞",
    "&#160;": " ",
    "&nbsp;": " ",
    "&#8592;": "←",
    "&larr;": "←",
    "&#8594;": "→",
    "&rarr;": "→",
    "&#8595;": "?",
    "&darr;": "?",
    "&#169;": "©",
    "&copy;": "©",
    "&trade;": "™",
    "&pound;": "£",
    "&euro;": "€",
    "&prod;": "∏",
    "&sum;": "∑",
    "&int;": "∫",
    "&le;": "≤",
    "&ge;": "≥",
    "&#92;": "\\",
    "&sup2;": "²",
    "&sup3;": "³"
  }
};
const AsciiEmojiMap = {
  //:) :D :O :* :( :| :S :Z :$ :P :/   ;-)     :'-(   ,:-(   ,:-)   O:-)       8-) X-)    :-")  :'-)        :,'-(          ";-(   ]:-)   <3
  re: /(:-[)(DOo*|$SsZzP/@]|;-\)|:[',]-\(|,:-\(|,:-\)|[0oO]:-\)|[B8Xx]-\)|:-"\)|:[',]-[)D]|:(?:,'|',)-\(|";-\(|]:-\)|<\/?3)/g,
  items: {
    ":-)": "🙂",
    ";-)": "😉",
    ":-(": "😦",
    ":'-(": "😢",
    ":,-(": "😢",
    ":-D": "😄",
    ":-o": "😮",
    ":-O": "😮",
    ":-*": "😘",
    ",:-(": "😓",
    ",:-)": "😅",
    "0:-)": "😇",
    "O:-)": "😇",
    "o:-)": "😇",
    "8-)": "😎",
    "B-)": "😎",
    ':-")': "😊",
    ":-$": "😒",
    ":'-)": "😂",
    ":'-D": "😂",
    ":,-)": "😂",
    ":,-D": "😂",
    ":,'-(": "😭",
    '";-(': "😭",
    ":-/": "😕",
    ":-@": "😡",
    ":-P": "😛",
    ":-S": "😒",
    ":-Z": "😒",
    ":-s": "😒",
    ":-z": "😒",
    ":-|": "😐",
    "]:-)": "😈",
    "X-)": "😆",
    "x-)": "😆",
    "</3": "💔",
    "<3": "💗"
  }
};
const ExtendedEmojiMap = {
  re: /#\(([a-z\-]+)\)/g,
  items: {
    baby: "👶",
    boy: "👦",
    girl: "👧",
    man: "👨",
    woman: "👩",
    "old-man": "👴",
    "old-woman": "👵",
    cow: "🐄",
    horse: "🐎",
    tiger: "🐅",
    elephant: "🐘",
    "unicorn-face": "🦄",
    pig: "🐖",
    "pig-face": "🐷",
    "pig-nose": "🐽",
    rat: "🐀",
    mouse: "🐁",
    "hamster-face": "🐹",
    bat: "🦇",
    chicken: "🐔",
    dolphin: "🐬",
    fish: "🐟",
    crocodile: "🐊",
    snake: "🐍",
    whale: "🐋",
    octopus: "🐙",
    spider: "🕷",
    "panda-face": "🐼",
    "bear-face": "🐻",
    boar: "🐗",
    dog: "🐕",
    "dog-face": "🐶",
    cat: "🐈",
    "cat-face": "🐱",
    snail: "🐌",
    butterfly: "🦋",
    ant: "🐜",
    fire: "🔥",
    "skull-with-crossbones": "☠",
    bomb: "💣",
    "light-bulb": "💡",
    hammer: "🔨",
    wrench: "🔧",
    key: "🔑",
    gear: "⚙",
    coffin: "⚰",
    moai: "🗿",
    beer: "🍺",
    volcano: "🌋",
    "pile-of-poo": "💩",
    shit: "💩",
    "broken-heart": "💔",
    heart: "❤️",
    love: "💘",
    alien: "👽",
    "robot-face": "🤖",
    skull: "💀",
    ghost: "👻",
    cloud: "☁",
    "thumbs-up": "👍",
    "thumbs-down": "👎",
    "index-finger": "☝️",
    "sign-of-the-horns": "🤘",
    "vulcan-salute": "🖖",
    "clapping-hands": "👏",
    handshake: "🤝",
    "ok-hand": "👌",
    "raised-hand": "✋",
    "five-finger-hand": "🖐",
    "middle-finger": "🖕",
    "raised-fist": "✊",
    "victory-hand": "✌",
    "crossed-fingers": "🤞",
    "writing-hand": "✍️",
    kiss: "💋",
    anchor: "⚓",
    airplane: "✈",
    sailboat: "⛵",
    car: "🚗",
    truck: "🚚",
    train: "🚆",
    tractor: "🚜",
    ship: "🚢",
    rocket: "🚀",
    helicopter: "🚁",
    ball: "⚽",
    czechia: "🇨🇿",
    "united-states": "🇺🇸",
    germany: "🇩🇪",
    ukraine: "🇺🇦",
    slovakia: "🇸🇰",
    netherlands: "🇳🇱",
    spain: "🇪🇸",
    "united-kingdom": "🇬🇧",
    croatia: "🇭🇷",
    "skin-light": "🏻",
    "skin-medium-light": "🏼",
    "skin-medium": "🏽",
    "skin-medium-dark": "🏾",
    "skin-dark": "🏿"
  }
};
const TextEntityMap = {
  _re: null,
  _htmlEntity: true,
  get htmlEntity() {
    return this._htmlEntity;
  },
  set htmlEntity(s) {
    if (s !== this._htmlEntity) {
      this._htmlEntity = s;
      this.recompile();
    }
  },
  _htmlEntityMap: HtmlEntityMap,
  replaceHtmlEntity(text) {
    const reg = new RegExp(`(\\\\)?${this._htmlEntityMap.re.source}`, "g");
    if (this.htmlEntity) text = text.replace(reg, (m0, m1, m2) => m1 ? m2 : this._htmlEntityMap.items[m2] || m2);
    return text;
  },
  _asciiEmoji: true,
  get asciiEmoji() {
    return this._asciiEmoji;
  },
  set asciiEmoji(s) {
    if (s !== this.asciiEmoji) {
      this._asciiEmoji = s;
      this.recompile();
    }
  },
  _asciiEmojiMap: AsciiEmojiMap,
  replaceAsciiEmoji(text) {
    const reg = new RegExp(`(\\\\)?${this._asciiEmojiMap.re.source}`, "g");
    if (this.asciiEmoji) text = text.replace(reg, (m0, m1, m2) => m1 ? m2 : this._asciiEmojiMap.items[m2] || m2);
    return text;
  },
  _extendedTextEntity: true,
  get extendedTextEntity() {
    return this._extendedTextEntity;
  },
  set extendedTextEntity(s) {
    if (s !== this._extendedTextEntity) {
      this._extendedTextEntity = s;
      this.recompile();
    }
  },
  _extendedTextEntityMapList: [ExtendedEmojiMap],
  _textEntityRegexGroups: {},
  replace(text) {
    const eteg = this._textEntityRegexGroups;
    const count = this._reGroupsCount;
    return text.replace(this._re, (match, esc, ...groups) => {
      let r = match;
      if (esc) r = match.slice(1);else for (let i = 0; i < count; i++) {
        if (groups[i]) {
          r = eteg[i].items[groups[i]] || r;
          break;
        }
      }
      return r;
    });
  },
  addExtendedTextEntityMap(map) {
    if (!this._extendedTextEntityMapList.some(item => item === map)) this._extendedTextEntityMapList.push(map);
  },
  removeExtendedTextEntityMap(map) {
    this._extendedTextEntityMapList = this._extendedTextEntityMapList.filter(item => item !== map);
  },
  get extendedTextEntityMapList() {
    return this._extendedTextEntityMapList;
  },
  recompile() {
    if (this.htmlEntity || this.asciiEmoji || this.extendedTextEntity) {
      let reA = [];
      let i = 0;
      this._textEntityRegexGroups = {};
      if (this.htmlEntity) {
        reA.push(this._htmlEntityMap.re.source);
        this._textEntityRegexGroups[i] = this._htmlEntityMap;
        i++;
      }
      if (this.asciiEmoji) {
        reA.push(this._asciiEmojiMap.re.source);
        this._textEntityRegexGroups[i] = this._asciiEmojiMap;
        i++;
      }
      if (this.extendedTextEntity) {
        this._extendedTextEntityMapList.forEach(item => {
          reA.push(item.re.source);
          this._textEntityRegexGroups[i] = item;
          i++;
        });
      }
      this._reGroupsCount = i;
      this._re = new RegExp(`(\\\\)?(?:${reA.join("|")})`, "g");
    } else this._re = null;
  }
};

//precompile regex
TextEntityMap.recompile();
module.exports = TextEntityMap;

/***/ }),

/***/ "./internal/tools.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright (C) 2019 Unicorn a.s.
 *
 * This program is free software; you can use it under the terms of the UAF Open License v01 or
 * any later version. The text of the license is available in the file LICENSE or at www.unicorn.com.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See LICENSE for more details.
 *
 * You may contact Unicorn a.s. at address: V Kapslovne 2767/2, Praha 3, Czech Republic or
 * at the email: info@unicorn.com.
 */

const SYMBOLS = __webpack_require__("./internal/symbols.js");
const {
  TAG,
  TEMPLATE_REG_EXP,
  UU5STRING_REGEXP,
  ATTR_REGEXP,
  ATTR_VALUE_TYPE_REGEXP,
  UU5DATA_REGEXP,
  JSCODE_REGEXP,
  DEFAULT_SEPARATOR,
  DEFAULT_BOUNDARIES,
  DEFAULT_VALUE_DELIMITER,
  FORBIDDEN_TAGS_REGEXP,
  FORBIDDEN_TAGS_REGEXP2,
  FORBIDDEN_ATTRS_REGEXP,
  UU5JSON_REGEXP,
  TAG_WITH_MAYBE_BROKEN_ATTR_WITH_QUOTE,
  ATTR,
  BROKEN_ATTR_WITH_QUOTE
} = __webpack_require__("./internal/constants.js");
const TextEntityMap = __webpack_require__("./internal/text-entity-map.js");
const Uu5Data = __webpack_require__("./uu5-data.js");
const Uu5Json = __webpack_require__("./uu5-json.js");
const Tools = {
  /*
    Transform content into React components.
     @param content - array of Uu5StringObjects, strings, numbers, booleans and Uu5StringTemplates
    @param templateDataMap - map with data for Uu5String templates
    @param filterFn({uu5Tag, props}) - function to change tag and props used for rendering into components. Function is called for each descendant Uu5StringObject before creation of React component. This function cannot change data of Uu5StringObjects.
    @returns array of React components
   */
  contentToChildren(content, templateDataMap, uu5DataMap, filterFn, buildChildFn, allowedTagsRegExp) {
    if (!content || !content.length) {
      return null;
    }
    let context = Tools.getContentTemplateContext();
    return content.map((item, index) => typeof item === "string" ? Tools.printTemplateToChildren(TextEntityMap.replace(item), templateDataMap, uu5DataMap, buildChildFn, allowedTagsRegExp, context) : item.toChildren({
      templateDataMap,
      uu5DataMap,
      filterFn,
      buildChildFn,
      index
    }));
  },
  /*
    Transform content into string.
     @param content - array of Uu5StringObjects, strings, numbers, booleans and Uu5StringTemplates
    @param templateDataMap - map with data for Uu5String templates
    @param filterFn({uu5Tag, props}) - function to change tag and props used for printing into string. Function is called for each descendant Uu5StringObject before print into string. This function cannot change data of Uu5StringObjects.
    @returns string
  */
  contentToString(content, templateDataMap, filterFn) {
    if (!content || !content.length) {
      return "";
    }
    let context = Tools.getContentTemplateContext();
    if (typeof content === "string") {
      return Tools.printTemplateToString(content, templateDataMap, context);
    }
    let result = "";
    content.forEach(item => result += typeof item === "string" ? Tools.printTemplateToString(item, templateDataMap, context) : item.toString({
      templateDataMap,
      filterFn
    }));
    return result;
  },
  /*
    Transform content into object.
     @param content - array of Uu5StringObjects, strings, numbers, booleans and Uu5StringTemplates
    @param templateDataMap - map with data for Uu5String templates
    @param filterFn({uu5Tag, props}) - function to change tag and props used for printing into string. Function is called for each descendant Uu5StringObject before print into string. This function cannot change data of Uu5StringObjects.
    @returns string
  */
  contentToObject(content, templateDataMap, filterFn) {
    if (!content || !content.length) {
      return [];
    }
    let context = Tools.getContentTemplateContext();
    return content.map(item => typeof item === "string" ? Tools.printTemplateToString(item, templateDataMap, context) : item.toObject({
      templateDataMap,
      filterFn
    }));
  },
  /*
    Transform content into plain text. Returned string will not contain tags, but only text from their props. If parameter templateDataMap is undefined, templateDataMap passed into constructor will be used instead.
     @param templateDataMap - map with data for Uu5String templates
    @param filterFn({uu5Tag, props}) - function to change props used for printing into plain text. Function is called for each descendant Uu5StringObject before print props into plain text.
    @returns string
  */
  contentToPlainText(content, templateDataMap, uu5DataMap, filterFn) {
    if (!content || !content.length) {
      return "";
    }
    let context = Tools.getContentTemplateContext();
    if (typeof content === "string") {
      return Tools.printTemplateToString(content, templateDataMap, context);
    }
    let result = "";
    content.forEach(item => {
      result += (result ? " " : "") + (typeof item === "string" ? Tools.printTemplateToString(item, templateDataMap, context) : item.toPlainText({
        templateDataMap,
        uu5DataMap,
        filterFn
      }));
    });
    return result.replace(/\s+/g, " ").trim();
  },
  printTemplateToString(string, templateDataMap, context) {
    if (!templateDataMap) {
      return string;
    }
    let result = Tools._printTemplate(string, templateDataMap, context);
    return result.length === 1 ? result[0] : result.join("");
  },
  printTemplateToChildren(string, templateDataMap, uu5DataMap, buildChildFn, allowedTagsRegExp, context) {
    if (!templateDataMap) {
      return string;
    }
    let isChildren;
    let canJoin = true;
    let result = Tools._printTemplate(string, templateDataMap, context, matchValue => {
      let result = matchValue;
      let exact = false;
      if (typeof matchValue === "string" && matchValue.match(UU5STRING_REGEXP) && Tools.isValidUu5String(matchValue)) {
        isChildren = true;
        // create component by buildChildFn (e.g. UU5.Common.Tools.findComponent)
        result = Tools.parseUu5String(matchValue, Tools._buildChildItem.bind(Tools, buildChildFn), uu5DataMap, allowedTagsRegExp);
      } else if (typeof matchValue === "string" && matchValue.match(UU5JSON_REGEXP)) {
        try {
          result = Uu5Json.parse(matchValue);
          exact = true;
        } catch (e) {
          // ignore (result will be matchValue)
        }
      } else if (matchValue && typeof matchValue === "object") {
        canJoin = false;
        exact = true;
      }
      return {
        value: result,
        exact
      };
    });

    // result contains parsed Uu5String - return array
    if (isChildren) return result;
    return result.length === 1 ? result[0] : canJoin ? result.join("") : result;
  },
  buildChild(buildChildFn, uu5Tag, props, children, context) {
    let result;
    if (typeof buildChildFn === "function") {
      result = buildChildFn(uu5Tag, props, children, context);
    } else {
      result = {
        uu5Tag,
        tag: uu5Tag,
        props,
        children
      };
    }
    return result;
  },
  _buildChildItem(buildChildFn, uu5Tag, propsString, {
    children,
    uu5DataMap,
    allowedTagsRegExp
  } = {}) {
    if (!uu5Tag) return children;
    let propsArray = propsString ? Tools.parseUu5StringProps(propsString, Tools._buildChildItem.bind(Tools, buildChildFn), uu5DataMap, allowedTagsRegExp) : [];
    let props = {};
    propsArray.forEach(item => props[item.name] = item.value);
    return Tools.buildChild(buildChildFn, uu5Tag, props, children);
  },
  _printTemplate(string, templateDataMap, context, matchHandler) {
    // check if string is single template - in this case return template result ( posible another type then string )
    // let isTemplate = string.match(CHECK_IS_TEMPLATE);
    let useMatchHandler = typeof matchHandler === "function";
    let result = [];
    let templateRegExp = new RegExp(TEMPLATE_REG_EXP); // must be new instance (regexp-s mutate their .lastIndex in successive .exec() calls and we don't want it to be remembered for another uu5string / for matchHandler call)
    let templateMatch = templateRegExp.exec(string);
    let startIndex = 0;
    let endIndex = 0;
    /*
    template[1] - name
    template[2] - default value prefixed by :
    template[3] - default value
    */
    while (templateMatch) {
      let templateName = templateMatch[1];
      let value;
      endIndex = templateRegExp.lastIndex - templateMatch[0].length;
      if (endIndex > startIndex) {
        result.push(string.substring(startIndex, endIndex));
      }
      startIndex = templateRegExp.lastIndex;
      let templateNamePath = templateName.split(".");
      let templateContext = {
        ...context,
        value: string,
        matchValue: templateMatch[0],
        matchStartIndex: endIndex,
        matchEndIndex: startIndex
      };
      if (templateDataMap[templateName]) {
        // check data
        let template = templateDataMap[templateName];
        value = typeof template === "function" ? template(templateMatch[3], [templateName], templateContext) : template;
      } else {
        // check data path
        let template = templateDataMap;
        for (let i = 0; i < templateNamePath.length; i++) {
          template = template[templateNamePath[i]];
          if (typeof template === "function" || template == null) break;
        }
        if (typeof template === "function") {
          value = template(templateMatch[3], templateNamePath, templateContext);
        } else if (template != null) {
          value = template;
        } else if (SYMBOLS[templateName]) {
          // check symbols
          let template = SYMBOLS[templateName];
          value = typeof template === "function" ? template(templateMatch[3]) : template;
        } else {
          // replace template by default value or empty string
          value = templateMatch[3] === undefined ? templateMatch[0] : templateMatch[3];
        }
      }
      if (useMatchHandler) {
        let {
          value: matchResult,
          exact
        } = matchHandler(value);
        if (exact) {
          result.push(matchResult);
        } else if (Array.isArray(matchResult)) {
          matchResult.forEach(item => result.push(item));
        } else {
          result.push(matchResult);
        }
      } else {
        result.push(value);
      }
      templateMatch = templateRegExp.exec(string);
    }

    // add string after end of last match
    if (startIndex < string.length) {
      result.push(string.substring(startIndex));
    }
    return result;
  },
  isValidUu5String(uu5string) {
    if (typeof uu5string !== "string") return false;
    try {
      Tools.parseUu5String(uu5string);
      return true;
    } catch (e) {
      return false;
    }
  },
  parseUu5String(uu5string, buildItemFn, uu5DataMap, allowedTagsRegExp) {
    if (!uu5string || typeof uu5string !== "string" || uu5string.length === 0) {
      return [];
    }
    uu5string = uu5string.trim().replace(/\r\n/g, "\n");
    let childStack = [{
      uu5Tag: "_root",
      children: [],
      index: 0
    }];
    let pointer = childStack[0];
    let cIndex = -1;
    let pIndex = 0;
    let pre = false;
    let preTag = "";
    let matchS;
    let matchUu5String = uu5string.match(UU5STRING_REGEXP);
    if (matchUu5String) {
      // !!!!! Never put uu5stringRe to constants, otherwise it gets stuck - because of exec method on regexp
      // groups: comp name, comp name suffix, attrs, -, -, -, self-closing, closing tag comp name, content upto next tag
      let tagRe = new RegExp(TAG_WITH_MAYBE_BROKEN_ATTR_WITH_QUOTE, "g");
      pIndex = tagRe.lastIndex = matchUu5String[0].length;
      matchS = tagRe.exec(uu5string);
      while (matchS) {
        cIndex = matchS.index;
        if (cIndex > pIndex) {
          let head = uu5string.substring(pIndex, cIndex);
          let text = head;
          // let text = pre ? TextEntityMap.replaceHtmlEntity(head) : TextEntityMap.replace(head);
          pointer.children.push(typeof buildItemFn === "function" ? buildItemFn(null, null, {
            children: text,
            uu5DataMap,
            allowedTagsRegExp
          }) : text);
          Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1]);
        }
        let isTagWithBrokenAttrs = !uu5string.slice(cIndex, cIndex + matchS[0].length).match(TAG);
        let childTag = matchS[2] || matchS[14];
        let childTagNoVersion = childTag.slice(0, childTag.length - ((childTag === matchS[2] ? matchS[3] : matchS[15]) || "").length);
        let attrs = matchS[4];
        let isClosing = !!matchS[14];
        let isSelfClosing = !!matchS[13];
        let openingTagLengthIfBroken = isTagWithBrokenAttrs ? matchS[1].length : 0;
        let tagObj;
        if (pre && !(childTag === preTag && isClosing) || !isTagWithBrokenAttrs && (childTagNoVersion.match(FORBIDDEN_TAGS_REGEXP) || childTagNoVersion.match(FORBIDDEN_TAGS_REGEXP2))) {
          let text = matchS[0];
          // let text = TextEntityMap.replaceHtmlEntity(matchS[0]);
          pointer.children.push(typeof buildItemFn === "function" ? buildItemFn(null, null, {
            children: text,
            uu5DataMap,
            allowedTagsRegExp
          }) : text);
          Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1]);
        } else if (isTagWithBrokenAttrs) {
          let attrRegExp = new RegExp(`${BROKEN_ATTR_WITH_QUOTE}|${ATTR}`, "g");
          let brokenQuoteIndex;
          attrs.replace(attrRegExp, function (m, groupBeforeQuotedValue, groupBeforeOffendingDoubleQuote, groupBeforeOffendingSingleQuote) {
            let attrMatch = m.match(new RegExp(ATTR));
            if (attrMatch && attrMatch[0].length === m.length) return;
            if (brokenQuoteIndex === undefined) {
              let skippedAttributesLength = arguments[9];
              brokenQuoteIndex = matchS.index + openingTagLengthIfBroken +
              // opening tag name - `<Component`
              skippedAttributesLength +
              // skipped (valid) attributes - ` foo="bar"`
              groupBeforeQuotedValue.length +
              // attribute name & equals sign - ` invalid="`
              (groupBeforeOffendingDoubleQuote || groupBeforeOffendingSingleQuote).length; // attribute content up to bad quote - `quote in attr: `
            }
          });

          let err = new Error(`Invalid uu5string: Detected unescaped quote(s) in an attribute value.`);
          err.code = "uu5StringInvalid";
          err.context = {
            uu5string,
            uu5Tag: childTag,
            tag: childTag,
            index: brokenQuoteIndex
          };
          throw err;
        } else {
          if (isClosing) {
            //closing tag

            tagObj = childStack.pop();
            if (tagObj.uu5Tag !== childTag) {
              const err = new Error(`Invalid uu5string: Tag ${tagObj.uu5Tag} at position ${tagObj.index} is not closed.`);
              err.code = "uu5StringInvalid";
              err.context = {
                uu5string,
                uu5Tag: tagObj.uu5Tag,
                tag: tagObj.uu5Tag,
                index: tagObj.index
              };
              throw err;
            }
            pointer = childStack[childStack.length - 1];
            if (pre) {
              pre = false;
              let text = tagObj.children.join("");
              // let text = TextEntityMap.replaceHtmlEntity(tagObj.children.join(''));
              pointer.children[pointer.children.length - 1] = typeof buildItemFn === "function" ? buildItemFn(tagObj.uu5Tag, tagObj.attrs, {
                children: text,
                uu5DataMap,
                allowedTagsRegExp
              }) : text;
              Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1], tagObj.uu5Tag);
            } else {
              if (tagObj.forbidden) {
                tagObj.children = `Error: Tag <${tagObj.uu5Tag} /> is not allowed.`;
                tagObj.attrs = ` uu5Tag="${tagObj.uu5Tag}" tag="${tagObj.uu5Tag}"`;
                tagObj.uu5Tag = tagObj.tag = "invalidTag";
              }
              pointer.children[pointer.children.length - 1] = typeof buildItemFn === "function" ? buildItemFn(tagObj.uu5Tag, tagObj.attrs, {
                children: tagObj.children,
                isPairedTag: true,
                uu5DataMap,
                allowedTagsRegExp
              }) : tagObj;
              Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1], tagObj.uu5Tag);
            }
          } else {
            // prevent parsing json inside uu5json
            pre = childTag === "uu5string.pre" || childTag === "uu5json";
            preTag = childTag;
            tagObj = {
              uu5Tag: childTag,
              children: [],
              index: matchS.index
            };
            if (allowedTagsRegExp && !allowedTagsRegExp.test(childTagNoVersion)) {
              tagObj.forbidden = true;
            } else if (attrs) {
              tagObj.attrs = attrs;
            }
            if (isSelfClosing) {
              //self-closing tag
              pre = false;
              if (childTag.indexOf("uu5string.") === 0) {
                //meta-tag uu5string.*
                let s = Tools.execMetaTag(childTag, tagObj.attrs);
                if (s) {
                  s.forEach(item => {
                    pointer.children.push(typeof buildItemFn === "function" ? buildItemFn(null, null, {
                      children: item,
                      uu5DataMap,
                      allowedTagsRegExp
                    }) : item);
                    Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1]);
                  });
                }
              } else {
                if (tagObj.forbidden) {
                  tagObj.children = `Error: Tag <${tagObj.uu5Tag} /> is not allowed.`;
                  tagObj.attrs = ` uu5Tag="${tagObj.uu5Tag}" tag="${tagObj.uu5Tag}"`;
                  tagObj.uu5Tag = tagObj.tag = "invalidTag";
                }
                pointer.children.push(typeof buildItemFn === "function" ? buildItemFn(tagObj.uu5Tag, tagObj.attrs, {
                  children: tagObj.children,
                  isPairedTag: false,
                  uu5DataMap,
                  allowedTagsRegExp
                }) : tagObj);
                Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1], tagObj.uu5Tag);
              }
            } else {
              //common tag
              pointer.children.push(tagObj);
              childStack.push(tagObj);
              pointer = tagObj;
            }
          }
        }
        pIndex = cIndex + matchS[0].length;
        matchS = tagRe.exec(uu5string);
      }
      // handle ending text
      if (pIndex < uu5string.length) {
        let text = uu5string.substr(pIndex);
        // text = pre ? TextEntityMap.replaceHtmlEntity(text) : TextEntityMap.replace(text);
        pointer.children.push(typeof buildItemFn === "function" ? buildItemFn(null, null, {
          children: text,
          uu5DataMap,
          allowedTagsRegExp
        }) : text);
        Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1]);
      }
      if (childStack.length > 1) {
        let tagObj = childStack.pop();
        const err = new Error(`Invalid uu5string: Tag ${tagObj.uu5Tag} at position ${tagObj.index} is not closed.`);
        err.code = "uu5StringInvalid";
        err.context = {
          uu5string,
          uu5Tag: tagObj.uu5Tag,
          tag: tagObj.uu5Tag,
          index: tagObj.index
        };
        throw err;
      }
    } else {
      pointer.children.push(typeof buildItemFn === "function" ? buildItemFn(null, null, {
        children: uu5string,
        uu5DataMap,
        allowedTagsRegExp
      }) : uu5string);
      Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1]);
    }
    return pointer.children;
  },
  parseUu5StringProps(attrsString, buildItemFn, uu5DataMap, allowedTagsRegExp) {
    let attrs = [];

    // group1 = separator
    // group2 = attribute name
    // group3 = name and value separator
    // group4 = attribute value
    // group5 = indication that attribute value is not wrapped into quotes / single quotes
    let attrsReg = new RegExp(ATTR_REGEXP.source, "g");
    let matchAttrs = attrsReg.exec(attrsString);
    while (matchAttrs) {
      let separator = matchAttrs[1];
      let name = matchAttrs[2];
      let valueDelimiter = matchAttrs[3];
      let valueBoundaries = "";
      let value = true;
      let uu5DataKey = undefined;
      let valueType = null; // hold info if data is parsed from uu5string, uu5data or uu5json
      let matchValue = matchAttrs[4];
      let isUnquoted = !!matchAttrs[5];
      if (!name.match(FORBIDDEN_ATTRS_REGEXP)) {
        if (isUnquoted) {
          if (matchValue === "true") {
            //true
            value = true;
          } else if (matchValue === "false") {
            //false
            value = false;
          } else if (isFinite(matchValue)) {
            //number
            value = +matchValue;
          } else {
            //any other -> null | undefined
            value = matchValue === "undefined" ? undefined : null;
          }
        } else if (matchValue != null) {
          // unescape quoted value
          if (matchValue[0] === "'") {
            valueBoundaries = "'";
            matchValue = matchValue.substr(1, matchValue.length - 2).replace(/\\([\\'])/g, "$1");
          } else if (matchValue[0] === '"') {
            valueBoundaries = '"';
            matchValue = matchValue.substr(1, matchValue.length - 2).replace(/\\([\\"])/g, "$1");
          }
          let matchValueType = matchValue.match(ATTR_VALUE_TYPE_REGEXP);
          if (matchValueType[1]) {
            //uu5JSON
            valueType = "uu5json";
            try {
              value = Uu5Json.parse(matchValue);
            } catch (e) {
              e.context.prop = name;
              throw e;
            }
          } else if (matchValueType[2]) {
            //uu5String
            valueType = "uu5string";
            value = Tools.parseUu5String(matchValue, buildItemFn, uu5DataMap, allowedTagsRegExp);
          } else if (matchValueType[3]) {
            //uu5Data
            valueType = "uu5data";
            uu5DataKey = matchValue.replace(UU5DATA_REGEXP, "");
            value = Uu5Data.parse(matchValue, uu5DataMap);
          } else {
            //as-is
            if (name === "href") {
              matchValue = matchValue.replace(JSCODE_REGEXP, "");
            }
            value = matchValue;
          }
        }
        attrs.push({
          name,
          value,
          valueDelimiter,
          separator,
          valueBoundaries,
          valueType,
          uu5DataKey
        });
      }
      matchAttrs = attrsReg.exec(attrsString);
    }
    return attrs;
  },
  parseUu5StringPropsObject(attrsObject, buildItem, uu5DataMap, allowedTagsRegExp) {
    const attrs = [];
    for (const attr in attrsObject) {
      let separator = DEFAULT_SEPARATOR;
      let name = attr;
      let attrValue = attrsObject[attr];
      let valueDelimiter = DEFAULT_VALUE_DELIMITER;
      let valueBoundaries = DEFAULT_BOUNDARIES;
      let value = null;
      let uu5DataKey = undefined;
      let valueType = null; // hold info if data is parsed from uu5string, uu5data or uu5json

      if (name && !name.match(FORBIDDEN_ATTRS_REGEXP)) {
        if (typeof attrValue === "string") {
          let matchValueType = attrValue.match(ATTR_VALUE_TYPE_REGEXP);
          if (matchValueType[1]) {
            //uu5JSON
            valueType = "uu5json";
            try {
              value = Uu5Json.parse(attrValue);
            } catch (e) {
              e.context.prop = name;
              throw e;
            }
          } else if (matchValueType[2]) {
            //uu5String
            valueType = "uu5string";
            value = Tools.parseUu5String(attrValue, buildItem, uu5DataMap, allowedTagsRegExp);
          } else if (matchValueType[3]) {
            //uu5Data
            valueType = "uu5data";
            uu5DataKey = attrValue.replace(UU5DATA_REGEXP, "");
            value = Uu5Data.parse(attrValue, uu5DataMap);
          } else {
            //as-is
            if (name === "href") {
              value = attrValue.replace(JSCODE_REGEXP, "");
            } else {
              value = attrValue;
            }
          }
        } else if (attrValue && typeof attrValue === "object" && (attrValue.uu5Tag || attrValue.tag)) {
          value = [this.parseTagPropsObject(attrValue, buildItem, uu5DataMap, allowedTagsRegExp)];
        } else if (Array.isArray(attrValue)) {
          value = this.parseTagPropsArray(attrValue, buildItem, uu5DataMap, allowedTagsRegExp);
        } else {
          value = attrValue;
        }
        attrs.push({
          name,
          value,
          valueDelimiter,
          separator,
          valueBoundaries,
          valueType,
          uu5DataKey
        });
      }
    }
    return attrs;
  },
  parseTagPropsArray(tagPropsArray, buildItem, uu5DataMap, allowedTagsRegExp) {
    if (!tagPropsArray || !Array.isArray(tagPropsArray) || !tagPropsArray.length) {
      return [];
    }
    return tagPropsArray.map(item => this.parseTagPropsObject(item, buildItem, uu5DataMap, allowedTagsRegExp));
  },
  parseTagPropsObject(tagPropsObject, buildItem, uu5DataMap, allowedTagsRegExp) {
    if (!tagPropsObject) return null;
    if (!tagPropsObject || !tagPropsObject.uu5Tag && !tagPropsObject.tag) return tagPropsObject;
    let uu5Tag = tagPropsObject.uu5Tag || tagPropsObject.tag;
    if (uu5Tag && (uu5Tag.match(FORBIDDEN_TAGS_REGEXP) || uu5Tag.match(FORBIDDEN_TAGS_REGEXP2))) {
      let result = buildItem(null, null, {
        children: `<${uu5Tag} />`,
        uu5DataMap,
        allowedTagsRegExp
      });
      return result;
    }
    if (allowedTagsRegExp && !allowedTagsRegExp.test(uu5Tag)) {
      let result = buildItem("invalidTag", ` uu5Tag="${uu5Tag}" tag="${uu5Tag}"`, {
        children: `Error: Tag <${uu5Tag} /> is not allowed.`,
        uu5DataMap,
        isPairedTag: false,
        allowedTagsRegExp
      });
      Tools.syncUu5TagAfterApiCall(result, "invalidTag");
      return result;
    }
    const children = this.parseTagPropsArray(tagPropsObject.children, buildItem, uu5DataMap, allowedTagsRegExp);
    return buildItem(uu5Tag, tagPropsObject.props, {
      children,
      uu5DataMap,
      allowedTagsRegExp,
      isPairedTag: !!(children && children.length)
    });
  },
  execMetaTag(tag, args) {
    //TODO implement each metaTag as separate function, call functions dynamically (witch safety keyword guard)
    let metaTag = tag.slice(10);
    let r = [];
    switch (metaTag) {
      case "now":
        r.push(SYMBOLS.now());
        break;
      case "codeHex32":
        r.push(SYMBOLS.idHex32());
        break;
      case "codeHex64":
        r.push(SYMBOLS.idHex64());
        break;
      default:
        r.push(null);
    }
    return r;
  },
  syncUu5TagAfterApiCall(tagObj, origUu5Tag) {
    // for backward compatibility - "older" API methods (filterFn, buildItemFn, ...) could change
    // "tag" instead of "uu5Tag" field => use the changed "tag" in such case, otherwise prefer "uu5Tag"
    if (!tagObj || typeof tagObj !== "object") return;
    if (!tagObj.uu5Tag || tagObj.uu5Tag !== tagObj.tag && tagObj.uu5Tag === origUu5Tag && tagObj.tag) {
      tagObj.uu5Tag = tagObj.tag;
    } else {
      tagObj.tag = tagObj.uu5Tag;
    }
  },
  isAllowedTagAndAttrCombination(tag, attrName, attrValue) {
    let tagNoVersion = typeof tag === "string" ? tag.replace(/_.*/, "") : tag;
    if (tagNoVersion === "UU5.Bricks.Iframe") {
      if (attrName === "srcDoc") return false;
      // NOTE Even "src" gets sometimes internally used as "srcDoc" => forbid if it contains "<".
      if (attrName === "src" && attrValue && (typeof attrValue !== "string" || !attrValue.match(/^https?:\/\/[^<]*$/))) {
        return false;
      }
    } else if (tagNoVersion === "Plus4U5.Bricks.Iframe") {
      if (attrName === "src" && attrValue) {
        if (typeof attrValue !== "string" || attrValue.match(/</)) return false;
        if (typeof document !== "undefined" && typeof window !== "undefined") {
          let a = document.createElement("a");
          a.href = attrValue; // browser normalizes
          let normalizedUrl = a.href;
          let legacyEnv = (window.UU5 || {}).Environment || {};
          let trustedDomainRegExpStr = (window.uu5Environment || {}).uu5g05_trustedUriRegExp || legacyEnv.trustedDomainRegexp || "^";
          let trustedDomainRegExp = new RegExp(trustedDomainRegExpStr, "i");
          let curBase = window.location.protocol + "//" + window.location.host + "/";
          if (!normalizedUrl.match(trustedDomainRegExp) && !normalizedUrl.startsWith(curBase)) return false;
        }
      }
    }
    return true;
  },
  escapeEntities(text) {
    if (typeof text !== "string") return text;
    // TODO Maybe unescape emojis too.
    // NOTE TextEntityMap doesn't have unescaping mechanism and it contains
    // multiple mappings to the same character, e.g. &lt; and &#060; are both mapped to ">".
    return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  },
  getPropTemplateContext(prop) {
    return {
      location: "prop",
      propName: prop.name
    };
  },
  getContentTemplateContext() {
    return {
      location: "content"
    };
  }
};
module.exports = Tools;

/***/ }),

/***/ "./internal/uu5-common-tools.js":
/***/ ((module) => {

const REGEXP_XY = /[xy]/g;
const Tools = {};
Tools.REGEXP = {
  uu5string: /^\s*<uu5string\s*\/>/,
  uu5stringTemplate: /\$\{([0-9a-zA-Z.\-_]+)\s*(:\s*([0-9a-zA-Z.\-_ ()\[\]<>\\\/]+))?\}/,
  uu5json: /^\s*<uu5json\s*\/>/,
  uu5data: /^\s*<uu5data\s*\/>/,
  jsCode: /^(javascript:\s*)*/i
};
Tools.generateId = length => {
  length = Math.max(length, 8);
  let uuidCore = "x4xxxyxx";
  const additionalCharLength = length - uuidCore.length;
  for (let i = 0; i < additionalCharLength; ++i) {
    if (i % 2 === 0) uuidCore = uuidCore + "x";else uuidCore = "x" + uuidCore;
  }
  return uuidCore.replace(REGEXP_XY, char => {
    let r = Math.random() * 16 % 16 | 0;
    return (char === "x" ? r : r & 0x3 | 0x8).toString(16);
  });
};
module.exports = Tools;

/***/ }),

/***/ "./uu5-data.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright (C) 2019 Unicorn a.s.
 *
 * This program is free software; you can use it under the terms of the UAF Open License v01 or
 * any later version. The text of the license is available in the file LICENSE or at www.unicorn.com.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See LICENSE for more details.
 *
 * You may contact Unicorn a.s. at address: V Kapslovne 2767/2, Praha 3, Czech Republic or
 * at the email: info@unicorn.com.
 */

const {
  UU5DATA_REGEXP
} = __webpack_require__("./internal/constants.js");
class Uu5Data {
  static parse(uu5Data, uu5DataMap) {
    uu5Data = uu5Data.replace(UU5DATA_REGEXP, "");
    let parts = uu5Data.split(".");
    let data = uu5DataMap;
    while (data != null && parts.length > 0) data = data[parts.shift()];
    if (typeof data === undefined && typeof self === "undefined") {
      console.warn(`There is no component data in uu5DataMap for uu5Data: ${uu5Data} !`, {
        uu5Data: uu5Data
      });
    }
    return data;
  }
}
module.exports = Uu5Data;

/***/ }),

/***/ "./uu5-json.js":
/***/ ((module) => {

/**
 * Copyright (C) 2019 Unicorn a.s.
 *
 * This program is free software; you can use it under the terms of the UAF Open License v01 or
 * any later version. The text of the license is available in the file LICENSE or at www.unicorn.com.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See LICENSE for more details.
 *
 * You may contact Unicorn a.s. at address: V Kapslovne 2767/2, Praha 3, Czech Republic or
 * at the email: info@unicorn.com.
 */

const UU5_JSON_REGEXP = /^\s*<uu5json\s*\/>/;
class Uu5Json {
  static parse(uu5Json) {
    uu5Json = Uu5Json.toJson(uu5Json);
    let value = null;
    try {
      value = JSON.parse(uu5Json);
    } catch (err) {
      err.code = "uu5JsonInvalid";
      err.context = {
        json: uu5Json
      };
      throw err;
    }
    return value;
  }
  static toJson(uu5Json) {
    return uu5Json.replace(UU5_JSON_REGEXP, "");
  }
  constructor(json) {
    this._uu5json = json;
    this._object = Uu5Json.parse(json);
  }
  toUu5Json() {
    return this._uu5json;
  }
  toJson() {
    return this._uu5json;
  }
  toObject() {
    return this._object;
  }
  clone() {
    return new Uu5Json(this._uu5json);
  }
}
module.exports = Uu5Json;

/***/ }),

/***/ "./uu5-string-object.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright (C) 2019 Unicorn a.s.
 *
 * This program is free software; you can use it under the terms of the UAF Open License v01 or
 * any later version. The text of the license is available in the file LICENSE or at www.unicorn.com.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See LICENSE for more details.
 *
 * You may contact Unicorn a.s. at address: V Kapslovne 2767/2, Praha 3, Czech Republic or
 * at the email: info@unicorn.com.
 */

const TextEntityMap = __webpack_require__("./internal/text-entity-map.js");
const Uu5StringTools = __webpack_require__("./internal/tools.js");
const defaultFactory = __webpack_require__("./internal/factory.js");
const {
  FORBIDDEN_ATTRS_REGEXP
} = __webpack_require__("./internal/constants.js");
const defaultPlainTextFilterFn = ({
  uu5Tag,
  tag,
  props
}) => {
  tag = uu5Tag = uu5Tag || tag;
  if (props) {
    let result = {
      tag,
      uu5Tag,
      props: {}
    };
    if (props.header) {
      result.props.header = props.header;
    }
    if (props.uu5string) {
      result.props.uu5string = props.uu5string;
    }
    if (props.content || props.children) {
      result.props.children = props.content || props.children;
    }
    if (props.footer) {
      result.props.footer = props.footer;
    }
    return result;
  }
};
class Uu5StringObject {
  /* constructor */
  constructor(uu5Tag, props, {
    children = [],
    isPairedTag = true,
    initFn = null,
    parent = null,
    uu5DataMap: initialUu5DataMap,
    allowedTagsRegExp
  } = {}) {
    this._factory = arguments[2] && arguments[2]._factory || defaultFactory;
    /* public methods */

    /*
    Returns Uu5StringObject as a string
     @param opts.templateDataMap - object with data for templates
    @param filterFn({uu5Tag, props}) - returns changed tag and props, if it returns false skip print of this component and its children - this method cannot change data of this component only change them for print
    @returns Uu5StringObject as a string
    */
    this.toString = ({
      templateDataMap,
      filterFn
    } = {}) => {
      if (this.uu5Tag === "uu5string.pre") {
        return `<uu5string.pre>${this.children.join("")}</uu5string.pre>`;
      }
      return this._withPropsAfterFilterFn({
        templateDataMap,
        filterFn
      }, "", (uu5Tag, uu5StringProps, children) => {
        let {
          propsString,
          tooLongPropItemMap
        } = uu5StringProps.toString({
          templateDataMap,
          filterFn,
          _extendedResult: true
        });
        let resultParts = [`<${uu5Tag}${propsString}`];

        // render children - children from props content was rendered with props
        if (this._isPairTag(children) || tooLongPropItemMap) {
          resultParts.push(">");
          if (tooLongPropItemMap) {
            for (let propItem of Object.values(tooLongPropItemMap)) {
              let uu5stringObject = this._createPropChild(propItem, templateDataMap);
              resultParts.push(Uu5StringTools.contentToString([uu5stringObject], templateDataMap, filterFn));
            }
          }
          resultParts.push(`${Uu5StringTools.contentToString(children, templateDataMap, filterFn)}</${uu5Tag}>`);
        } else {
          resultParts.push("/>");
        }
        return resultParts.join("");
      });
    };

    /**
     * @return Object-representation of the uu5string. Passing .toString() and .toObject() values back into Uu5String
     *         constructor must result in the exact same structure.
     */
    this.toObject = ({
      templateDataMap,
      filterFn
    } = {}) => {
      if (this.uu5Tag === "uu5string.pre") {
        return this.children.join("");
      }
      return this._withPropsAfterFilterFn({
        templateDataMap,
        filterFn
      }, undefined, (uu5Tag, uu5StringProps, children) => {
        let {
          props: transformedProps,
          tooLongPropItemMap
        } = uu5StringProps.toObject({
          templateDataMap,
          filterFn,
          preserveValueTypes: true,
          _extendedResult: true
        });
        let childrenToTransform = children;
        // move props containing uu5string to children if they're too long
        if (tooLongPropItemMap) {
          childrenToTransform = Array.isArray(childrenToTransform) ? [...childrenToTransform] : childrenToTransform != null ? [childrenToTransform] : [];
          for (let propItem of Object.values(tooLongPropItemMap)) {
            // NOTE The result must contain <uu5string propName="">...</> as a child with the value in pre-parsed form
            // (if it was simple string, we would have exactly the same problem as if it was in a prop - see UU5STRING_LENGTH_LIMIT).
            let uu5stringObject = this._createPropChild(propItem, templateDataMap);
            delete transformedProps[propItem.name];
            childrenToTransform.unshift(uu5stringObject);
          }
        }
        let transformedChildren = Uu5StringTools.contentToObject(childrenToTransform, templateDataMap, filterFn);
        let result = {
          uu5Tag,
          props: transformedProps
        };
        if (transformedChildren !== undefined && (!Array.isArray(transformedChildren) || transformedChildren.length > 0)) {
          result.children = transformedChildren;
        }
        return result;
      });
    };

    /*
    Returns Uu5StringObject as a plain text
     @param opts.templateDataMap - object with data for templates
    @param filterFn({uu5Tag, props}) - returns changed tag and props, if it returns false skip print of this component and its children - this method cannot change data of this component only change them for print
    @returns Uu5StringObject as a string
    */
    this.toPlainText = ({
      templateDataMap,
      uu5DataMap,
      filterFn
    } = {}) => {
      if (this.uu5Tag === "uu5string.pre") {
        return `${this.children.join("")}`;
      }
      let children = this.children;

      // there is no need to special handling of props parsed from children

      let propsArray = [...this.props.props];
      let originalProps = this.props.props;

      // add children into props
      if (children) {
        propsArray.push({
          name: "children",
          value: children.slice(),
          valueType: "uu5string"
        });
      }
      let result;

      // update filter function - use default if is not set other wise add default filter function as an another parameter into filterFn
      let modifiedFilterFn = defaultPlainTextFilterFn;
      if (filterFn) {
        modifiedFilterFn = (...params) => filterFn(...params, defaultPlainTextFilterFn);
      }

      // handle props with children
      this.props.props = propsArray;
      let uu5Tag = this.uu5Tag;
      let obj = {
        uu5Tag,
        tag: uu5Tag,
        props: this.props.toObject({
          uu5DataMap
        })
      };
      // filter result by obj
      let _result = this._filterProps(obj, modifiedFilterFn, true);
      // check if filter returns false => do not render component
      if (_result === false) {
        return "";
      }
      this.props.props = _result.resultProps;
      // print filtered props
      result = `${this.props.toPlainText({
        templateDataMap,
        uu5DataMap,
        filterFn
      })}`;
      // return original props
      this.props.props = originalProps;
      return result;
    };

    /*
    Returns Uu5StringObject as a hierarchy of react component
     @param opts.templateDataMap - object with data for templates
    @param filterFn({uu5Tag, props}) - returns changed tag and props, if it returns false skip print of this component and its children - this method cannot change data of this component only change them for print
    @returns Uu5StringObject as a React component
    */
    this.toChildren = ({
      templateDataMap,
      uu5DataMap = initialUu5DataMap,
      filterFn,
      buildChildFn,
      index
    } = {}) => {
      if (this.uu5Tag === "uu5string.pre") {
        return this.children.map(it => {
          if (typeof it === "string") return TextEntityMap.replaceHtmlEntity(it);
          return it;
        });
      }
      let result;
      let children = this.children;
      let uu5Tag = this.uu5Tag;
      if (filterFn) {
        // create shallow copy of component
        let obj = {
          uu5Tag,
          tag: uu5Tag,
          props: this.props.toObject({
            uu5DataMap
          })
        };
        obj.props.children = this.children.slice();
        // filter result by obj
        let _result = this._filterProps(obj, filterFn);
        // check if filter returns false => do not render component
        if (_result === false) {
          return null;
        }
        let {
          resultTag,
          resultProps
        } = _result;
        // remove children from props
        resultProps = resultProps.filter(item => {
          if (item.name === "children") {
            children = item.value;
            return false;
          }
          return true;
        });
        let propsArray = this.props.props;
        this.props.props = resultProps;
        // process filtered props
        result = {
          uu5Tag: resultTag,
          tag: resultTag,
          props: this.props.toChildren({
            templateDataMap,
            uu5DataMap,
            filterFn,
            buildChildFn
          })
        };
        // return original props
        this.props.props = propsArray;
      } else {
        result = {
          uu5Tag,
          tag: uu5Tag,
          props: this.props.toChildren({
            templateDataMap,
            uu5DataMap,
            undefined,
            buildChildFn
          })
        };
      }
      let usedChildren = Uu5StringTools.contentToChildren(children, templateDataMap, uu5DataMap, filterFn, buildChildFn, allowedTagsRegExp);
      let context = {
        index
      };
      let returnValue = Uu5StringTools.buildChild(buildChildFn, result.uu5Tag, result.props, usedChildren, context);
      return returnValue;
    };

    /*
    Deep clone of this component.
     @returns new instance of Uu5StringObject
    */
    this.clone = ({
      initFn = this.initFn
    } = {}) => {
      // filter props by filter function
      let uu5Tag = this.uu5Tag;
      let result = {
        uu5Tag,
        tag: uu5Tag,
        props: this.props.clone({
          initFn
        })
      };
      // clone children at first
      result.children = this.children.map(item => typeof item === "string" ? item : item.clone({
        initFn
      }));
      // create new object - props are already cloned so do not send them into constructor
      let newUu5StringObject = this._factory.createObject(result.uu5Tag, null, {
        children: result.children,
        isPairedTag: this._isPairTag(),
        initFn,
        allowedTagsRegExp
      });
      newUu5StringObject.props = result.props;
      return newUu5StringObject;
    };

    /*
    Returns index of this component in the parent. If component does not have parent returns -1.
     @returns number
    */
    this.getIndex = () => {
      return this.parent ? this.parent.children.indexOf(this) : -1;
    };

    /* private methods */
    this._initContent = () => {
      // set parent to children
      if (this.children && Array.isArray(this.children)) {
        this.children.forEach(item => {
          if (item && typeof item === "object") item.parent = this;
        });
      }
      if (this.props && this.props.props) {
        let content = this.props.props.find(item => item.name === "content");
        if (content && Array.isArray(content.value)) {
          content.value.forEach(item => {
            if (item && typeof item === "object") item.parent = this;
          });
        }
      }
    };
    this._filterProps = (propsObj, filterFn, preserveObjectOrder) => {
      let uu5TagOrig = propsObj ? propsObj.uu5Tag : undefined;
      let tagOrig = propsObj ? propsObj.tag : undefined;
      let filterObj = filterFn(propsObj);
      if (filterObj === false) return false;
      let uu5Tag = uu5TagOrig || tagOrig;
      if (filterObj) {
        propsObj = filterObj;
        Uu5StringTools.syncUu5TagAfterApiCall(propsObj, uu5TagOrig);
        uu5Tag = propsObj.uu5Tag;
      }
      // some props values may be false or undefined - for filtering we need to have some value evaluated as a true
      let filteredProps = {};
      let counter = 1;
      for (let propName in propsObj.props) {
        filteredProps[propName] = counter++;
      }
      // filter result by obj
      let propsArray = this.props.props.filter(prop => filteredProps[prop.name]);
      if (preserveObjectOrder) {
        propsArray.sort((prop1, prop2) => filteredProps[prop1.name] - filteredProps[prop2.name]);
      }
      // update values
      for (let propName in propsObj.props) {
        let prop = propsArray.find(item => item.name === propName);
        if (prop) {
          // update value
          prop.value = propsObj.props[propName];
        } else {
          // add new props
          propsArray.push({
            name: propName,
            value: propsObj.props[propName]
          });
        }
      }
      return {
        resultTag: uu5Tag,
        resultProps: propsArray
      };
    };
    this._withPropsAfterFilterFn = ({
      templateDataMap,
      filterFn
    }, fallbackValue, callbackFn) => {
      let children = [...this.children];
      let propsChildren = [];
      let filteredProps = [];
      for (let pi = 0; pi < this.props.props.length; pi++) {
        let prop = this.props.props[pi];
        if (prop.childrenProperty) {
          propsChildren.push(prop);
        } else {
          filteredProps.push(prop);
        }
      }

      // sort props children by index from lowest
      propsChildren.sort((child1, child2) => child2.index - child1.index);

      // re-create children in the form of <uu5json propName="foo">...</uu5json>, ...
      for (let pi = 0; pi < propsChildren.length; pi++) {
        let prop = propsChildren[pi];
        let uu5stringObject = this._factory.createObject(undefined, undefined, {
          allowedTagsRegExp
        });
        uu5stringObject.uu5Tag = prop.valueType === "string" ? "uu5string" : prop.valueType;
        let context = Uu5StringTools.getPropTemplateContext(prop);
        uu5stringObject.children = prop.valueType === "uu5json" ? [Uu5StringTools.printTemplateToString(JSON.stringify(prop.value, undefined, 2), templateDataMap, context).replace(/<\/uu5json>/g, "\\u003c/uu5json>") // json containing "</uu5json>" should not break later parsing
        ] : Uu5StringTools.contentToString(prop.value, templateDataMap, filterFn);
        uu5stringObject.props.props.push({
          name: "propName",
          value: prop.name,
          type: "string"
        });

        // add item back into its original place - if index is larger then count of children, then we push it at the end of array
        if (prop.index < children.length) {
          //insert back formating spaces
          if (prop.spacesBefore) {
            children.splice(prop.index, 0, prop.spacesBefore, uu5stringObject);
          } else {
            children.splice(prop.index, 0, uu5stringObject);
          }
        } else {
          //insert back formating spaces
          if (prop.spacesBefore) {
            children.push(prop.spacesBefore);
          }
          children.push(uu5stringObject);
        }
      }

      // use filteredProps for rest of the algorithm and then return back original props
      let originalProps = this.props.props;
      this.props.props = filteredProps;
      let uu5Tag = this.uu5Tag;
      let result;
      if (filterFn) {
        let obj = {
          uu5Tag,
          tag: uu5Tag,
          props: this.props.toObject()
        };
        obj.props.children = children.slice();
        // filter result by obj
        // NOTE Props realized as <uu5json propName="...">...</uu5json> are present in "children" when using filterFn,
        // i.e. they're not in "props" directly ({ uu5Tag, props, children }).
        let _result = this._filterProps(obj, filterFn);
        // check if filter returns false => do not render component
        if (_result === false) {
          result = fallbackValue;
        } else {
          let {
            resultTag,
            resultProps
          } = _result;
          uu5Tag = resultTag;
          // remove children from props
          resultProps = resultProps.filter(item => {
            if (item.name === "children") {
              children = item.value;
              return false;
            }
            return true;
          });
          this.props.props = resultProps;
          // print filtered props
          result = callbackFn(uu5Tag, this.props, children);
        }
      } else {
        result = callbackFn(uu5Tag, this.props, children);
      }

      // return original props
      this.props.props = originalProps;
      return result;
    };
    this._createPropChild = (propItem, templateDataMap) => {
      let context = Uu5StringTools.getPropTemplateContext(propItem);
      let uu5stringObject = this._factory.createObject();
      uu5stringObject.uu5Tag = propItem.valueType;
      uu5stringObject.children = propItem.valueType === "uu5string" ? propItem.value : [Uu5StringTools.printTemplateToString(JSON.stringify(propItem.value, undefined, 2), templateDataMap, context).replace(/<\/uu5json>/g, "\\u003c/uu5json>") // json containing "</uu5json>" should not break later parsing
      ];

      uu5stringObject.props.props.push({
        name: "propName",
        value: propItem.name,
        type: "string"
      });
      return uu5stringObject;
    };
    this._isPairTag = (children = this.children) => {
      let isPairTag = children.length > 0 || this._pairTag;
      this._pairTag = isPairTag;
      return this._pairTag;
    };

    // constructor logic
    this.uu5Tag = uu5Tag;
    Object.defineProperty(this, "tag", {
      get: () => this.uu5Tag,
      set: v => {
        this.uu5Tag = v;
      },
      enumerable: true
    });
    this.props = this._factory.createProps(props, {
      buildItemFn: (uu5Tag, props, opts) => Uu5StringObject.create(uu5Tag, props, {
        ...opts,
        initFn,
        uu5DataMap: initialUu5DataMap,
        allowedTagsRegExp,
        _factory: this._factory
      }),
      uu5DataMap: initialUu5DataMap,
      allowedTagsRegExp
    });
    this.parent = parent;
    this.children = [];
    if (!isPairedTag && children.length === 0) {
      let childPropIndex = this.props.props.findIndex(it => it.name === "children");
      if (childPropIndex !== -1) {
        let value = this.props.props[childPropIndex].value;
        this.children = value == null ? [] : Array.isArray(value) ? value : typeof value === "string" ? [Uu5StringTools.escapeEntities(value)] // <b children="<hello>" />    =>   <b>&lt;hello&gt;</b>
        : [value];
        this.props.props.splice(childPropIndex, 1);
      }
    }
    if (typeof children === "string") {
      this.children.push(children);
    } else {
      // filter props set inside children from children and add them into children
      let childProps = {};
      children.forEach((child, index) => {
        let childTag = child.uu5Tag || child.tag;
        if (childTag === "uu5string" || childTag === "uu5json") {
          // find property propName
          let propName = child.props.props.find(prop => prop.name === "propName");
          if (propName) {
            childProps[propName.value] = {
              child,
              index: index
            };
            if (index > 0 && typeof children[index - 1] === "string" && children[index - 1].match(/^\s+$/)) {
              // remove spaces from array oof children
              childProps[propName.value].spacesBefore = this.children.pop();
              // lower index of component
              childProps[propName.value].index--;
            }
            if (childTag === "uu5json") {
              child.children = JSON.parse(child.children);
            } else if (child.children.length === 1 && typeof child.children[0] === "string") {
              child.children = child.children[0];
              child.uu5Tag = child.tag = "string";
            }
          } else {
            this.children.push(child);
          }
        } else {
          this.children.push(child);
        }
      });

      // iterate over all props and update already existing props by the ones from children
      for (let pi = 0; pi < this.props.props.length; pi++) {
        let prop = this.props.props[pi];
        if (childProps[prop.name] !== undefined) {
          prop.value = childProps[prop.name].child.children;
          prop.type = childProps[prop.name].child.uu5Tag || childProps[prop.name].child.tag;
          prop.childrenProperty = true;
          prop.index = childProps[prop.name].index;
          prop.spacesBefore = childProps[prop.name].spacesBefore;
          delete childProps[prop.name];
        }
      }

      // add new props for rest of props children
      for (let propName in childProps) {
        this.props.props.push({
          name: propName,
          value: childProps[propName].child.children,
          valueType: childProps[propName].child.uu5Tag || childProps[propName].child.tag,
          childrenProperty: true,
          index: childProps[propName].index,
          spacesBefore: childProps[propName].spacesBefore
        });
      }
    }

    // remove all forbidden props
    for (let pi = this.props.props.length - 1; pi >= 0; pi--) {
      let prop = this.props.props[pi];
      if (prop.name.match(FORBIDDEN_ATTRS_REGEXP) || !Uu5StringTools.isAllowedTagAndAttrCombination(this.uu5Tag, prop.name, prop.value)) {
        console.warn(`Provided value is not allowed in uu5string for '${this.uu5Tag}' prop '${prop.name}': ${prop.value}`);
        this.props.props.splice(pi, 1);
      }
    }

    // this.children = (typeof children === "string" ? [children] : children) || [];
    this.initFn = initFn;
    this._pairTag = isPairedTag;
    this._initContent();

    // use filter function to let user update component tag and props
    if (typeof initFn === "function") {
      initFn(this);
    }
  }

  /* static methods */
  static create(uu5Tag, props, {
    children,
    isPairedTag,
    initFn,
    parent,
    uu5DataMap,
    allowedTagsRegExp
  } = {}) {
    if (!uu5Tag) return children;
    let _factory = arguments[2] && arguments[2]._factory || defaultFactory;
    return _factory.createObject(uu5Tag, props, {
      children,
      isPairedTag,
      initFn,
      parent,
      uu5DataMap,
      allowedTagsRegExp
    });
  }
}
module.exports = Uu5StringObject;

/***/ }),

/***/ "./uu5-string-props.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright (C) 2019 Unicorn a.s.
 *
 * This program is free software; you can use it under the terms of the UAF Open License v01 or
 * any later version. The text of the license is available in the file LICENSE or at www.unicorn.com.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See LICENSE for more details.
 *
 * You may contact Unicorn a.s. at address: V Kapslovne 2767/2, Praha 3, Czech Republic or
 * at the email: info@unicorn.com.
 */

const Uu5StringTools = __webpack_require__("./internal/tools.js");
const Uu5Data = __webpack_require__("./uu5-data.js");
const Uu5StringObject = __webpack_require__("./uu5-string-object.js");
const defaultFactory = __webpack_require__("./internal/factory.js");
const Constants = __webpack_require__("./internal/constants.js");
const {
  DEFAULT_SEPARATOR,
  DEFAULT_BOUNDARIES,
  DEFAULT_VALUE_DELIMITER
} = Constants;
class Uu5StringProps {
  /* constructor */
  constructor(props, {
    buildItemFn,
    uu5DataMap: initialUu5DataMap,
    allowedTagsRegExp
  } = {}) {
    this._factory = arguments[1] && arguments[1]._factory || defaultFactory;
    /* public methods */
    /*
      Returns props as an array of objects {name, value, separator}.
       @returns array
    */
    this.toArray = () => {
      return this.props;
    };

    /*
      Returns props as a map of name: value
       @returns object
    */
    this.toObject = ({
      uu5DataMap = initialUu5DataMap,
      templateDataMap,
      filterFn,
      preserveValueTypes,
      _extendedResult
    } = {}) => {
      let resultProps = {};
      let tooLongPropItemMap;
      if (!preserveValueTypes) {
        // returned prop values will have transformed form, e.g. an object (if value type was "uu5json") which
        // means that afterwards it's not possible to figure out whether the original prop was uu5json or uu5string.
        this.props.forEach(item => {
          let value = item.value;
          if (item.valueType === "uu5data") value = Uu5Data.parse("<uu5data/>" + item.uu5DataKey, uu5DataMap);
          resultProps[item.name] = value;
        });
      } else {
        // returned prop values will be in original form, e.g. a uu5json string instead of parsed json object
        this.props.forEach(item => {
          resultProps[item.name] =
          // NOTE uu5json is included because it might contain ${expressions} and we must preserve logic that
          // when we send the result of .toObject() into Uu5String constructor and e.g. convert it into JSX,
          // it must work just like when it was in string form, i.e. ${expressions} must get converted (and that
          // will happen only if parser encounters "<uu5json/>...${expressions}", not when it encounters unknown object
          // with "${expressions}" in a value nested somewhere deep).
          item.valueType === "uu5string" || item.valueType === "uu5json" || item.valueType === "uu5data" ? Uu5StringProps._renderItemSerializedValue(item, templateDataMap, filterFn) : item.value;
          // NOTE Using Constants.UU5STRING_LENGTH_LIMIT instead of direct UU5STRING_LENGTH_LIMIT to be able to override
          // the value in tests.
          if ((item.valueType === "uu5string" || item.valueType === "uu5json") && resultProps[item.name].length > Constants.UU5STRING_LENGTH_LIMIT) {
            tooLongPropItemMap ??= {};
            tooLongPropItemMap[item.name] = item;
          }
        });
      }
      return _extendedResult ? {
        props: resultProps,
        tooLongPropItemMap
      } : resultProps;
    };
    this.toChildren = ({
      templateDataMap,
      uu5DataMap = initialUu5DataMap,
      filterFn,
      buildChildFn
    } = {}) => {
      let result = {};
      this.props.forEach(item => result[item.name] = Uu5StringProps._renderItemValueToChildren(item, templateDataMap, uu5DataMap, filterFn, buildChildFn, allowedTagsRegExp));
      return result;
    };

    /*
      Returns props as a string with separators.
       @returns string
    */
    this.toString = ({
      templateDataMap,
      filterFn,
      _extendedResult
    } = {}) => {
      let propsString = "";
      let tooLongPropItemMap;
      this.props.forEach(item => {
        if (item.value !== undefined || item.valueType === "uu5data") {
          let transformedPropValue = Uu5StringProps._renderItemValueToString(item, templateDataMap, filterFn);
          let isString = typeof transformedPropValue === "string";
          if (isString && (item.valueType === "uu5string" || item.valueType === "uu5json") && transformedPropValue.length > Constants.UU5STRING_LENGTH_LIMIT) {
            tooLongPropItemMap ??= {};
            tooLongPropItemMap[item.name] = item;
          } else {
            let escapedValue;
            let boundaries = "";
            if (isString) {
              // escape prop value
              if (item.valueBoundaries === undefined) {
                boundaries = DEFAULT_BOUNDARIES;
              } else if (item.valueBoundaries) {
                boundaries = item.valueBoundaries;
              }
              // escape content
              if (boundaries === "'") {
                escapedValue = transformedPropValue.replace(/([\\'])/g, "\\$1");
              } else if (boundaries === '"') {
                escapedValue = transformedPropValue.replace(/([\\"])/g, "\\$1");
              } else {
                escapedValue = transformedPropValue;
              }
            } else {
              escapedValue = transformedPropValue;
            }
            let attrValue = escapedValue === undefined ? "" : `${item.valueDelimiter || DEFAULT_VALUE_DELIMITER}${boundaries}${escapedValue}${boundaries}`;
            propsString += `${item.separator || DEFAULT_SEPARATOR}${item.name}${attrValue}`;
          }
        }
      });
      propsString += this.lastSeparator;
      return _extendedResult ? {
        propsString,
        tooLongPropItemMap
      } : propsString;
    };

    /*
      Returns props as a string with separators.
       @returns string
    */
    this.toPlainText = ({
      templateDataMap,
      uu5DataMap,
      filterFn
    } = {}) => {
      let result = [];
      this.props.forEach(item => {
        result.push(Uu5StringProps._renderItemValueToPlainText(item, templateDataMap, uu5DataMap, filterFn));
      });
      return result.join(" ");
    };
    this.clone = ({
      initFn
    } = {}) => {
      let newPropsObject = this._factory.createProps(undefined, {
        allowedTagsRegExp
      });
      // set last separator
      newPropsObject.lastSeparator = this.lastSeparator;
      // set all props as a new array
      newPropsObject.props = this.props.map(item => {
        let newItem = {};
        // clone all attributes
        for (let attr in item) {
          newItem[attr] = item[attr];
        }
        // clone object in value attribute - other attributes has only string values
        if (newItem.value) {
          let isArray = Array.isArray(newItem.value);
          let value = (isArray ? newItem.value : [newItem.value]).map(valueItem => {
            if (typeof valueItem === "object") {
              // instead of: valueItem instanceof Uu5StringObject
              if (typeof valueItem.clone === "function") {
                return valueItem.clone({
                  initFn
                });
              } else {
                return {
                  ...valueItem
                }; // clone object
              }
            }
            // return other values
            return valueItem;
          });
          newItem.value = isArray ? value : value[0];
        }
        return newItem;
      });
      return newPropsObject;
    };

    // constructor logic
    // parse props string into array of props - each prop have its name, value and separator - props are ordered by its order in string
    this.props = props ? typeof props === "string" ? Uu5StringProps.parse(props, {
      buildItemFn,
      uu5DataMap: initialUu5DataMap,
      allowedTagsRegExp
    }) : Uu5StringProps.parseObject(props, {
      buildItemFn,
      uu5DataMap: initialUu5DataMap,
      allowedTagsRegExp
    }) : [];
    this.lastSeparator = props && typeof props === "string" ? props.match(/\s*$/)[0] : "";
  }

  /* static methods */
  static parse(attrsString, {
    buildItemFn,
    uu5DataMap,
    allowedTagsRegExp
  } = {}) {
    return Uu5StringTools.parseUu5StringProps(attrsString, buildItemFn, uu5DataMap, allowedTagsRegExp);
  }
  static parseObject(attrsString, {
    buildItemFn,
    uu5DataMap,
    allowedTagsRegExp
  } = {}) {
    return Uu5StringTools.parseUu5StringPropsObject(attrsString, buildItemFn, uu5DataMap, allowedTagsRegExp);
  }

  /* private static methods */
  static _renderItemValueToString(item, templateDataMap, filterFn) {
    let context = Uu5StringTools.getPropTemplateContext(item);
    let result;
    if (item.valueType === "uu5string") {
      result = "<uu5string/>" + Uu5StringTools.contentToString(item.value, templateDataMap, filterFn);
    } else if (item.valueType === "uu5json") {
      result = "<uu5json/>" + Uu5StringTools.printTemplateToString(JSON.stringify(item.value, undefined, 2), templateDataMap, context);
    } else if (item.valueType === "uu5data") {
      result = "<uu5data/>" + item.uu5DataKey;
    } else if (typeof item.value === "string") {
      result = Uu5StringTools.printTemplateToString(item.value, templateDataMap, context);
    } else if (item.value && typeof item.value === "object") {
      // same as uu5json
      if (Array.isArray(item.value) && item.value.some(elem => elem instanceof Uu5StringObject)) {
        result = "<uu5string/>";
        item.value.forEach(elem => result += elem.toString({
          templateDataMap,
          filterFn
        }));
      } else {
        result = "<uu5json/>" + Uu5StringTools.printTemplateToString(JSON.stringify(item.value, undefined, 2), templateDataMap, context);
      }
    } else if (item.value !== true) {
      result = item.value;
    }
    return result;
  }

  /* private static methods */
  static _renderItemValueToPlainText(item, templateDataMap, uu5DataMap, filterFn) {
    if (typeof item.value === "boolean") return "";
    let result;
    if (item.valueType === "uu5string") {
      result = Uu5StringTools.contentToPlainText(item.value, templateDataMap, uu5DataMap, filterFn);
    } else if (item.valueType === "uu5json") {
      result = JSON.stringify(item.value, undefined, 2);
    } else if (typeof item.value === "string") {
      let context = Uu5StringTools.getPropTemplateContext(item);
      result = Uu5StringTools.printTemplateToString(item.value, templateDataMap, context);
    } else {
      result = item.value + "";
    }
    return result;
  }
  static _renderItemValueToChildren(item, templateDataMap, uu5DataMap, filterFn, buildChildFn, allowedTagsRegExp) {
    let context = Uu5StringTools.getPropTemplateContext(item);
    if (item.valueType === "uu5string") {
      return Uu5StringTools.contentToChildren(item.value, templateDataMap, uu5DataMap, filterFn, buildChildFn, allowedTagsRegExp);
    } else if (item.valueType === "uu5json") {
      return item.value ? JSON.parse(Uu5StringTools.printTemplateToString(JSON.stringify(item.value), templateDataMap, context)) : {};
    } else if (item.valueType === "uu5data") {
      item.value = Uu5Data.parse("<uu5data/>" + item.uu5DataKey, uu5DataMap);
      return item.value;
    }
    return typeof item.value === "string" ? Uu5StringTools.printTemplateToChildren(item.value, templateDataMap, uu5DataMap, buildChildFn, allowedTagsRegExp, context) : item.value;
  }
  static _renderItemSerializedValue(item, templateDataMap, filterFn) {
    let context = Uu5StringTools.getPropTemplateContext(item);
    let result;
    if (item.valueType === "uu5string") {
      result = "<uu5string/>" + Uu5StringTools.contentToString(item.value, templateDataMap, filterFn);
    } else if (item.valueType === "uu5json") {
      result = "<uu5json/>" + Uu5StringTools.printTemplateToString(JSON.stringify(item.value, undefined, 2), templateDataMap, context);
    } else if (item.valueType === "uu5data") {
      result = "<uu5data/>" + item.uu5DataKey;
    } else {
      result = item.value !== undefined ? item.value + "" : "";
    }
    return result;
  }
}
module.exports = Uu5StringProps;

/***/ }),

/***/ "./uu5-string.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright (C) 2019 Unicorn a.s.
 *
 * This program is free software; you can use it under the terms of the UAF Open License v01 or
 * any later version. The text of the license is available in the file LICENSE or at www.unicorn.com.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See LICENSE for more details.
 *
 * You may contact Unicorn a.s. at address: V Kapslovne 2767/2, Praha 3, Czech Republic or
 * at the email: info@unicorn.com.
 */

const Uu5StringTools = __webpack_require__("./internal/tools.js");
const Uu5StringObject = __webpack_require__("./uu5-string-object.js");
const Uu5StringProps = __webpack_require__("./uu5-string-props.js");
const {
  REGEXP
} = __webpack_require__("./internal/uu5-common-tools.js");
const defaultFactory = __webpack_require__("./internal/factory.js");
class Uu5String {
  // TODO to 2.0.0 remove templateDataMap from constructor!
  constructor(uu5string, {
    templateDataMap,
    uu5DataMap: initialUu5DataMap,
    allowedTagsRegExp,
    initFn = null
  } = {}) {
    this._factory = arguments[1] && arguments[1]._factory || defaultFactory;
    this.templateDataMap = templateDataMap;
    this.initFn = initFn;

    /*
      Transform content of Uu5String into React components. If parameter templateDataMap is undefined, templateDataMap passed into constructor will be used instead.
       @param opts.templateDataMap - map with data for Uu5String templates
      @param filterFn({uu5Tag, props}) - function to change tag and props used for rendering into components. Function is called for each descendant Uu5StringObject before creation of React component. This function cannot change data of Uu5StringObjects.
      @returns array of React components
      */
    this.toChildren = ({
      templateDataMap = this.templateDataMap || {},
      uu5DataMap = initialUu5DataMap,
      filterFn,
      buildChildFn
    } = {}) => {
      return Uu5StringTools.contentToChildren(this.content, templateDataMap, uu5DataMap, filterFn, buildChildFn, allowedTagsRegExp);
    };

    /*
      Transform content into string. If parameter templateDataMap is undefined, templateDataMap passed into constructor will be used instead.
       @param opts.templateDataMap - map with data for Uu5String templates
      @param filterFn({uu5Tag, props}) - function to change tag and props used for printing into string. Function is called for each descendant Uu5StringObject before print into string. This function cannot change data of Uu5StringObjects.
      @returns string
    */
    this.toString = ({
      templateDataMap = this.templateDataMap || null,
      filterFn
    } = {}) => {
      return Uu5StringTools.contentToString(this.content, templateDataMap, filterFn);
    };

    /*
      Transform content into object. If parameter templateDataMap is undefined, templateDataMap passed into constructor will be used instead.
       @param opts.templateDataMap - map with data for Uu5String templates
      @param filterFn({uu5Tag, props}) - function to change tag and props used for printing into string. Function is called for each descendant Uu5StringObject before print into string. This function cannot change data of Uu5StringObjects.
      @returns string
    */
    this.toObject = ({
      templateDataMap = this.templateDataMap || null,
      filterFn
    } = {}) => {
      return Uu5StringTools.contentToObject(this.content, templateDataMap, filterFn);
    };

    /*
      Transform content into plain text. Returned string will not contain tags, but only text from their props. If parameter templateDataMap is undefined, templateDataMap passed into constructor will be used instead.
       @param opts.templateDataMap - map with data for Uu5String templates
      @param filterFn({uu5Tag, props}) - function to change props used for printing into plain text. Function is called for each descendant Uu5StringObject before print props into plain text.
      @returns string
    */
    this.toPlainText = ({
      templateDataMap = this.templateDataMap || {},
      uu5DataMap = initialUu5DataMap,
      filterFn
    } = {}) => {
      return Uu5StringTools.contentToPlainText(this.content, templateDataMap, uu5DataMap, filterFn);
    };

    /*
      Returns new instance of Uu5String. If parameter templateDataMap is undefined, templateDataMap passed into constructor will be used instead.
       @param opts.templateDataMap - data for Uu5StringTemplates
      @returns Uu5String instance.
    */
    this.clone = ({
      templateDataMap = this.templateDataMap,
      uu5DataMap = initialUu5DataMap,
      initFn = this.initFn
    } = {}) => {
      let result = this._factory.createString(null, {
        templateDataMap,
        uu5DataMap
      });
      if (!this.content) return result;
      result.content = this.content.map(item => typeof item === "string" ? item : item.clone({
        initFn
      }));
      return result;
    };

    // constructor logic
    const buildItemFn = (uu5Tag, props, opts) => Uu5StringObject.create(uu5Tag, props, {
      ...opts,
      initFn,
      uu5DataMap: initialUu5DataMap,
      allowedTagsRegExp,
      _factory: this._factory
    });
    this.content = !uu5string || typeof uu5string === "string" ? Uu5String.parse(uu5string, {
      buildItemFn,
      uu5DataMap: initialUu5DataMap,
      allowedTagsRegExp
    }) : Uu5String.parseTagPropsArray(Array.isArray(uu5string) ? uu5string : [uu5string], {
      buildItemFn,
      uu5DataMap: initialUu5DataMap,
      allowedTagsRegExp
    });
  }

  /* static functions */
  static parse(uu5string, {
    buildItemFn,
    uu5DataMap,
    allowedTagsRegExp
  } = {}) {
    if (buildItemFn === undefined) {
      let _factory = arguments[1] && arguments[1]._factory || defaultFactory;
      buildItemFn = (uu5Tag, propsString, opts) => Uu5StringObject.create(uu5Tag, propsString, {
        ...opts,
        _factory
      });
    }
    return Uu5StringTools.parseUu5String(uu5string, buildItemFn, uu5DataMap, allowedTagsRegExp);
  }
  static parseTagPropsArray(uu5object, {
    buildItemFn,
    uu5DataMap,
    allowedTagsRegExp
  } = {}) {
    if (buildItemFn === undefined) {
      let _factory = arguments[1] && arguments[1]._factory || defaultFactory;
      buildItemFn = (uu5Tag, props, opts) => Uu5StringObject.create(uu5Tag, props, {
        ...opts,
        _factory
      });
    }
    return Uu5StringTools.parseTagPropsArray(uu5object, buildItemFn, uu5DataMap, allowedTagsRegExp);
  }
  static isValid(uu5string) {
    return Uu5StringTools.isValidUu5String(uu5string);
  }
  static toChildren(uu5string, {
    templateDataMap,
    uu5DataMap,
    filterFn,
    buildChildFn,
    allowedTagsRegExp
  } = {}) {
    let _factory = arguments[1] && arguments[1]._factory || defaultFactory;
    return _factory.createString(uu5string, {
      allowedTagsRegExp
    }).toChildren({
      templateDataMap,
      uu5DataMap,
      filterFn,
      buildChildFn
    });
  }
  static toString(uu5string, {
    templateDataMap,
    filterFn,
    allowedTagsRegExp
  } = {}) {
    let _factory = arguments[1] && arguments[1]._factory || defaultFactory;
    return _factory.createString(uu5string, {
      allowedTagsRegExp
    }).toString({
      templateDataMap,
      filterFn
    });
  }
  static toObject(uu5string, {
    templateDataMap,
    filterFn,
    allowedTagsRegExp
  } = {}) {
    let _factory = arguments[1] && arguments[1]._factory || defaultFactory;
    return _factory.createString(uu5string, {
      allowedTagsRegExp
    }).toObject({
      templateDataMap,
      filterFn
    });
  }
  static toPlainText(uu5string, {
    templateDataMap,
    uu5DataMap,
    filterFn,
    allowedTagsRegExp
  } = {}) {
    let _factory = arguments[1] && arguments[1]._factory || defaultFactory;
    return _factory.createString(uu5string, {
      allowedTagsRegExp
    }).toPlainText({
      templateDataMap,
      uu5DataMap,
      filterFn
    });
  }
  static contentToChildren(content, {
    templateDataMap,
    uu5DataMap,
    filterFn,
    buildChildFn
  } = {}) {
    return Uu5StringTools.contentToChildren(content, templateDataMap, uu5DataMap, filterFn, buildChildFn);
  }
  static contentToString(content, {
    templateDataMap,
    filterFn
  } = {}) {
    return Uu5StringTools.contentToString(content, templateDataMap, filterFn);
  }
  static contentToObject(content, {
    templateDataMap,
    filterFn
  } = {}) {
    return Uu5StringTools.contentToObject(content, templateDataMap, filterFn);
  }
  static contentToPlainText(content, {
    templateDataMap,
    uu5DataMap,
    filterFn
  } = {}) {
    return Uu5StringTools.contentToPlainText(content, templateDataMap, uu5DataMap, filterFn);
  }
}
Uu5String.Props = Uu5StringProps;
Uu5String.Object = Uu5StringObject;
Uu5String.REGEXP = {
  uu5string: REGEXP.uu5string,
  uu5json: REGEXP.uu5json,
  uu5data: REGEXP.uu5data
};
Object.defineProperties(Uu5String, {
  // "private" for uu5g04
  _textEntityMap: {
    get: () => __webpack_require__("./internal/text-entity-map.js")
  }
});
defaultFactory.init(Uu5String, Uu5StringObject, Uu5StringProps);
module.exports = Uu5String;

/***/ }),

/***/ "../target/webpack-tmp/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mod = __webpack_require__("module");
var isDoc = typeof document !== "undefined";
var uri = ((mod ? mod.uri : isDoc && (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName("script"), -1)[0] || {}).src) || "").toString();
uri = uri.split(/\//).slice(0, -1).join("/") + "/"; // runtime publicPath configuration required for proper linking of styles, background images, ...
var floatingVersion = "/1.0.0/";
if (uri.substr(-floatingVersion.length) === floatingVersion) uri = uri.substr(0, uri.length - floatingVersion.length) + "/1.9.1/";
__webpack_require__.p = (typeof process !== "undefined" && process.env && (process.env.NODE_ENV) || "development") === "test" && uri === "/" ? "file://" + eval("__filename").replace(/[^/\\]*$/, "") : uri;
module.exports = __webpack_require__("./index.js");
var ex = module.exports;
if (ex && typeof ex === "object") {
  if (!("version" in ex)) Object.defineProperty(ex, "version", {
    configurable: true,
    value: "1.9.1"
  });
  if (!("name" in ex)) Object.defineProperty(ex, "name", {
    configurable: true,
    value: "uu5stringg01".split(/[\/\\]/).pop()
  });
  if (!("namespace" in ex)) Object.defineProperty(ex, "namespace", {
    configurable: true,
    value: "Uu5String"
  });
}

/***/ }),

/***/ "module":
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_module__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "";
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("../target/webpack-tmp/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});