/**
 * Copyright (C) 2019 Unicorn a.s.
 *
 * This program is free software; you can use it under the terms of the UAF Open License v01 or
 * any later version. The text of the license is available in the file LICENSE or at www.unicorn.com.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See LICENSE for more details.
 *
 * You may contact Unicorn a.s. at address: V Kapslovne 2767/2, Praha 3, Czech Republic or
 * at the email: info@unicorn.com.
 */

const SYMBOLS = require("./symbols");
const {
  TAG,
  TEMPLATE_REG_EXP,
  UU5STRING_REGEXP,
  ATTR_REGEXP,
  ATTR_VALUE_TYPE_REGEXP,
  UU5DATA_REGEXP,
  JSCODE_REGEXP,
  DEFAULT_SEPARATOR,
  DEFAULT_BOUNDARIES,
  DEFAULT_VALUE_DELIMITER,
  FORBIDDEN_TAGS_REGEXP,
  FORBIDDEN_TAGS_REGEXP2,
  FORBIDDEN_ATTRS_REGEXP,
  UU5JSON_REGEXP,
  TAG_WITH_MAYBE_BROKEN_ATTR_WITH_QUOTE,
  ATTR,
  BROKEN_ATTR_WITH_QUOTE,
} = require("./constants");
const TextEntityMap = require("./text-entity-map.js");
const Uu5Data = require("../uu5-data.js");
const Uu5Json = require("../uu5-json.js");

const Tools = {
  /*
    Transform content into React components.

    @param content - array of Uu5StringObjects, strings, numbers, booleans and Uu5StringTemplates
    @param templateDataMap - map with data for Uu5String templates
    @param filterFn({uu5Tag, props}) - function to change tag and props used for rendering into components. Function is called for each descendant Uu5StringObject before creation of React component. This function cannot change data of Uu5StringObjects.
    @returns array of React components
   */
  contentToChildren(content, templateDataMap, uu5DataMap, filterFn, buildChildFn, allowedTagsRegExp) {
    if (!content || !content.length) {
      return null;
    }
    let context = Tools.getContentTemplateContext();
    return content.map((item, index) =>
      typeof item === "string"
        ? Tools.printTemplateToChildren(
            TextEntityMap.replace(item),
            templateDataMap,
            uu5DataMap,
            buildChildFn,
            allowedTagsRegExp,
            context
          )
        : item.toChildren({ templateDataMap, uu5DataMap, filterFn, buildChildFn, index })
    );
  },

  /*
    Transform content into string.

    @param content - array of Uu5StringObjects, strings, numbers, booleans and Uu5StringTemplates
    @param templateDataMap - map with data for Uu5String templates
    @param filterFn({uu5Tag, props}) - function to change tag and props used for printing into string. Function is called for each descendant Uu5StringObject before print into string. This function cannot change data of Uu5StringObjects.
    @returns string
  */
  contentToString(content, templateDataMap, filterFn) {
    if (!content || !content.length) {
      return "";
    }
    let context = Tools.getContentTemplateContext();
    if (typeof content === "string") {
      return Tools.printTemplateToString(content, templateDataMap, context);
    }
    let result = "";
    content.forEach(
      (item) =>
        (result +=
          typeof item === "string"
            ? Tools.printTemplateToString(item, templateDataMap, context)
            : item.toString({ templateDataMap, filterFn }))
    );
    return result;
  },
  /*
    Transform content into object.

    @param content - array of Uu5StringObjects, strings, numbers, booleans and Uu5StringTemplates
    @param templateDataMap - map with data for Uu5String templates
    @param filterFn({uu5Tag, props}) - function to change tag and props used for printing into string. Function is called for each descendant Uu5StringObject before print into string. This function cannot change data of Uu5StringObjects.
    @returns string
  */
  contentToObject(content, templateDataMap, filterFn) {
    if (!content || !content.length) {
      return [];
    }
    let context = Tools.getContentTemplateContext();
    return content.map((item) =>
      typeof item === "string"
        ? Tools.printTemplateToString(item, templateDataMap, context)
        : item.toObject({ templateDataMap, filterFn })
    );
  },

  /*
    Transform content into plain text. Returned string will not contain tags, but only text from their props. If parameter templateDataMap is undefined, templateDataMap passed into constructor will be used instead.

    @param templateDataMap - map with data for Uu5String templates
    @param filterFn({uu5Tag, props}) - function to change props used for printing into plain text. Function is called for each descendant Uu5StringObject before print props into plain text.
    @returns string
  */
  contentToPlainText(content, templateDataMap, uu5DataMap, filterFn) {
    if (!content || !content.length) {
      return "";
    }
    let context = Tools.getContentTemplateContext();
    if (typeof content === "string") {
      return Tools.printTemplateToString(content, templateDataMap, context);
    }
    let result = "";
    content.forEach((item) => {
      result +=
        (result ? " " : "") +
        (typeof item === "string"
          ? Tools.printTemplateToString(item, templateDataMap, context)
          : item.toPlainText({ templateDataMap, uu5DataMap, filterFn }));
    });
    return result.replace(/\s+/g, " ").trim();
  },

  printTemplateToString(string, templateDataMap, context) {
    if (!templateDataMap) {
      return string;
    }
    let result = Tools._printTemplate(string, templateDataMap, context);
    return result.length === 1 ? result[0] : result.join("");
  },

  printTemplateToChildren(string, templateDataMap, uu5DataMap, buildChildFn, allowedTagsRegExp, context) {
    if (!templateDataMap) {
      return string;
    }
    let isChildren;
    let canJoin = true;
    let result = Tools._printTemplate(string, templateDataMap, context, (matchValue) => {
      let result = matchValue;
      let exact = false;
      if (typeof matchValue === "string" && matchValue.match(UU5STRING_REGEXP) && Tools.isValidUu5String(matchValue)) {
        isChildren = true;
        // create component by buildChildFn (e.g. UU5.Common.Tools.findComponent)
        result = Tools.parseUu5String(
          matchValue,
          Tools._buildChildItem.bind(Tools, buildChildFn),
          uu5DataMap,
          allowedTagsRegExp
        );
      } else if (typeof matchValue === "string" && matchValue.match(UU5JSON_REGEXP)) {
        try {
          result = Uu5Json.parse(matchValue);
          exact = true;
        } catch (e) {
          // ignore (result will be matchValue)
        }
      } else if (matchValue && typeof matchValue === "object") {
        canJoin = false;
        exact = true;
      }
      return { value: result, exact };
    });

    // result contains parsed Uu5String - return array
    if (isChildren) return result;

    return result.length === 1 ? result[0] : canJoin ? result.join("") : result;
  },

  buildChild(buildChildFn, uu5Tag, props, children, context) {
    let result;
    if (typeof buildChildFn === "function") {
      result = buildChildFn(uu5Tag, props, children, context);
    } else {
      result = { uu5Tag, tag: uu5Tag, props, children };
    }
    return result;
  },

  _buildChildItem(buildChildFn, uu5Tag, propsString, { children, uu5DataMap, allowedTagsRegExp } = {}) {
    if (!uu5Tag) return children;
    let propsArray = propsString
      ? Tools.parseUu5StringProps(
          propsString,
          Tools._buildChildItem.bind(Tools, buildChildFn),
          uu5DataMap,
          allowedTagsRegExp
        )
      : [];
    let props = {};
    propsArray.forEach((item) => (props[item.name] = item.value));
    return Tools.buildChild(buildChildFn, uu5Tag, props, children);
  },

  _printTemplate(string, templateDataMap, context, matchHandler) {
    // check if string is single template - in this case return template result ( posible another type then string )
    // let isTemplate = string.match(CHECK_IS_TEMPLATE);
    let useMatchHandler = typeof matchHandler === "function";

    let result = [];
    let templateRegExp = new RegExp(TEMPLATE_REG_EXP); // must be new instance (regexp-s mutate their .lastIndex in successive .exec() calls and we don't want it to be remembered for another uu5string / for matchHandler call)
    let templateMatch = templateRegExp.exec(string);
    let startIndex = 0;
    let endIndex = 0;
    /*
    template[1] - name
    template[2] - default value prefixed by :
    template[3] - default value
    */
    while (templateMatch) {
      let templateName = templateMatch[1];
      let value;

      endIndex = templateRegExp.lastIndex - templateMatch[0].length;
      if (endIndex > startIndex) {
        result.push(string.substring(startIndex, endIndex));
      }
      startIndex = templateRegExp.lastIndex;
      let templateNamePath = templateName.split(".");

      let templateContext = {
        ...context,
        value: string,
        matchValue: templateMatch[0],
        matchStartIndex: endIndex,
        matchEndIndex: startIndex,
      };
      if (templateDataMap[templateName]) {
        // check data
        let template = templateDataMap[templateName];
        value = typeof template === "function" ? template(templateMatch[3], [templateName], templateContext) : template;
      } else {
        // check data path
        let template = templateDataMap;
        for (let i = 0; i < templateNamePath.length; i++) {
          template = template[templateNamePath[i]];
          if (typeof template === "function" || template == null) break;
        }
        if (typeof template === "function") {
          value = template(templateMatch[3], templateNamePath, templateContext);
        } else if (template != null) {
          value = template;
        } else if (SYMBOLS[templateName]) {
          // check symbols
          let template = SYMBOLS[templateName];
          value = typeof template === "function" ? template(templateMatch[3]) : template;
        } else {
          // replace template by default value or empty string
          value = templateMatch[3] === undefined ? templateMatch[0] : templateMatch[3];
        }
      }

      if (useMatchHandler) {
        let { value: matchResult, exact } = matchHandler(value);
        if (exact) {
          result.push(matchResult);
        } else if (Array.isArray(matchResult)) {
          matchResult.forEach((item) => result.push(item));
        } else {
          result.push(matchResult);
        }
      } else {
        result.push(value);
      }

      templateMatch = templateRegExp.exec(string);
    }

    // add string after end of last match
    if (startIndex < string.length) {
      result.push(string.substring(startIndex));
    }

    return result;
  },

  isValidUu5String(uu5string) {
    if (typeof uu5string !== "string") return false;
    try {
      Tools.parseUu5String(uu5string);
      return true;
    } catch (e) {
      return false;
    }
  },

  parseUu5String(uu5string, buildItemFn, uu5DataMap, allowedTagsRegExp) {
    if (!uu5string || typeof uu5string !== "string" || uu5string.length === 0) {
      return [];
    }

    uu5string = uu5string.trim().replace(/\r\n/g, "\n");

    let childStack = [
      {
        uu5Tag: "_root",
        children: [],
        index: 0,
      },
    ];

    let pointer = childStack[0];

    let cIndex = -1;
    let pIndex = 0;
    let pre = false;
    let preTag = "";

    let matchS;
    let matchUu5String = uu5string.match(UU5STRING_REGEXP);
    if (matchUu5String) {
      // !!!!! Never put uu5stringRe to constants, otherwise it gets stuck - because of exec method on regexp
      // groups: comp name, comp name suffix, attrs, -, -, -, self-closing, closing tag comp name, content upto next tag
      let tagRe = new RegExp(TAG_WITH_MAYBE_BROKEN_ATTR_WITH_QUOTE, "g");
      pIndex = tagRe.lastIndex = matchUu5String[0].length;
      matchS = tagRe.exec(uu5string);

      while (matchS) {
        cIndex = matchS.index;
        if (cIndex > pIndex) {
          let head = uu5string.substring(pIndex, cIndex);
          let text = head;
          // let text = pre ? TextEntityMap.replaceHtmlEntity(head) : TextEntityMap.replace(head);
          pointer.children.push(
            typeof buildItemFn === "function"
              ? buildItemFn(null, null, { children: text, uu5DataMap, allowedTagsRegExp })
              : text
          );
          Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1]);
        }
        let isTagWithBrokenAttrs = !uu5string.slice(cIndex, cIndex + matchS[0].length).match(TAG);
        let childTag = matchS[2] || matchS[14];
        let childTagNoVersion = childTag.slice(
          0,
          childTag.length - ((childTag === matchS[2] ? matchS[3] : matchS[15]) || "").length
        );
        let attrs = matchS[4];
        let isClosing = !!matchS[14];
        let isSelfClosing = !!matchS[13];
        let openingTagLengthIfBroken = isTagWithBrokenAttrs ? matchS[1].length : 0;
        let tagObj;

        if (
          (pre && !(childTag === preTag && isClosing)) ||
          (!isTagWithBrokenAttrs &&
            (childTagNoVersion.match(FORBIDDEN_TAGS_REGEXP) || childTagNoVersion.match(FORBIDDEN_TAGS_REGEXP2)))
        ) {
          let text = matchS[0];
          // let text = TextEntityMap.replaceHtmlEntity(matchS[0]);
          pointer.children.push(
            typeof buildItemFn === "function"
              ? buildItemFn(null, null, { children: text, uu5DataMap, allowedTagsRegExp })
              : text
          );
          Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1]);
        } else if (isTagWithBrokenAttrs) {
          let attrRegExp = new RegExp(`${BROKEN_ATTR_WITH_QUOTE}|${ATTR}`, "g");
          let brokenQuoteIndex;
          attrs.replace(
            attrRegExp,
            function (m, groupBeforeQuotedValue, groupBeforeOffendingDoubleQuote, groupBeforeOffendingSingleQuote) {
              let attrMatch = m.match(new RegExp(ATTR));
              if (attrMatch && attrMatch[0].length === m.length) return;
              if (brokenQuoteIndex === undefined) {
                let skippedAttributesLength = arguments[9];
                brokenQuoteIndex =
                  matchS.index +
                  openingTagLengthIfBroken + // opening tag name - `<Component`
                  skippedAttributesLength + // skipped (valid) attributes - ` foo="bar"`
                  groupBeforeQuotedValue.length + // attribute name & equals sign - ` invalid="`
                  (groupBeforeOffendingDoubleQuote || groupBeforeOffendingSingleQuote).length; // attribute content up to bad quote - `quote in attr: `
              }
            }
          );
          let err = new Error(`Invalid uu5string: Detected unescaped quote(s) in an attribute value.`);
          err.code = "uu5StringInvalid";
          err.context = { uu5string, uu5Tag: childTag, tag: childTag, index: brokenQuoteIndex };
          throw err;
        } else {
          if (isClosing) {
            //closing tag

            tagObj = childStack.pop();

            if (tagObj.uu5Tag !== childTag) {
              const err = new Error(
                `Invalid uu5string: Tag ${tagObj.uu5Tag} at position ${tagObj.index} is not closed.`
              );
              err.code = "uu5StringInvalid";
              err.context = { uu5string, uu5Tag: tagObj.uu5Tag, tag: tagObj.uu5Tag, index: tagObj.index };
              throw err;
            }

            pointer = childStack[childStack.length - 1];

            if (pre) {
              pre = false;
              let text = tagObj.children.join("");
              // let text = TextEntityMap.replaceHtmlEntity(tagObj.children.join(''));
              pointer.children[pointer.children.length - 1] =
                typeof buildItemFn === "function"
                  ? buildItemFn(tagObj.uu5Tag, tagObj.attrs, { children: text, uu5DataMap, allowedTagsRegExp })
                  : text;
              Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1], tagObj.uu5Tag);
            } else {
              if (tagObj.forbidden) {
                tagObj.children = `Error: Tag <${tagObj.uu5Tag} /> is not allowed.`;
                tagObj.attrs = ` uu5Tag="${tagObj.uu5Tag}" tag="${tagObj.uu5Tag}"`;
                tagObj.uu5Tag = tagObj.tag = "invalidTag";
              }
              pointer.children[pointer.children.length - 1] =
                typeof buildItemFn === "function"
                  ? buildItemFn(tagObj.uu5Tag, tagObj.attrs, {
                      children: tagObj.children,
                      isPairedTag: true,
                      uu5DataMap,
                      allowedTagsRegExp,
                    })
                  : tagObj;
              Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1], tagObj.uu5Tag);
            }
          } else {
            // prevent parsing json inside uu5json
            pre = childTag === "uu5string.pre" || childTag === "uu5json";
            preTag = childTag;
            tagObj = { uu5Tag: childTag, children: [], index: matchS.index };

            if (allowedTagsRegExp && !allowedTagsRegExp.test(childTagNoVersion)) {
              tagObj.forbidden = true;
            } else if (attrs) {
              tagObj.attrs = attrs;
            }

            if (isSelfClosing) {
              //self-closing tag
              pre = false;

              if (childTag.indexOf("uu5string.") === 0) {
                //meta-tag uu5string.*
                let s = Tools.execMetaTag(childTag, tagObj.attrs);
                if (s) {
                  s.forEach((item) => {
                    pointer.children.push(
                      typeof buildItemFn === "function"
                        ? buildItemFn(null, null, { children: item, uu5DataMap, allowedTagsRegExp })
                        : item
                    );
                    Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1]);
                  });
                }
              } else {
                if (tagObj.forbidden) {
                  tagObj.children = `Error: Tag <${tagObj.uu5Tag} /> is not allowed.`;
                  tagObj.attrs = ` uu5Tag="${tagObj.uu5Tag}" tag="${tagObj.uu5Tag}"`;
                  tagObj.uu5Tag = tagObj.tag = "invalidTag";
                }
                pointer.children.push(
                  typeof buildItemFn === "function"
                    ? buildItemFn(tagObj.uu5Tag, tagObj.attrs, {
                        children: tagObj.children,
                        isPairedTag: false,
                        uu5DataMap,
                        allowedTagsRegExp,
                      })
                    : tagObj
                );
                Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1], tagObj.uu5Tag);
              }
            } else {
              //common tag
              pointer.children.push(tagObj);
              childStack.push(tagObj);
              pointer = tagObj;
            }
          }
        }
        pIndex = cIndex + matchS[0].length;
        matchS = tagRe.exec(uu5string);
      }
      // handle ending text
      if (pIndex < uu5string.length) {
        let text = uu5string.substr(pIndex);
        // text = pre ? TextEntityMap.replaceHtmlEntity(text) : TextEntityMap.replace(text);
        pointer.children.push(
          typeof buildItemFn === "function"
            ? buildItemFn(null, null, { children: text, uu5DataMap, allowedTagsRegExp })
            : text
        );
        Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1]);
      }

      if (childStack.length > 1) {
        let tagObj = childStack.pop();

        const err = new Error(`Invalid uu5string: Tag ${tagObj.uu5Tag} at position ${tagObj.index} is not closed.`);
        err.code = "uu5StringInvalid";
        err.context = { uu5string, uu5Tag: tagObj.uu5Tag, tag: tagObj.uu5Tag, index: tagObj.index };
        throw err;
      }
    } else {
      pointer.children.push(
        typeof buildItemFn === "function"
          ? buildItemFn(null, null, { children: uu5string, uu5DataMap, allowedTagsRegExp })
          : uu5string
      );
      Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1]);
    }

    return pointer.children;
  },

  parseUu5StringProps(attrsString, buildItemFn, uu5DataMap, allowedTagsRegExp) {
    let attrs = [];

    // group1 = separator
    // group2 = attribute name
    // group3 = name and value separator
    // group4 = attribute value
    // group5 = indication that attribute value is not wrapped into quotes / single quotes
    let attrsReg = new RegExp(ATTR_REGEXP.source, "g");
    let matchAttrs = attrsReg.exec(attrsString);

    while (matchAttrs) {
      let separator = matchAttrs[1];
      let name = matchAttrs[2];
      let valueDelimiter = matchAttrs[3];
      let valueBoundaries = "";
      let value = true;
      let uu5DataKey = undefined;
      let valueType = null; // hold info if data is parsed from uu5string, uu5data or uu5json
      let matchValue = matchAttrs[4];
      let isUnquoted = !!matchAttrs[5];

      if (!name.match(FORBIDDEN_ATTRS_REGEXP)) {
        if (isUnquoted) {
          if (matchValue === "true") {
            //true
            value = true;
          } else if (matchValue === "false") {
            //false
            value = false;
          } else if (isFinite(matchValue)) {
            //number
            value = +matchValue;
          } else {
            //any other -> null | undefined
            value = matchValue === "undefined" ? undefined : null;
          }
        } else if (matchValue != null) {
          // unescape quoted value
          if (matchValue[0] === "'") {
            valueBoundaries = "'";
            matchValue = matchValue.substr(1, matchValue.length - 2).replace(/\\([\\'])/g, "$1");
          } else if (matchValue[0] === '"') {
            valueBoundaries = '"';
            matchValue = matchValue.substr(1, matchValue.length - 2).replace(/\\([\\"])/g, "$1");
          }

          let matchValueType = matchValue.match(ATTR_VALUE_TYPE_REGEXP);
          if (matchValueType[1]) {
            //uu5JSON
            valueType = "uu5json";
            try {
              value = Uu5Json.parse(matchValue);
            } catch (e) {
              e.context.prop = name;
              throw e;
            }
          } else if (matchValueType[2]) {
            //uu5String
            valueType = "uu5string";
            value = Tools.parseUu5String(matchValue, buildItemFn, uu5DataMap, allowedTagsRegExp);
          } else if (matchValueType[3]) {
            //uu5Data
            valueType = "uu5data";
            uu5DataKey = matchValue.replace(UU5DATA_REGEXP, "");
            value = Uu5Data.parse(matchValue, uu5DataMap);
          } else {
            //as-is
            if (name === "href") {
              matchValue = matchValue.replace(JSCODE_REGEXP, "");
            }

            value = matchValue;
          }
        }

        attrs.push({ name, value, valueDelimiter, separator, valueBoundaries, valueType, uu5DataKey });
      }
      matchAttrs = attrsReg.exec(attrsString);
    }

    return attrs;
  },

  parseUu5StringPropsObject(attrsObject, buildItem, uu5DataMap, allowedTagsRegExp) {
    const attrs = [];
    for (const attr in attrsObject) {
      let separator = DEFAULT_SEPARATOR;
      let name = attr;
      let attrValue = attrsObject[attr];
      let valueDelimiter = DEFAULT_VALUE_DELIMITER;
      let valueBoundaries = DEFAULT_BOUNDARIES;
      let value = null;
      let uu5DataKey = undefined;
      let valueType = null; // hold info if data is parsed from uu5string, uu5data or uu5json

      if (name && !name.match(FORBIDDEN_ATTRS_REGEXP)) {
        if (typeof attrValue === "string") {
          let matchValueType = attrValue.match(ATTR_VALUE_TYPE_REGEXP);
          if (matchValueType[1]) {
            //uu5JSON
            valueType = "uu5json";
            try {
              value = Uu5Json.parse(attrValue);
            } catch (e) {
              e.context.prop = name;
              throw e;
            }
          } else if (matchValueType[2]) {
            //uu5String
            valueType = "uu5string";
            value = Tools.parseUu5String(attrValue, buildItem, uu5DataMap, allowedTagsRegExp);
          } else if (matchValueType[3]) {
            //uu5Data
            valueType = "uu5data";
            uu5DataKey = attrValue.replace(UU5DATA_REGEXP, "");
            value = Uu5Data.parse(attrValue, uu5DataMap);
          } else {
            //as-is
            if (name === "href") {
              value = attrValue.replace(JSCODE_REGEXP, "");
            } else {
              value = attrValue;
            }
          }
        } else if (attrValue && typeof attrValue === "object" && (attrValue.uu5Tag || attrValue.tag)) {
          value = [this.parseTagPropsObject(attrValue, buildItem, uu5DataMap, allowedTagsRegExp)];
        } else if (Array.isArray(attrValue)) {
          value = this.parseTagPropsArray(attrValue, buildItem, uu5DataMap, allowedTagsRegExp);
        } else {
          value = attrValue;
        }

        attrs.push({ name, value, valueDelimiter, separator, valueBoundaries, valueType, uu5DataKey });
      }
    }
    return attrs;
  },

  parseTagPropsArray(tagPropsArray, buildItem, uu5DataMap, allowedTagsRegExp) {
    if (!tagPropsArray || !Array.isArray(tagPropsArray) || !tagPropsArray.length) {
      return [];
    }

    return tagPropsArray.map((item) => this.parseTagPropsObject(item, buildItem, uu5DataMap, allowedTagsRegExp));
  },

  parseTagPropsObject(tagPropsObject, buildItem, uu5DataMap, allowedTagsRegExp) {
    if (!tagPropsObject) return null;
    if (!tagPropsObject || (!tagPropsObject.uu5Tag && !tagPropsObject.tag)) return tagPropsObject;
    let uu5Tag = tagPropsObject.uu5Tag || tagPropsObject.tag;
    if (uu5Tag && (uu5Tag.match(FORBIDDEN_TAGS_REGEXP) || uu5Tag.match(FORBIDDEN_TAGS_REGEXP2))) {
      let result = buildItem(null, null, { children: `<${uu5Tag} />`, uu5DataMap, allowedTagsRegExp });
      return result;
    }
    if (allowedTagsRegExp && !allowedTagsRegExp.test(uu5Tag)) {
      let result = buildItem("invalidTag", ` uu5Tag="${uu5Tag}" tag="${uu5Tag}"`, {
        children: `Error: Tag <${uu5Tag} /> is not allowed.`,
        uu5DataMap,
        isPairedTag: false,
        allowedTagsRegExp,
      });
      Tools.syncUu5TagAfterApiCall(result, "invalidTag");
      return result;
    }

    const children = this.parseTagPropsArray(tagPropsObject.children, buildItem, uu5DataMap, allowedTagsRegExp);

    return buildItem(uu5Tag, tagPropsObject.props, {
      children,
      uu5DataMap,
      allowedTagsRegExp,
      isPairedTag: !!(children && children.length),
    });
  },

  execMetaTag(tag, args) {
    //TODO implement each metaTag as separate function, call functions dynamically (witch safety keyword guard)
    let metaTag = tag.slice(10);
    let r = [];
    switch (metaTag) {
      case "now":
        r.push(SYMBOLS.now());
        break;
      case "codeHex32":
        r.push(SYMBOLS.idHex32());
        break;
      case "codeHex64":
        r.push(SYMBOLS.idHex64());
        break;
      default:
        r.push(null);
    }
    return r;
  },

  syncUu5TagAfterApiCall(tagObj, origUu5Tag) {
    // for backward compatibility - "older" API methods (filterFn, buildItemFn, ...) could change
    // "tag" instead of "uu5Tag" field => use the changed "tag" in such case, otherwise prefer "uu5Tag"
    if (!tagObj || typeof tagObj !== "object") return;
    if (!tagObj.uu5Tag || (tagObj.uu5Tag !== tagObj.tag && tagObj.uu5Tag === origUu5Tag && tagObj.tag)) {
      tagObj.uu5Tag = tagObj.tag;
    } else {
      tagObj.tag = tagObj.uu5Tag;
    }
  },

  isAllowedTagAndAttrCombination(tag, attrName, attrValue) {
    let tagNoVersion = typeof tag === "string" ? tag.replace(/_.*/, "") : tag;
    if (tagNoVersion === "UU5.Bricks.Iframe") {
      if (attrName === "srcDoc") return false;
      // NOTE Even "src" gets sometimes internally used as "srcDoc" => forbid if it contains "<".
      if (
        attrName === "src" &&
        attrValue &&
        (typeof attrValue !== "string" || !attrValue.match(/^https?:\/\/[^<]*$/))
      ) {
        return false;
      }
    } else if (tagNoVersion === "Plus4U5.Bricks.Iframe") {
      if (attrName === "src" && attrValue) {
        if (typeof attrValue !== "string" || attrValue.match(/</)) return false;
        if (typeof document !== "undefined" && typeof window !== "undefined") {
          let a = document.createElement("a");
          a.href = attrValue; // browser normalizes
          let normalizedUrl = a.href;
          let legacyEnv = (window.UU5 || {}).Environment || {};
          let trustedDomainRegExpStr =
            (window.uu5Environment || {}).uu5g05_trustedUriRegExp || legacyEnv.trustedDomainRegexp || "^";
          let trustedDomainRegExp = new RegExp(trustedDomainRegExpStr, "i");
          let curBase = window.location.protocol + "//" + window.location.host + "/";
          if (!normalizedUrl.match(trustedDomainRegExp) && !normalizedUrl.startsWith(curBase)) return false;
        }
      }
    }
    return true;
  },

  escapeEntities(text) {
    if (typeof text !== "string") return text;
    // TODO Maybe unescape emojis too.
    // NOTE TextEntityMap doesn't have unescaping mechanism and it contains
    // multiple mappings to the same character, e.g. &lt; and &#060; are both mapped to ">".
    return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  },

  getPropTemplateContext(prop) {
    return { location: "prop", propName: prop.name };
  },
  getContentTemplateContext() {
    return { location: "content" };
  },
};

module.exports = Tools;
