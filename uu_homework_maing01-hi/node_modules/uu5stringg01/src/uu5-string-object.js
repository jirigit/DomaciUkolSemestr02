/**
 * Copyright (C) 2019 Unicorn a.s.
 *
 * This program is free software; you can use it under the terms of the UAF Open License v01 or
 * any later version. The text of the license is available in the file LICENSE or at www.unicorn.com.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See LICENSE for more details.
 *
 * You may contact Unicorn a.s. at address: V Kapslovne 2767/2, Praha 3, Czech Republic or
 * at the email: info@unicorn.com.
 */

const TextEntityMap = require("./internal/text-entity-map.js");
const Uu5StringTools = require("./internal/tools.js");
const defaultFactory = require("./internal/factory.js");
const { FORBIDDEN_ATTRS_REGEXP } = require("./internal/constants.js");

const defaultPlainTextFilterFn = ({ uu5Tag, tag, props }) => {
  tag = uu5Tag = uu5Tag || tag;
  if (props) {
    let result = { tag, uu5Tag, props: {} };
    if (props.header) {
      result.props.header = props.header;
    }
    if (props.uu5string) {
      result.props.uu5string = props.uu5string;
    }
    if (props.content || props.children) {
      result.props.children = props.content || props.children;
    }
    if (props.footer) {
      result.props.footer = props.footer;
    }
    return result;
  }
};

class Uu5StringObject {
  /* constructor */
  constructor(
    uu5Tag,
    props,
    {
      children = [],
      isPairedTag = true,
      initFn = null,
      parent = null,
      uu5DataMap: initialUu5DataMap,
      allowedTagsRegExp,
    } = {}
  ) {
    this._factory = (arguments[2] && arguments[2]._factory) || defaultFactory;
    /* public methods */

    /*
    Returns Uu5StringObject as a string

    @param opts.templateDataMap - object with data for templates
    @param filterFn({uu5Tag, props}) - returns changed tag and props, if it returns false skip print of this component and its children - this method cannot change data of this component only change them for print
    @returns Uu5StringObject as a string
    */
    this.toString = ({ templateDataMap, filterFn } = {}) => {
      if (this.uu5Tag === "uu5string.pre") {
        return `<uu5string.pre>${this.children.join("")}</uu5string.pre>`;
      }
      return this._withPropsAfterFilterFn({ templateDataMap, filterFn }, "", (uu5Tag, uu5StringProps, children) => {
        let { propsString, tooLongPropItemMap } = uu5StringProps.toString({
          templateDataMap,
          filterFn,
          _extendedResult: true,
        });
        let resultParts = [`<${uu5Tag}${propsString}`];

        // render children - children from props content was rendered with props
        if (this._isPairTag(children) || tooLongPropItemMap) {
          resultParts.push(">");
          if (tooLongPropItemMap) {
            for (let propItem of Object.values(tooLongPropItemMap)) {
              let uu5stringObject = this._createPropChild(propItem, templateDataMap);
              resultParts.push(Uu5StringTools.contentToString([uu5stringObject], templateDataMap, filterFn));
            }
          }
          resultParts.push(`${Uu5StringTools.contentToString(children, templateDataMap, filterFn)}</${uu5Tag}>`);
        } else {
          resultParts.push("/>");
        }
        return resultParts.join("");
      });
    };

    /**
     * @return Object-representation of the uu5string. Passing .toString() and .toObject() values back into Uu5String
     *         constructor must result in the exact same structure.
     */
    this.toObject = ({ templateDataMap, filterFn } = {}) => {
      if (this.uu5Tag === "uu5string.pre") {
        return this.children.join("");
      }
      return this._withPropsAfterFilterFn(
        { templateDataMap, filterFn },
        undefined,
        (uu5Tag, uu5StringProps, children) => {
          let { props: transformedProps, tooLongPropItemMap } = uu5StringProps.toObject({
            templateDataMap,
            filterFn,
            preserveValueTypes: true,
            _extendedResult: true,
          });
          let childrenToTransform = children;
          // move props containing uu5string to children if they're too long
          if (tooLongPropItemMap) {
            childrenToTransform = Array.isArray(childrenToTransform)
              ? [...childrenToTransform]
              : childrenToTransform != null
              ? [childrenToTransform]
              : [];
            for (let propItem of Object.values(tooLongPropItemMap)) {
              // NOTE The result must contain <uu5string propName="">...</> as a child with the value in pre-parsed form
              // (if it was simple string, we would have exactly the same problem as if it was in a prop - see UU5STRING_LENGTH_LIMIT).
              let uu5stringObject = this._createPropChild(propItem, templateDataMap);
              delete transformedProps[propItem.name];
              childrenToTransform.unshift(uu5stringObject);
            }
          }
          let transformedChildren = Uu5StringTools.contentToObject(childrenToTransform, templateDataMap, filterFn);

          let result = { uu5Tag, props: transformedProps };
          if (
            transformedChildren !== undefined &&
            (!Array.isArray(transformedChildren) || transformedChildren.length > 0)
          ) {
            result.children = transformedChildren;
          }
          return result;
        }
      );
    };

    /*
    Returns Uu5StringObject as a plain text

    @param opts.templateDataMap - object with data for templates
    @param filterFn({uu5Tag, props}) - returns changed tag and props, if it returns false skip print of this component and its children - this method cannot change data of this component only change them for print
    @returns Uu5StringObject as a string
    */
    this.toPlainText = ({ templateDataMap, uu5DataMap, filterFn } = {}) => {
      if (this.uu5Tag === "uu5string.pre") {
        return `${this.children.join("")}`;
      }
      let children = this.children;

      // there is no need to special handling of props parsed from children

      let propsArray = [...this.props.props];
      let originalProps = this.props.props;

      // add children into props
      if (children) {
        propsArray.push({
          name: "children",
          value: children.slice(),
          valueType: "uu5string",
        });
      }
      let result;

      // update filter function - use default if is not set other wise add default filter function as an another parameter into filterFn
      let modifiedFilterFn = defaultPlainTextFilterFn;
      if (filterFn) {
        modifiedFilterFn = (...params) => filterFn(...params, defaultPlainTextFilterFn);
      }

      // handle props with children
      this.props.props = propsArray;

      let uu5Tag = this.uu5Tag;
      let obj = { uu5Tag, tag: uu5Tag, props: this.props.toObject({ uu5DataMap }) };
      // filter result by obj
      let _result = this._filterProps(obj, modifiedFilterFn, true);
      // check if filter returns false => do not render component
      if (_result === false) {
        return "";
      }

      this.props.props = _result.resultProps;
      // print filtered props
      result = `${this.props.toPlainText({ templateDataMap, uu5DataMap, filterFn })}`;
      // return original props
      this.props.props = originalProps;

      return result;
    };

    /*
    Returns Uu5StringObject as a hierarchy of react component

    @param opts.templateDataMap - object with data for templates
    @param filterFn({uu5Tag, props}) - returns changed tag and props, if it returns false skip print of this component and its children - this method cannot change data of this component only change them for print
    @returns Uu5StringObject as a React component
    */
    this.toChildren = ({ templateDataMap, uu5DataMap = initialUu5DataMap, filterFn, buildChildFn, index } = {}) => {
      if (this.uu5Tag === "uu5string.pre") {
        return this.children.map((it) => {
          if (typeof it === "string") return TextEntityMap.replaceHtmlEntity(it);
          return it;
        });
      }
      let result;
      let children = this.children;
      let uu5Tag = this.uu5Tag;
      if (filterFn) {
        // create shallow copy of component
        let obj = { uu5Tag, tag: uu5Tag, props: this.props.toObject({ uu5DataMap }) };
        obj.props.children = this.children.slice();
        // filter result by obj
        let _result = this._filterProps(obj, filterFn);
        // check if filter returns false => do not render component
        if (_result === false) {
          return null;
        }
        let { resultTag, resultProps } = _result;
        // remove children from props
        resultProps = resultProps.filter((item) => {
          if (item.name === "children") {
            children = item.value;
            return false;
          }
          return true;
        });
        let propsArray = this.props.props;
        this.props.props = resultProps;
        // process filtered props
        result = {
          uu5Tag: resultTag,
          tag: resultTag,
          props: this.props.toChildren({ templateDataMap, uu5DataMap, filterFn, buildChildFn }),
        };
        // return original props
        this.props.props = propsArray;
      } else {
        result = {
          uu5Tag,
          tag: uu5Tag,
          props: this.props.toChildren({ templateDataMap, uu5DataMap, undefined, buildChildFn }),
        };
      }

      let usedChildren = Uu5StringTools.contentToChildren(
        children,
        templateDataMap,
        uu5DataMap,
        filterFn,
        buildChildFn,
        allowedTagsRegExp
      );
      let context = { index };
      let returnValue = Uu5StringTools.buildChild(buildChildFn, result.uu5Tag, result.props, usedChildren, context);
      return returnValue;
    };

    /*
    Deep clone of this component.

    @returns new instance of Uu5StringObject
    */
    this.clone = ({ initFn = this.initFn } = {}) => {
      // filter props by filter function
      let uu5Tag = this.uu5Tag;
      let result = { uu5Tag, tag: uu5Tag, props: this.props.clone({ initFn }) };
      // clone children at first
      result.children = this.children.map((item) => (typeof item === "string" ? item : item.clone({ initFn })));
      // create new object - props are already cloned so do not send them into constructor
      let newUu5StringObject = this._factory.createObject(result.uu5Tag, null, {
        children: result.children,
        isPairedTag: this._isPairTag(),
        initFn,
        allowedTagsRegExp,
      });
      newUu5StringObject.props = result.props;
      return newUu5StringObject;
    };

    /*
    Returns index of this component in the parent. If component does not have parent returns -1.

    @returns number
    */
    this.getIndex = () => {
      return this.parent ? this.parent.children.indexOf(this) : -1;
    };

    /* private methods */
    this._initContent = () => {
      // set parent to children
      if (this.children && Array.isArray(this.children)) {
        this.children.forEach((item) => {
          if (item && typeof item === "object") item.parent = this;
        });
      }
      if (this.props && this.props.props) {
        let content = this.props.props.find((item) => item.name === "content");
        if (content && Array.isArray(content.value)) {
          content.value.forEach((item) => {
            if (item && typeof item === "object") item.parent = this;
          });
        }
      }
    };

    this._filterProps = (propsObj, filterFn, preserveObjectOrder) => {
      let uu5TagOrig = propsObj ? propsObj.uu5Tag : undefined;
      let tagOrig = propsObj ? propsObj.tag : undefined;
      let filterObj = filterFn(propsObj);
      if (filterObj === false) return false;
      let uu5Tag = uu5TagOrig || tagOrig;
      if (filterObj) {
        propsObj = filterObj;
        Uu5StringTools.syncUu5TagAfterApiCall(propsObj, uu5TagOrig);
        uu5Tag = propsObj.uu5Tag;
      }
      // some props values may be false or undefined - for filtering we need to have some value evaluated as a true
      let filteredProps = {};
      let counter = 1;
      for (let propName in propsObj.props) {
        filteredProps[propName] = counter++;
      }
      // filter result by obj
      let propsArray = this.props.props.filter((prop) => filteredProps[prop.name]);

      if (preserveObjectOrder) {
        propsArray.sort((prop1, prop2) => filteredProps[prop1.name] - filteredProps[prop2.name]);
      }
      // update values
      for (let propName in propsObj.props) {
        let prop = propsArray.find((item) => item.name === propName);
        if (prop) {
          // update value
          prop.value = propsObj.props[propName];
        } else {
          // add new props
          propsArray.push({
            name: propName,
            value: propsObj.props[propName],
          });
        }
      }

      return { resultTag: uu5Tag, resultProps: propsArray };
    };

    this._withPropsAfterFilterFn = ({ templateDataMap, filterFn }, fallbackValue, callbackFn) => {
      let children = [...this.children];
      let propsChildren = [];
      let filteredProps = [];

      for (let pi = 0; pi < this.props.props.length; pi++) {
        let prop = this.props.props[pi];
        if (prop.childrenProperty) {
          propsChildren.push(prop);
        } else {
          filteredProps.push(prop);
        }
      }

      // sort props children by index from lowest
      propsChildren.sort((child1, child2) => child2.index - child1.index);

      // re-create children in the form of <uu5json propName="foo">...</uu5json>, ...
      for (let pi = 0; pi < propsChildren.length; pi++) {
        let prop = propsChildren[pi];
        let uu5stringObject = this._factory.createObject(undefined, undefined, { allowedTagsRegExp });
        uu5stringObject.uu5Tag = prop.valueType === "string" ? "uu5string" : prop.valueType;
        let context = Uu5StringTools.getPropTemplateContext(prop);
        uu5stringObject.children =
          prop.valueType === "uu5json"
            ? [
                Uu5StringTools.printTemplateToString(
                  JSON.stringify(prop.value, undefined, 2),
                  templateDataMap,
                  context
                ).replace(/<\/uu5json>/g, "\\u003c/uu5json>"), // json containing "</uu5json>" should not break later parsing
              ]
            : Uu5StringTools.contentToString(prop.value, templateDataMap, filterFn);
        uu5stringObject.props.props.push({ name: "propName", value: prop.name, type: "string" });

        // add item back into its original place - if index is larger then count of children, then we push it at the end of array
        if (prop.index < children.length) {
          //insert back formating spaces
          if (prop.spacesBefore) {
            children.splice(prop.index, 0, prop.spacesBefore, uu5stringObject);
          } else {
            children.splice(prop.index, 0, uu5stringObject);
          }
        } else {
          //insert back formating spaces
          if (prop.spacesBefore) {
            children.push(prop.spacesBefore);
          }
          children.push(uu5stringObject);
        }
      }

      // use filteredProps for rest of the algorithm and then return back original props
      let originalProps = this.props.props;
      this.props.props = filteredProps;

      let uu5Tag = this.uu5Tag;
      let result;
      if (filterFn) {
        let obj = { uu5Tag, tag: uu5Tag, props: this.props.toObject() };
        obj.props.children = children.slice();
        // filter result by obj
        // NOTE Props realized as <uu5json propName="...">...</uu5json> are present in "children" when using filterFn,
        // i.e. they're not in "props" directly ({ uu5Tag, props, children }).
        let _result = this._filterProps(obj, filterFn);
        // check if filter returns false => do not render component
        if (_result === false) {
          result = fallbackValue;
        } else {
          let { resultTag, resultProps } = _result;
          uu5Tag = resultTag;
          // remove children from props
          resultProps = resultProps.filter((item) => {
            if (item.name === "children") {
              children = item.value;
              return false;
            }
            return true;
          });
          this.props.props = resultProps;
          // print filtered props
          result = callbackFn(uu5Tag, this.props, children);
        }
      } else {
        result = callbackFn(uu5Tag, this.props, children);
      }

      // return original props
      this.props.props = originalProps;

      return result;
    };

    this._createPropChild = (propItem, templateDataMap) => {
      let context = Uu5StringTools.getPropTemplateContext(propItem);
      let uu5stringObject = this._factory.createObject();
      uu5stringObject.uu5Tag = propItem.valueType;
      uu5stringObject.children =
        propItem.valueType === "uu5string"
          ? propItem.value
          : [
              Uu5StringTools.printTemplateToString(
                JSON.stringify(propItem.value, undefined, 2),
                templateDataMap,
                context
              ).replace(/<\/uu5json>/g, "\\u003c/uu5json>"), // json containing "</uu5json>" should not break later parsing
            ];
      uu5stringObject.props.props.push({ name: "propName", value: propItem.name, type: "string" });
      return uu5stringObject;
    };

    this._isPairTag = (children = this.children) => {
      let isPairTag = children.length > 0 || this._pairTag;
      this._pairTag = isPairTag;
      return this._pairTag;
    };

    // constructor logic
    this.uu5Tag = uu5Tag;
    Object.defineProperty(this, "tag", {
      get: () => this.uu5Tag,
      set: (v) => {
        this.uu5Tag = v;
      },
      enumerable: true,
    });
    this.props = this._factory.createProps(props, {
      buildItemFn: (uu5Tag, props, opts) =>
        Uu5StringObject.create(uu5Tag, props, {
          ...opts,
          initFn,
          uu5DataMap: initialUu5DataMap,
          allowedTagsRegExp,
          _factory: this._factory,
        }),
      uu5DataMap: initialUu5DataMap,
      allowedTagsRegExp,
    });
    this.parent = parent;
    this.children = [];

    if (!isPairedTag && children.length === 0) {
      let childPropIndex = this.props.props.findIndex((it) => it.name === "children");
      if (childPropIndex !== -1) {
        let value = this.props.props[childPropIndex].value;
        this.children =
          value == null
            ? []
            : Array.isArray(value)
            ? value
            : typeof value === "string"
            ? [Uu5StringTools.escapeEntities(value)] // <b children="<hello>" />    =>   <b>&lt;hello&gt;</b>
            : [value];
        this.props.props.splice(childPropIndex, 1);
      }
    }
    if (typeof children === "string") {
      this.children.push(children);
    } else {
      // filter props set inside children from children and add them into children
      let childProps = {};
      children.forEach((child, index) => {
        let childTag = child.uu5Tag || child.tag;
        if (childTag === "uu5string" || childTag === "uu5json") {
          // find property propName
          let propName = child.props.props.find((prop) => prop.name === "propName");
          if (propName) {
            childProps[propName.value] = { child, index: index };
            if (index > 0 && typeof children[index - 1] === "string" && children[index - 1].match(/^\s+$/)) {
              // remove spaces from array oof children
              childProps[propName.value].spacesBefore = this.children.pop();
              // lower index of component
              childProps[propName.value].index--;
            }
            if (childTag === "uu5json") {
              child.children = JSON.parse(child.children);
            } else if (child.children.length === 1 && typeof child.children[0] === "string") {
              child.children = child.children[0];
              child.uu5Tag = child.tag = "string";
            }
          } else {
            this.children.push(child);
          }
        } else {
          this.children.push(child);
        }
      });

      // iterate over all props and update already existing props by the ones from children
      for (let pi = 0; pi < this.props.props.length; pi++) {
        let prop = this.props.props[pi];
        if (childProps[prop.name] !== undefined) {
          prop.value = childProps[prop.name].child.children;
          prop.type = childProps[prop.name].child.uu5Tag || childProps[prop.name].child.tag;
          prop.childrenProperty = true;
          prop.index = childProps[prop.name].index;
          prop.spacesBefore = childProps[prop.name].spacesBefore;
          delete childProps[prop.name];
        }
      }

      // add new props for rest of props children
      for (let propName in childProps) {
        this.props.props.push({
          name: propName,
          value: childProps[propName].child.children,
          valueType: childProps[propName].child.uu5Tag || childProps[propName].child.tag,
          childrenProperty: true,
          index: childProps[propName].index,
          spacesBefore: childProps[propName].spacesBefore,
        });
      }
    }

    // remove all forbidden props
    for (let pi = this.props.props.length - 1; pi >= 0; pi--) {
      let prop = this.props.props[pi];
      if (
        prop.name.match(FORBIDDEN_ATTRS_REGEXP) ||
        !Uu5StringTools.isAllowedTagAndAttrCombination(this.uu5Tag, prop.name, prop.value)
      ) {
        console.warn(
          `Provided value is not allowed in uu5string for '${this.uu5Tag}' prop '${prop.name}': ${prop.value}`
        );
        this.props.props.splice(pi, 1);
      }
    }

    // this.children = (typeof children === "string" ? [children] : children) || [];
    this.initFn = initFn;
    this._pairTag = isPairedTag;
    this._initContent();

    // use filter function to let user update component tag and props
    if (typeof initFn === "function") {
      initFn(this);
    }
  }

  /* static methods */
  static create(uu5Tag, props, { children, isPairedTag, initFn, parent, uu5DataMap, allowedTagsRegExp } = {}) {
    if (!uu5Tag) return children;
    let _factory = (arguments[2] && arguments[2]._factory) || defaultFactory;
    return _factory.createObject(uu5Tag, props, {
      children,
      isPairedTag,
      initFn,
      parent,
      uu5DataMap,
      allowedTagsRegExp,
    });
  }
}

module.exports = Uu5StringObject;
