'use strict';
const jsonpath = require("jsonpath");
const AuditLog = require("../auditlog.js");
const { LoggerFactory } = require("uu_appg01_core-logging");
const { ErrorConverter } = require("uu_appg01_core-appserver");
const {Config} = require("uu_appg01_core-utils");


const logger = LoggerFactory.get("AuditLogMiddleware");
const schemaVersion = AuditLog.getSchemaVersion();
const asid = Config.get("asid");

const AUDITLOG_START_MIDDLEWARE_CODE = "uuAuditLog_start_middleware";

const SCHEMA_0_9_0 = "0.9.0";
const SCHEMA_1_0_0 = "1.0.0";


class RequestAuditLogAbl{

  constructor() {}

  async logRequest(code, req, res, asyncWrite = true) {
    let ucProperties = res.locals.ucProperties;
    if (!ucProperties || Object.keys(ucProperties).length === 0) {
      return false;
    } // TODO check whether it works like this on static resource calls

    let severity, message, eventCode, ucState, errorDtoOut, errorCode, errorMessage;
    let { uri, session, authorizationResult, dispatchedError, auditLogStartTime } = res.locals;

    let headers = req.headers;
    let statusCode = res.statusCode;
    let dtoOut = res.locals.response && res.locals.response.body;
    const clientIdentity = session.getClientIdentity();

    const logData = {
      uri: uri.toString().replace(/\?.+/, ""),
      gateway: uri.getGateway(),
      tokenId: session.getId(),
      dtoInAuditMap: this._parseDtoAuditMap(ucProperties.getAttribute("dtoInAuditMap"), res.locals.parsedParameters) // res.locals.parsedParameters is dtoIn
    }

    logData.forwardedFor = headers["x-forwarded-for"];
    if (headers["x-base-uri-alias"]) {
      logData.baseUriAlias = headers["x-base-uri-alias"];
    }
    if (dispatchedError) {
      let result = ErrorConverter.buildErrorDtoOut(dispatchedError, true);
      errorDtoOut = result.dtoOut;
      errorCode = result.errorCode;
      errorMessage = result.errorMessage;
      logData.errorCode = errorCode;
    }
    if (typeof statusCode === "string" || statusCode instanceof String) {
      statusCode = Number(statusCode);
    }
    if (statusCode >= 500) {
      severity = "CRITICAL";
      message = errorMessage || "Use Case failed.";
      ucState = "completedWithError";
    } else if (statusCode >= 400) {
      severity = "ERROR";
      message = errorMessage || "Use Case failed.";
      ucState = "completedWithError";
    } else {
      severity = "INFO";
      message = code === AUDITLOG_START_MIDDLEWARE_CODE ? "Use case execution just started" :  "Use case executed.";
      ucState = "completed";
    }

    switch(schemaVersion){
      case SCHEMA_0_9_0:

        logData.useCaseType = ucProperties.getType(),
        logData.clientAppId = (clientIdentity && clientIdentity.getAwid()) || session.getAttribute("client_app_id");
        logData.clientAppName = (clientIdentity && clientIdentity.getProduct()) || session.getAttribute("client_app_name");
        logData.profileList = authorizationResult && authorizationResult.getAuthorizedProfiles();
        if(code === AUDITLOG_START_MIDDLEWARE_CODE){
          eventCode = "UC_EXECUTION_START";
        }else{
          logData.ucStatus = statusCode;
          logData.duration = Date.now() - auditLogStartTime;
          logData.dtoOutAuditMap = this._parseDtoAuditMap(ucProperties.getAttribute("dtoOutAuditMap"), dtoOut);
          eventCode = "UC_EXECUTION";
        }
        break;

      default:
        logData.httpMethod = req.method.toUpperCase();
        logData.useCaseType = ucProperties.getType() === "UVE" ? "uuUve" : "uuCmd";
        logData.clientUuIdentity = clientIdentity && clientIdentity.getUuIdentity();
        logData.clientUuIdentityType = clientIdentity && clientIdentity.getType();
        logData.clientUuAppKey = session.getAttribute("client_uuappkey");
        logData.authorizedProfileList = authorizationResult && authorizationResult.getAuthorizedProfiles();
  
        if(code === AUDITLOG_START_MIDDLEWARE_CODE){
          eventCode = "uuApp/useCaseExecutionStart";
        }else{
          logData.httpStatus = statusCode;
          logData.useCaseState = ucState;
          logData.duration = Date.now() - auditLogStartTime;
          logData.dtoOutAuditMap = this._parseDtoAuditMap(ucProperties.getAttribute("dtoOutAuditMap"), dtoOut);
          eventCode = "uuApp/useCaseExecution";
        }
  
        if (clientIdentity) {
          if (clientIdentity.getAuthenticationLevelOfAssurance() === "none") {
            logData.callOrigin = "unknownApp";
          } else if (clientIdentity.getAwid() === uri.getAwid()) {
            logData.callOrigin = "sameAwid";
          } else if (clientIdentity.getAsid() === asid) {
            logData.callOrigin = "sameAsid";
          } else if (uri.getProduct().startsWith(clientIdentity.getProduct)) {
            logData.callOrigin = "sameApp";
          } else {
            logData.callOrigin = "differentApp";
          }
        } else {
          logData.callOrigin = "unknownApp";
        }
        if (dispatchedError) {
          logData.errorId = dispatchedError.id;
          logData.uuAppErrorMap = JSON.stringify(errorDtoOut.uuAppErrorMap);
        }
        break;
    }

    if(asyncWrite){
      return await AuditLog.log(severity, eventCode, message, logData);
    }else{
      AuditLog.log(severity, eventCode, message, logData);
      return !!dispatchedError;
    }
  }


  _parseDtoAuditMap = (dtoAuditMap, dto) => {
      if (!dtoAuditMap || !dto || !(typeof dto === "object")) {
        return null;
      }
      let result = {};
      for (let [key, path] of Object.entries(dtoAuditMap)) {
        try {
          let tmp = jsonpath.query(dto, path);
          if (tmp.length === 0) {
            // the expected value is not in dtoIn
            continue;
          }
          result[key] = tmp[0];
        } catch (e) {
          logger.warn(`The expected JSONPath string ${path} is invalid`, e);
        }
      }
      return result;
  }
}




module.exports = new RequestAuditLogAbl();