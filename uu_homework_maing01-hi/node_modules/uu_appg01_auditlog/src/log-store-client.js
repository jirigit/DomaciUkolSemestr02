"use strict";

const { UseCaseContext } = require("uu_appg01_core-appserver");
const { Uri, UriBuilder } = require("uu_appg01_core-uri");
const { AuthenticationService } = require("uu_appg01_core-authentication");
const { Config } = require("uu_appg01_core-utils");
const { AppClient } = require("uu_appg01_core-appclient");
const { LoggerFactory } = require("uu_appg01_core-logging");

const Errors = require("./api/errors/sys-auditlog-error");

const IMPORT_UC = "logRecord/import";
const LOGGER_NAME = "auditLog";
const SCHEMA_0_9_0 = "0.9.0";

class LogStoreClient {
  constructor() {
    this.logger = LoggerFactory.get("uuapp.auditlog.logStoreClient");
    this.asid = Config.get("asid");
    this.uuEe = Config.get("uu_app_auditlog_app_logstore_uuee");
  }

  async importLogRecords(logStoreUri, logRecordList, preserveActor = true) {
    const callUri = UriBuilder.parse(logStoreUri).setUseCase(IMPORT_UC).toUri();

    // hds 1
    let callOptions;
    let session;

    if (this.uuEe) {
      try {
        session = await AuthenticationService.authenticate(this.uuEe, callUri); // a1
      } catch (e) {
        throw new Errors.AppLogStoreImport.AuthenticationFailed({}, { uuIdentity: this.uuEe }, e);
      }
    } else {
      if (!preserveActor) {
        // do not preserve the actor only if explicitly stated
        session = await AuthenticationService.authenticate({systemIdentity: this.asid}, callUri, {preserveActor: false});
      } else {
        // otherwise do not pass preserveActor option and use the value from the configuration
        session = await AuthenticationService.authenticate({systemIdentity: this.asid}, callUri);
      }
    }

    let headers = {};
    headers["Authorization"] = await session.getCallToken(null, { useTokenExchange: false });
    callOptions = { headers };

    // hds 2
    const uri = UseCaseContext.getUri();
    const transformedLogRecordList = this._prepareLogRecordList(logRecordList, uri);

    // hds 3
    const logSourceUri = UriBuilder.parse(uri).setTid(null).setAwid(this.asid).toUri();

    const dtoIn = {
      logSourceUri: logSourceUri.getBaseUri().toString(),
      logRecordList: transformedLogRecordList,
    };

    // hds 4
    try {
      return await AppClient.post(callUri, dtoIn, callOptions);
    } catch (e) {
      // a2
      if (e.code === "uu-applogstore-main/logRecord/import/importsPerMinuteLimitExceeded") {
        // TODO postpone the import based on error parameters
      }
      throw new Errors.AppLogStoreImport.ImportFailed({}, { appLogStoreUri: logStoreUri }, e);
    }
  }

  _prepareLogRecordList(logRecords, logSourceUri) {
    let logRecordList = logRecords.map((originalRecord) => {
      let transformedRecord = { ...originalRecord };
      transformedRecord.logId = originalRecord.id;
      if (!transformedRecord.logRecordSchemaVersion || transformedRecord.logRecordSchemaVersion === SCHEMA_0_9_0) {
        transformedRecord.logger = LOGGER_NAME;
        transformedRecord.logAsid = this.asid;
        transformedRecord.logAwid = originalRecord.awid;
        transformedRecord.subApp = Uri.parse(logSourceUri).getProduct();
        transformedRecord.logTypeCode = originalRecord.eventTypeCode;
        transformedRecord.logData = originalRecord.parameters;
        delete transformedRecord.eventTypeCode;
        delete transformedRecord.parameters;
      }
      delete transformedRecord.id;
      delete transformedRecord.awid;
      delete transformedRecord.sys;
      return transformedRecord;
    });
    return logRecordList;
  }
}

module.exports = new LogStoreClient();
