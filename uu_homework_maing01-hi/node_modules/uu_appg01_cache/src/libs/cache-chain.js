"use strict";

/**
 * Represents a cache with its handlers.
 */
class CacheChain {
  /**
   * @param {string} code
   * @param {{}} cache
   * @param {{}[]} handlers
   * @param {Record<string, unknown>} config
   */
  constructor(code, cache, handlers, config) {
    this._cache = new cache(code, config);
    this._chain = this._chainProxy();
    this._handlers = handlers;
    this._handlers = this._initHandlers(handlers);
    return this._chain;
  }

  async disconnect() {
    return Promise.all(
      [this._cache, ...this._handlers].filter((h) => Reflect.has(h, "disconnect")).map((h) => h.disconnect())
    );
  }

  _initHandlers(handlerClasses) {
    return handlerClasses.map(
      (h, idx) => new h(this._cache.code, this._cache.config, this._chain, this._nextProxy(idx))
    );
  }

  static _bindIfFn(obj, fn) {
    return fn instanceof Function ? fn.bind(obj) : fn;
  }

  _getProperty(key, fromIdx = 0) {
    for (let i = fromIdx; i < this._handlers.length; i++) {
      const handler = this._handlers[i];
      if (Reflect.has(handler, key)) {
        return CacheChain._bindIfFn(handler, handler[key]);
      }
    }
    if (Reflect.has(this._cache, key)) {
      return CacheChain._bindIfFn(this._cache, this._cache[key]);
    }
    return undefined;
  }

  /**
   * Proxies property set to all handlers and cache.
   * @param {string} key - key of property to set
   * @param {any} value - value of property to set
   * @param {number} fromIdx - index of handler to start from
   * @returns {boolean} true if property was set, false if it was set on CacheChain (not present in any handler)
   */
  _setProperty(key, value, fromIdx = 0) {
    for (let i = fromIdx; i < this._handlers.length; i++) {
      const handler = this._handlers[i];
      if (Reflect.has(handler, key)) {
        handler[key] = value;
        return true;
      }
    }
    if (Reflect.has(this._cache, key)) {
      this._cache[key] = value;
      return true;
    }
    this[key] = value;
    return false;
  }

  /**
   * Returns a proxy to the cache chain.
   * @returns {Proxy} proxy to chain
   */
  _chainProxy() {
    return new Proxy(this, {
      get: (target, prop) => {
        if (!Reflect.has(target, prop)) {
          return target._getProperty(prop);
        }
        return target[prop];
      },
      set: (target, prop, value) => {
        if (!Reflect.has(target, prop)) {
          return target._setProperty(prop, value);
        }
        target[prop] = value;
        return true;
      },
      has: (target, prop) =>
        Reflect.has(target, prop) ||
        target._handlers.some((h) => Reflect.has(h, prop)) ||
        Reflect.has(target._cache, prop),
    });
  }

  _nextProxy(idx) {
    let proxiedEntity;
    if (idx < this._handlers.length - 1) {
      proxiedEntity = this._handlers[idx + 1];
    } else {
      proxiedEntity = this._cache;
    }

    return new Proxy(proxiedEntity, {
      get: (_target, prop) => this._getProperty(prop, idx + 1),
      set: (_target, prop, value) => this._setProperty(prop, value, idx + 1),
      has: (_target, prop) =>
        this._handlers.filter((_h, i) => i >= idx).some((h) => Reflect.has(h, prop)) || Reflect.has(this._cache, prop),
    });
  }

  get code() {
    return this._cache.code;
  }

  get opts() {
    return this._cache.opts;
  }
}

module.exports = CacheChain;
