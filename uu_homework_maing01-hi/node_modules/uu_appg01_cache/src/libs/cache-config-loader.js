// @ts-check
"use strict";

const Fs = require("fs");
const Path = require("path");
const merge = require("deepmerge");
// overwrites arrays instead of catenating them
/**
 * @template T
 * @param {(T|Partial<T>)[]} objects
 * @returns {T}
 */
const mergeWithOverwrite = (objects) => merge.all(objects, { arrayMerge: (_destination, source) => source });

const { LoggerFactory } = require("uu_appg01_core-logging");
const { BaseError, Finder, Config, Json } = require("uu_appg01_core-utils");
const { Validator } = require("uu_appg01_core-validation");
const logger = LoggerFactory.get("UuApp.Cache.ConfigLoader", true);

const CACHE_CONFIG_GLOB_PATTERN = "{app,src}/config/cache.json";
const CACHE_CONFIG_PATH = ["app", "config", "cache.json"];
const CACHE_CONFIG_PREFIX = "uu_app_cache";

const CONFIG_VALIDATION_SCHEMA = `
const partialCacheManagerDefinitionType = shape({
  realization: string(),
  handlers: array(string()),
  config: shape({}, true)
});

const cacheManagerDefinitionType = shape({
  realization: string().isRequired(),
  handlers: array(string()).isRequired(),
  config: shape({}, true)
});

const partialCacheDefinitionType = shape({
  cacheManager: string(),
  policy: string(),
  disabled: boolean(),
  handlers: array(string()),
  config: shape({}, true),
});

const cacheDefinitionType = shape({
  cacheManager: string().isRequired(),
  policy: string().isRequired(),
  disabled: boolean().isRequired(),
  handlers: array(string()),
  config: shape({}, true).isRequired(),
});

const partialCacheConfigMapType = shape({
  cacheManagers: map(string(), partialCacheManagerDefinitionType),
  caches: map(string(), partialCacheDefinitionType),
});

const cacheConfigMapType = shape({
  cacheManagers: map(string(), cacheManagerDefinitionType),
  caches: map(string(), cacheDefinitionType),
});
`;

const HARDWIRED_HANDLERS_PRE = ["uu_app_cache/autoloading", "uu_app_cache/monitored"];
const HARDWIRED_HANDLERS_POST = [];

const CACHE_MANAGER_DEFINITION_DEFAULTS = {
  realization: "uu_app_cache/basic-memory-cache",
  handlers: [],
  config: {},
};

const CACHE_DEFINITION_DEFAULTS = {
  cacheManager: "uu_app_cache/basic-memory-cache-manager",
  disabled: false,
  policy: "lru",
  config: {
    maxSoi: 1000,
    maxItemCount: 100,
  },
};

/**
 * @type {Record<string, keyType>}
 */
const CACHE_MANAGER_DEFINITION_CONFIG_KEYS = {
  realization: "string",
  handlers: "[string]",
};

/**
 * @type {Record<string, keyType>}
 */
const CACHE_DEFINITION_CONFIG_KEYS = {
  cacheManager: "string",
  policy: "string",
  disabled: "boolean",
  handlers: "[string]",
};

/**
 * @typedef {{ disableConfigOverrides?: boolean, disableHardwiredHandlers?: boolean }} KnownCacheDefinitionConfig
 * @typedef {Record<string, unknown> & KnownCacheDefinitionConfig} CacheDefinitionConfig
 * @typedef {{ realization: string, handlers: string[], config: CacheDefinitionConfig }} CacheManagerDefinition
 * @typedef {{ cacheManager: string, policy: string, disabled: boolean, handlers: string[], config: CacheDefinitionConfig }} CacheDefinition
 * @typedef {CacheManagerDefinition & CacheDefinition} CacheConfig
 * @typedef {{ cacheManagers: {[key: string]: CacheManagerDefinition}, caches: {[key: string]: CacheDefinition }}} CacheConfigMap
 * @typedef {{ cacheManagers?: {[key: string]: Partial<CacheManagerDefinition>}, caches?: {[key: string]: Partial<CacheDefinition> }}} PartialCacheConfigMap
 * @typedef {"string" | "number" | "boolean" | "[string]" | "[number]" | "[boolean]"} keyType
 */

/**
 * Loads cache configuration from files.
 * Cache configurations are mainly stored as JSON files in the following directory structure:
 * ```
 *  app/config/cache-config.json
 *  src/config/cache-config.json
 * ```
 * First the config files in the node_modules libraries are loaded, then the config file in the app/config directory.
 *
 * Lastly, the config can be overridden using the {@link Config uu_appg01core-utils.Config} global configuration provider. The corresponding keys are: `uu_app_cache.${cacheName}.${keyPath}`.
 * For example, the following config overrides the cache `test`'s `maxNoi` value:
 * ```
 *   Config.set("uu_app_cache.caches.test.config.maxNoi", 10);
 * ```
 * This approach is used to allow the application to override the cache configuration in different contexts. (e.g. dev, test, prod)
 *
 * @remarks
 * CacheConfigLoader loads the config from the global configuration only for these config keys: disabled, realization, policy and handlers.
 * (Keys: `uu_app_cache.caches.${cacheName}.disabled`, `uu_app_cache.caches.${cacheName}.realization`, `uu_app_cache.caches.${cacheName}.policy`, `uu_app_cache.caches.${cacheName}.handlers`)
 *
 * The rest of the config should be loaded by the cache realization and handlers directly.
 *
 * Global config has the highest priority, then the app config, then any lib configs.
 * This may be overridden by setting the `disableConfigOverrides` option in cache or cacheManager to `true`, which disables the global config overrides.
 *
 * CacheConfigLoader also adds the following hard-wired handlers:
 * - `uu_app_cache/autoloading`
 * - `uu_app_cache/monitoring`
 * These handlers may be disabled by setting the `disableHardwiredHandlers` option in cache or cacheManager config to `true`.
 */
class CacheConfigLoader {
  constructor() {
    /**
     * @type {import("uu_appg01_core-validation/src/Validator")}
     */
    this._validator = new Validator(CONFIG_VALIDATION_SCHEMA);
    /**
     * @type {CacheConfigMap}
     */
    this._config;
    this.loadConfig();
  }

  /**
   * Validates final config
   * @param {*} cacheConfigMap
   * @returns {asserts cacheConfigMap is CacheConfigMap}
   */
  _validateConfig(cacheConfigMap) {
    // check typing
    const validationResult = this._validator.validate("cacheConfigMapType", cacheConfigMap);
    if (!validationResult.isValid()) {
      throw new BaseError(
        `Invalid parsed cache config:\n${Json.stringify(validationResult.getValidationErrorMap(), true)}`
      );
    }
    // check if all cache managers are defined
    /** @type {Set<string>} */
    const usedCacheManagers = Object.values(cacheConfigMap.caches).reduce(
      (acc, { cacheManager }) => acc.add(cacheManager),
      new Set()
    );
    const definedCacheManagers = Object.keys(cacheConfigMap.cacheManagers);
    const missingCacheManagers = [...usedCacheManagers.values()].filter(
      (cacheManager) => !definedCacheManagers.includes(cacheManager)
    );
    if (missingCacheManagers.length > 0) {
      throw new BaseError(`Referenced cache managers are not defined:\n${Json.stringify(missingCacheManagers, true)}`);
    }
  }

  /**
   * Loads cache configs for all caches in app and libs.
   * @returns {void}
   */
  loadConfig() {
    const root = Config.get("server_root") || process.cwd();
    const appCacheConfigPath =
      Finder.findConfigInProject(root, CACHE_CONFIG_GLOB_PATTERN) || Path.join(root, ...CACHE_CONFIG_PATH);

    // load partial cache configs from app and libs
    const libConfigs = this._loadLibConfigs(root);
    const appConfig = this._loadAppConfig(appCacheConfigPath);
    const initialConfig = mergeWithOverwrite(
      [{ data: { cacheManagers: {}, caches: {} } }, ...libConfigs, appConfig].map((c) => c.data)
    );
    // add top level defaults to each config
    Object.keys(initialConfig.cacheManagers).forEach((cacheManagerName) => {
      initialConfig.cacheManagers[cacheManagerName] = {
        ...CACHE_MANAGER_DEFINITION_DEFAULTS,
        ...initialConfig.cacheManagers[cacheManagerName],
      };
    });
    Object.keys(initialConfig.caches).forEach((cacheName) => {
      initialConfig.caches[cacheName] = {
        ...CACHE_DEFINITION_DEFAULTS,
        ...initialConfig.caches[cacheName],
      };
    });
    // load overrides from global config
    const configOverrides = this._loadConfigOverrides(initialConfig);

    const cacheConfigMap = mergeWithOverwrite([initialConfig, configOverrides]);

    this._validateConfig(cacheConfigMap);

    this._config = cacheConfigMap;
  }

  /**
   * Returns cache for all caches in app and libs.
   * @returns {CacheConfigMap} cache config
   */
  get config() {
    return mergeWithOverwrite([{}, this._config]);
  }

  /**
   * Returns cache config for a particular cache.
   * Adds the hardwired handlers to the cache config if they are not disabled using the `disableHardwiredHandlers` option either in cache or as an argument.
   * @param {string} cacheCode
   * @param {boolean} [disableHardwiredHandlers=false]
   * @returns {CacheConfig} cache config
   */
  getCacheConfig(cacheCode, disableHardwiredHandlers = false) {
    if (!this._config.caches[cacheCode]) {
      throw new BaseError(`Cache '${cacheCode}' is not configured.`);
    }
    const cacheDefinition = this._config.caches[cacheCode];
    const cacheManagerDefinition = this._config.cacheManagers[cacheDefinition.cacheManager];

    const cacheConfig = mergeWithOverwrite(
      /** @type {Partial<CacheConfig>[]} */ ([cacheManagerDefinition, cacheDefinition])
    );

    if (!cacheConfig.config.disableHardwiredDefaults && !disableHardwiredHandlers) {
      cacheConfig.handlers = [...HARDWIRED_HANDLERS_PRE, ...cacheConfig.handlers, ...HARDWIRED_HANDLERS_POST];
    }

    return cacheConfig;
  }

  /**
   * Returns the cache config defaults.
   * @returns {Partial<CacheConfig>} cache config
   */
  getDefaultCacheConfig() {
    return mergeWithOverwrite([{}, CACHE_DEFINITION_DEFAULTS, CACHE_MANAGER_DEFINITION_DEFAULTS]);
  }

  /**
   * Loads cache configs for all libs installed in the project.
   * @param {string} root root directory of the project
   * @returns {{ data: PartialCacheConfigMap, source: string }[]} lib cache config array
   */
  _loadLibConfigs(root) {
    const paths = Finder.findConfigInModules(root, CACHE_CONFIG_GLOB_PATTERN);

    return paths.map((path) => {
      try {
        return {
          data: this._loadConfig(path),
          source: path,
        };
      } catch (e) {
        throw new BaseError(`Failed to load cache config from '${path}'.`, e);
      }
    });
  }

  /**
   * Loads cache config for the root app.
   * @param {string} path path to app cache config
   * @returns {{ data: PartialCacheConfigMap, source: string }} app cache config
   */
  _loadAppConfig(path) {
    if (Fs.existsSync(path)) {
      try {
        return {
          data: this._loadConfig(path),
          source: path,
        };
      } catch (e) {
        throw new BaseError(`Unable to load app cache-config.json from ${path}.`, e);
      }
    } else {
      logger.info(`App cache-config.json not found. Only lib cache-config.json will be used.`);
      return { data: {}, source: path };
    }
  }

  /**
   * Loads a cache.json config file.
   * @param {string} path path to cache config
   * @returns {PartialCacheConfigMap} cache config
   */
  _loadConfig(path) {
    const cacheConfig = Json.parse(Fs.readFileSync(path));
    const validationResult = this._validator.validate("partialCacheConfigMapType", cacheConfig);
    if (!validationResult.isValid()) {
      throw new BaseError(
        `Invalid cache-config.json in ${path}:\n${Json.stringify(validationResult.getValidationErrorMap(), true)}`
      );
    }
    return cacheConfig;
  }

  /**
   * Loads cache config overrides from the global config.
   * Respects the optional disableConfigOverrides flag.
   * @param {PartialCacheConfigMap} config cache config which contains all definitions to be overridden
   * @returns {PartialCacheConfigMap} cache config overrides
   */
  _loadConfigOverrides(config) {
    /**
     * Loads overrides from the global config for a key set and config prefix.
     * @param {Record<string, keyType>} configKeys
     * @param  {...string} path
     * @returns {Record<string, unknown>}
     */
    const loadOverrides = (configKeys, ...path) =>
      Object.entries(configKeys).reduce((config, [key, type]) => {
        const configKey = this._getConfigKey(...path, key);
        const configuredValue = this._getConfigValue(configKey, type);
        if (configuredValue != null) {
          config[key] = configuredValue;
        }
        return config;
      }, {});

    // check for overridden top level keys if the disableConfigOverrides flag is not set
    const cacheOverrides = Object.fromEntries(
      Object.entries(config.caches)
        .filter(([_, cacheConfig]) => !(cacheConfig.config && cacheConfig.config.disableConfigOverrides))
        .map(([cacheName, _]) => [cacheName, loadOverrides(CACHE_DEFINITION_CONFIG_KEYS, "caches", cacheName)])
    );
    const cacheManagerOverrides = Object.fromEntries(
      Object.entries(config.cacheManagers)
        .filter(
          ([_, cacheManagerConfig]) => !(cacheManagerConfig.config && cacheManagerConfig.config.disableConfigOverrides)
        )
        .map(([cacheManagerName, _]) => [
          cacheManagerName,
          loadOverrides(CACHE_MANAGER_DEFINITION_CONFIG_KEYS, "cacheManagers", cacheManagerName),
        ])
    );

    return {
      caches: cacheOverrides,
      cacheManagers: cacheManagerOverrides,
    };
  }

  /**
   * Generates a config key for a key path in the config.
   * @param  {...string} args key path components
   * @returns {string}
   */
  _getConfigKey(...args) {
    return `${CACHE_CONFIG_PREFIX}.${args.join(".")}`;
  }

  /**
   * @param {string} key - key to get value for
   * @param {keyType} type - type of value to get
   * @param {boolean} [recursive] - whether to get value recursively
   * @returns {any | null} - value of key or null if not found
   */
  _getConfigValue(key, type, recursive = false) {
    const arrayRegex = /^\[(\d+)\]$/;
    switch (type) {
      case "string":
        return Config.getString(key, recursive);
      case "number":
        return Config.getNumber(key, recursive);
      case "boolean":
        return Config.getBoolean(key, recursive);
      default:
        if (arrayRegex.test(type)) {
          return Config.getArray(key, arrayRegex.exec(type)[1], recursive);
        }
        return Config.get(key);
    }
  }

  /**
   * Loads cache config overrides from the global config for one cache and key.
   * @see CacheConfigLoader for more information
   * @template T
   * @param {string} cacheCode - cache code
   * @param {Record<string, unknown>} config - initial config
   * @param {string} key - config key
   * @param {keyType} type - config type
   * @param {T} [defaultValue] - default value
   * @returns {T | null} - config value
   */
  loadOverrides(cacheCode, config, key, type, defaultValue = null) {
    const configKey = this._getConfigKey(cacheCode, "config", key);
    const cacheConfig = config[key];
    const globalConfig = this._getConfigValue(configKey, type);

    if (globalConfig != null) {
      return globalConfig;
    }

    if (cacheConfig != null) {
      return /** @type {T} */ (cacheConfig);
    }
    return defaultValue;
  }

  /**
   * Loads all cache config overrides from the global config.
   * Respects the optional disableConfigOverrides flag.
   * @see CacheConfigLoader for more information
   * @param {string} cacheCode
   * @param {Record<string, unknown>} config - initial config
   * @param {Record<string, keyType>} keyTypes - object with value of type for each key
   * @param {Record<string, unknown>} defaults - object with default value for each key
   * @returns {Record<string, unknown>} - config with overrides
   */
  loadAllOverrides(cacheCode, config, keyTypes, defaults = {}) {
    if (config.disableConfigOverrides) {
      return config;
    }
    const configWithOverrides = { ...config };
    Object.entries(keyTypes).forEach(([key, type]) => {
      configWithOverrides[key] = this.loadOverrides(cacheCode, config, key, type, defaults[key]);
    });
    return configWithOverrides;
  }
}

module.exports = new CacheConfigLoader();
