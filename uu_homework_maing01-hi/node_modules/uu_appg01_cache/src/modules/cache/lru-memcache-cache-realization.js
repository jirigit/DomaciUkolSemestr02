"use strict";

const SizedNestedMap = require("../memcache/sized-nested-map.js");
const LinkedList = require("../linked-list/linked-list.js");
const OrderedLinkedList = require("../linked-list/ordered-linked-list.js");
const CacheConfigLoader = require("../../libs/cache-config-loader");

const CACHE_REALIZATION_NAME = "uu_app_cache/basic-memory-cache";
const CACHE_REALIZATION_POLICY = "lru";

const CONFIG_TYPES = {
  ttl: "number",
};

const DEFAULT_CONFIG = {
  ttl: 1000 * 60 * 60,
};

/**
 * Represents one item in the cache.
 */
class LruCacheItem {
  constructor(awid, key, value, exp) {
    this.awid = awid;
    this.key = key;
    this.value = value;
    this.exp = exp;
  }

  isExpired() {
    return this.exp && this.exp <= Date.now();
  }

  toJSON() {
    return [this.awid, this.key, this.value, this.exp];
  }
}

/**
 * LRU cache realization.
 */
class LruCache extends SizedNestedMap {
  /**
   * Creates a new LRU cache.
   * @param {string} code
   * @param {Object} config
   */
  constructor(code, config = {}) {
    config = CacheConfigLoader.loadAllOverrides(code, config, CONFIG_TYPES, DEFAULT_CONFIG);
    super(code, config);
    this._ttl = config.ttl;

    // list with most recently used first
    this._recent = new LinkedList();
    // list with latest expiring items first
    this._expiring = new OrderedLinkedList("desc");
  }

  /**
   * Sets an item in the cache.
   * @param {*} awid
   * @param {*} key
   * @param {*} value
   * @param {Object} [opts={}]
   * @returns {*} previous value or null
   */
  set(awid, key, value, opts = {}) {
    const existingItem = super.get(awid, key);
    if (existingItem) {
      this._remove(existingItem);
    }

    const ttl = opts.ttl === undefined ? this._ttl : opts.ttl;
    const newItem = new LruCacheItem(awid, key, value, ttl ? Date.now() + ttl : null);

    // add new item to lists
    this._recent.unshift(newItem, "first");
    if (newItem.exp) {
      this._expiring.add(newItem, newItem.exp);
    }

    super.set(awid, key, newItem);
    return existingItem ? existingItem.value : null;
  }

  /**
   * Retrieves an item from cache.
   * @param {*} awid
   * @param {*} key
   * @returns {*} item value or null
   */
  get(awid, key) {
    const item = super.get(awid, key);
    if (!item) {
      return null;
    }

    if (item.isExpired()) {
      this._remove(item);
      return null;
    }

    this._touch(item);
    return item.value;
  }

  /**
   * Deletes an item from cache.
   * @param {*} awid
   * @param {*} key
   * @returns item value or null
   */
  delete(awid, key) {
    const item = super.get(awid, key);
    if (!item) {
      return null;
    }

    if (item.isExpired()) {
      this._remove(item);
      return null;
    }

    this._remove(item);
    return item.value;
  }

  clear(awid) {
    if (awid === undefined) {
      this._recent.clear();
      this._expiring.clear();
      return super.clear();
    }

    const items = super.values(awid);
    for (const item of items) {
      this._remove(item);
    }
  }

  entries(awid) {
    return super.entries(awid).map(([key, item]) => [key, item.value]);
  }

  [Symbol.iterator]() {
    const iterator = super[Symbol.iterator]();
    return {
      next: () => {
        const { value, done } = iterator.next();
        if (done) {
          return { value, done };
        }
        const [awid, key, item] = value;
        return { value: [awid, key, item.value], done };
      },
    };
  }

  /**
   * Returns a customized iterable limited to the given awid.
   * If awid is not specified returns the default iterable over all awids.
   * @param {any} awid
   * @returns {Iterable<[any, any, any]>}
   */
  iter(awid) {
    const iterable = super.iter(awid)[Symbol.iterator]();
    return {
      [Symbol.iterator]: () => ({
        next: () => {
          const { value, done } = iterable.next();
          if (done) {
            return { value, done };
          }
          const [awid, key, item] = value;
          return { value: [awid, key, item.value], done };
        },
      }),
    };
  }

  /**
   * Moves the item to the beginning of the recent list.
   * @param {LruCacheItem} item - item to touch
   */
  _touch(item) {
    this._recent.unshift(item);
  }

  /**
   * Deletes a cache item.
   * @param {LruCacheItem} item - item to delete
   */
  _remove(item) {
    this._recent.remove(item);
    if (item.exp) {
      this._expiring.remove(item);
    }
    super.delete(item.awid, item.key);
  }

  /**
   * Returns a customized realization name.
   * @returns {string}
   */
  static get REALIZATION_NAME() {
    return CACHE_REALIZATION_NAME;
  }

  /**
   * Returns a customized realization policy.
   * @returns {string}
   */
  static get REALIZATION_POLICY() {
    return CACHE_REALIZATION_POLICY;
  }
}

module.exports = LruCache;
