"use strict";

/**
 * Unordered Linked List
 * Stores objects in a doubly linked list.
 */
class LinkedList {
  constructor() {
    this.first = null;
    this.last = null;
    this.s = Symbol("LinkedList");
  }

  _addItem(item, position) {
    // if item is already in list, remove it
    if (item[this.s]) {
      this.remove(item);
    }

    // create links
    item[this.s] = {
      prev: null,
      next: null,
    };

    // if linked list is empty, add item as first and last
    if (!this.first) {
      this.first = item;
      this.last = item;
      return this;
    }

    // if linked list is not empty, add the item according to position
    switch (position) {
      case "first":
        if (this.first) {
          this.first[this.s].prev = item;
          item[this.s].next = this.first;
        }
        this.first = item;
        break;
      case "last":
      default:
        if (this.last) {
          this.last[this.s].next = item;
          item[this.s].prev = this.last;
        }
        this.last = item;
        break;
    }

    return this;
  }

  /**
   * Adds an item to the end of the list.
   * @param {Object} item
   * @returns {LinkedList}
   */
  push(item) {
    this._addItem(item, "last");
    return this;
  }

  /**
   * Adds an item to the beginning of the list.
   * @param {Object} item
   * @returns {LinkedList}
   */
  unshift(item) {
    this._addItem(item, "first");
    return this;
  }

  /**
   * Returns the last item in the list and removes it.
   * Returns null if the list is empty.
   * @returns {Object?}
   */
  pop() {
    if (!this.last) {
      return null;
    }
    const item = this.last;
    this.remove(item);
    return item;
  }

  /**
   * Returns the first item in the list and removes it.
   * Returns null if the list is empty.
   * @returns {Object?}
   */
  shift() {
    if (!this.first) {
      return null;
    }
    const item = this.first;
    this.remove(item);
    return item;
  }

  /**
   * Removes an item from the list.
   * @param {Object} item
   * @returns {OrderedLinkedList}
   */
  remove(item) {
    if (!item[this.s]) {
      return this;
    }

    // link previous item with next of removed item
    if (item[this.s].prev) {
      item[this.s].prev[this.s].next = item[this.s].next;
    }
    // link next item with prev of removed item
    if (item[this.s].next) {
      item[this.s].next[this.s].prev = item[this.s].prev;
    }
    // if removed item is first, update first
    if (this.first === item) {
      this.first = item[this.s].next;
    }
    // if removed item is last, update last
    if (this.last === item) {
      this.last = item[this.s].prev;
    }
    // remove links
    delete item[this.s];
    return this;
  }

  /**
   * Navigates to the next item or previous item in the list.
   * Returns null if there is no such neighbouring item.
   * @param {Object} item
   * @param {"prev" | "next"} direction
   * @returns {Object?}
   */
  navigate(item, direction) {
    if (!item[this.s]) {
      return null;
    }
    switch (direction) {
      case "next":
        return item[this.s].next;
      case "prev":
        return item[this.s].prev;
    }
  }

  /**
   * Removes all items from the list.
   */
  clear() {
    let next = this.first;
    while (next) {
      let item = next;
      next = item[this.s].next;
      delete item[this.s];
    }

    this.first = null;
    this.last = null;
  }
}

module.exports = LinkedList;
