"use strict";

const DEFAULT_SORTING = "asc";

/**
 * Ordered Linked List
 * Stores objects in a doubly linked list, ordered by a given value.
 */
class OrderedLinkedList {
  /**
   * Creates a new OrderedLinkedList instance.
   * @param {"asc" | "desc"} [sorting="asc"] - Sorting direction.
   */
  constructor(sorting = null) {
    this.sorting = sorting || DEFAULT_SORTING;
    this.s = Symbol("OrderedLinkedList");
  }

  /**
   * Adds an item to the list.
   * @param {Object} item - Item to add. Must be an object.
   * @param {any} key - Value to sort by.
   * @returns {OrderedLinkedList}
   */
  add(item, key) {
    switch (this.sorting) {
      case "asc": {
        // check if item may be inserted before first
        if (!this.first || key <= this.first[this.s].key) {
          return this._addAfter(item, null, key);
        }

        // check if item may be inserted after last
        if (this.last && key > this.last[this.s].key) {
          return this._addAfter(item, this.last, key);
        }

        // find item before which to insert
        let prev = this.first;
        while (prev[this.s].next && key > prev[this.s].next[this.s].key) {
          prev = prev[this.s].next;
        }

        this._addAfter(item, prev, key);
        break;
      }
      case "desc": {
        // check if item may be inserted before first
        if (!this.first || key >= this.first[this.s].key) {
          return this._addAfter(item, null, key);
        }

        // check if item may be inserted after last
        if (key < this.last[this.s].key) {
          return this._addAfter(item, this.last, key);
        }

        // find item before which to insert
        let prev = this.first;
        while (prev[this.s].next && key < prev[this.s].next[this.s].key) {
          prev = prev[this.s].next;
        }

        this._addAfter(item, prev, key);
        break;
      }
    }
    return this;
  }

  /**
   * Adds an item to the list after a given item.
   * @param {Object} item
   * @param {Object} prev
   * @param {any} key
   * @returns {OrderedLinkedList}
   */
  _addAfter(item, prev, key) {
    // if item is already in list, remove it
    if (item[this.s]) {
      this.remove(item);
    }

    // create links
    item[this.s] = {
      prev: null,
      next: null,
      key,
    };

    // if linked list is empty, add item as first and last
    if (!this.first) {
      this.first = item;
      this.last = item;
      return this;
    }

    // if item is null, add new item as first
    if (!prev) {
      // item[this.s].prev = null;
      item[this.s].next = this.first;
      this.first[this.s].prev = item;
      this.first = item;
      return this;
    }

    // if linked list is not empty, add the new item after the item
    item[this.s].prev = prev;
    if (prev[this.s].next) {
      item[this.s].next = prev[this.s].next;
      prev[this.s].next[this.s].prev = item;
    }
    if (this.last === prev) {
      this.last = item;
    }
    prev[this.s].next = item;
    return this;
  }

  /**
   * Returns the last item in the list and removes it.
   * Returns null if the list is empty.
   * @returns {Object?}
   */
  pop() {
    if (!this.last) {
      return null;
    }
    const item = this.last;
    this.remove(item);
    return item;
  }

  /**
   * Returns the first item in the list and removes it.
   * Returns null if the list is empty.
   * @returns {Object?}
   */
  shift() {
    if (!this.first) {
      return null;
    }
    const item = this.first;
    this.remove(item);
    return item;
  }

  /**
   * Removes an item from the list.
   * @param {Object} item
   * @returns {OrderedLinkedList}
   */
  remove(item) {
    if (!item[this.s]) {
      return;
    }

    // link previous item with next of removed item
    if (item[this.s].prev) {
      item[this.s].prev[this.s].next = item[this.s].next;
    }
    // link next item with prev of removed item
    if (item[this.s].next) {
      item[this.s].next[this.s].prev = item[this.s].prev;
    }
    // if removed item is first, update first
    if (this.first === item) {
      this.first = item[this.s].next;
    }
    // if removed item is last, update last
    if (this.last === item) {
      this.last = item[this.s].prev;
    }
    // remove links
    delete item[this.s];
  }

  /**
   * Navigates to the next item or previous item in the list.
   * Returns null if there is no such neighbouring item.
   * @param {Object} item
   * @param {"prev" | "next"} direction
   * @returns {Object?}
   */
  navigate(item, direction) {
    if (!item[this.s]) {
      return null;
    }
    switch (direction) {
      case "next":
        return item[this.s].next;
      case "prev":
        return item[this.s].prev;
    }
  }

  /**
   * Removes all items from the list.
   */
  clear() {
    let next = this.first;
    while (next) {
      let item = next;
      next = item[this.s].next;
      delete item[this.s];
    }

    this.first = null;
    this.last = null;
  }
}

module.exports = OrderedLinkedList;
