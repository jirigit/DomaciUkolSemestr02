// @ts-check
"use strict";

const { BaseError, Json } = require("uu_appg01_core-utils");
const Cache = require("../cache.js");

/* const _checkLocalStorage = () => {
  try {
    localStorage.setItem("uu_appg01_cache_test", "test");
    if (localStorage.getItem("uu_appg01_cache_test") !== "test") {
      return false;
    }
    localStorage.removeItem("uu_appg01_cache_test");
  } catch (e) {
    return false;
  }
};

const LOCAL_STORAGE_ENABLED = _checkLocalStorage(); */

/**
 * @template S - scope type
 * @template K - key type
 * @template V - value type
 * Stores items in a nested map. Items are specified by their scope and key.
 * Nested map is a map of maps where key in the outer map corresponds to nested map scope and key in the inner map correspond to nested map key.
 *
 * @remarks
 * A nested map with an item with scope "a" and key "b" will be stored in the following structure:
 *
 * ```
 * Map({
 *  "a": Map({
 *    "b": "value"
 *   }),
 * });
 * ```
 */
class NestedMap extends Cache {
  constructor(code, config = {}) {
    super(code, config);
    this._baseMap = new Map();
  }

  /**
   * Gets or creates nested map for given scope.
   * @param {S} scope
   * @returns {Map<K, V>}
   */
  _getMap(scope) {
    if (!this._baseMap.has(scope)) {
      this._baseMap.set(scope, new Map());
    }

    return this._baseMap.get(scope);
  }

  /**
   * Sets a value for given scope and key.
   * @param {S} scope
   * @param {K} key
   * @param {V} value
   * @returns {V | undefined} old value
   */
  set(scope, key, value) {
    if (scope === undefined) {
      throw new BaseError("Undefined is not a valid scope, use null or a static scope instead.");
    }

    const oldValue = this._getMap(scope).get(key);
    this._getMap(scope).set(key, value);
    return oldValue;
  }

  /**
   * Gets a value for given scope and key.
   * @param {S} scope
   * @param {K} key
   * @returns {V | undefined}
   */
  get(scope, key) {
    return this._getMap(scope).get(key);
  }

  /**
   * Deletes a value for given scope and key.
   * @param {S} scope
   * @param {K} key
   * @returns {V | undefined} old value
   */
  delete(scope, key) {
    const oldValue = this._getMap(scope).get(key);
    this._getMap(scope).delete(key);
    return oldValue;
  }

  /**
   * Clears the nested for given scope. If scope is not specified, clears the nested map for all scopes.
   * @param {S} [scope]
   * @returns {void}
   */
  clear(scope) {
    if (scope === undefined) {
      this._baseMap.clear();
    }

    return this._getMap(scope).clear();
  }

  /**
   * Checks if nested map contains a value for given scope and key.
   * @param {S} scope
   * @param {K} key
   * @returns {boolean}
   */
  has(scope, key) {
    return this._getMap(scope).has(key);
  }

  /**
   * Returns an array of entries in the shape of [scope, key, value].
   * If scope is not specified, returns all entries.
   * @param {S} [scope]
   * @returns {[S, K, V][]}
   */
  entries(scope) {
    if (scope === undefined) {
      return [...this._baseMap.keys()].reduce((acc, scope) => [...acc, ...this.entries(scope)], []);
    }

    return [...this._getMap(scope).entries()].map(([key, value]) => [scope, key, value]);
  }

  /**
   * Returns an array of keys in the shape of [scope, key].
   * If scope is not specified, returns all keys.
   * @param {S} [scope]
   * @returns {[S, K][]}
   */
  keys(scope) {
    if (scope === undefined) {
      return [...this._baseMap.keys()].reduce((acc, scope) => [...acc, ...this.keys(scope)], []);
    }

    return [...this._getMap(scope).keys()].map((key) => [scope, key]);
  }

  /**
   * Returns an array of values for a given scope. If scope is not specified, returns all values.
   * @param {S} [scope]
   * @returns {V[]}
   */
  values(scope) {
    if (scope === undefined) {
      return [...this._baseMap.keys()].reduce((acc, scope) => [...acc, ...this.values(scope)], []);
    }

    return [...this._getMap(scope).values()];
  }

  /**
   * Returns an object representation of the cache.
   * @returns {[S, K, V][]}
   */
  toJSON() {
    return this.entries();
  }

  /**
   * Recreate cache from JSON representation.
   * @param {string | [any, any, any][]} json
   * @returns {NestedMap}
   */
  static fromJSON(json) {
    const nm = new NestedMap();
    if (typeof json === "string") {
      json = Json.parse(json);
    }

    for (const [scope, key, value] of json) {
      nm.set(scope, key, value);
    }

    return nm;
  }

  /**
   * Returns a customized iterable limited to the given scope.
   * If scope is not specified, returns the default iterable over all scopes.
   * @param {S} [scope]
   * @returns {Iterable<[S, K, V]>}
   * @example
   * for (const [scope, key, value] of cache.iter(scope)) {
   *   // items from given scope
   *   console.log(`${scope}: ${key} = ${value}`);
   * }
   */
  iter(scope) {
    if (scope === undefined) {
      return this;
    }

    const itemIter = this._getMap(scope)[Symbol.iterator]();
    return {
      /**
       * @returns {Iterator<[S, K, V], undefined>}
       */
      [Symbol.iterator]: () => ({
        /**
         * @returns {IteratorResult<[S, K, V], undefined>}
         */
        next: () => {
          const item = itemIter.next();
          if (!item.done) {
            const [key, value] = item.value;
            return { done: false, value: [scope, key, value] };
          }

          return { done: true, value: undefined };
        },
      }),
    };
  }

  /**
   * Returns a customized iterable over all scopes.
   * @returns {Iterator<[S, K, V], undefined>}
   */
  [Symbol.iterator]() {
    // scope iterator
    const scopeIter = this._baseMap[Symbol.iterator]();
    let curScope = scopeIter.next();

    // nested map iterator initialized with dummy value
    let itemIter = { next: () => ({ done: true }) };
    let curItem = { done: true };
    return {
      /**
       * @returns {IteratorResult<[S, K, V], undefined>}
       */
      next: () => {
        // If we have items in current scope, return next one.
        // Otherwise, get next scope and start iterating over it.
        do {
          // If there are no more items in current scope, get next scope.
          if (curItem.done) {
            curScope = scopeIter.next();
            itemIter = curScope.value[Symbol.iterator]();
          }

          // try to get next item from current scope
          curItem = itemIter.next();
          if (!curItem.done) {
            return { done: false, value: curItem.value };
          }
        } while (!curScope.done);
        return { done: true, value: undefined };
      },
    };
  }

  /**
   * Returns the count of items in the cache for a given scope. If scope is not specified, returns the count of items in all scopes.
   * @param {S} [scope]
   * @returns {number}
   */
  size(scope) {
    if (scope === undefined) {
      return [...this._baseMap.keys()].reduce((acc, scope) => acc + this.size(scope), 0);
    }
    return this._getMap(scope).size;
  }
}

module.exports = NestedMap;
