// @ts-check
"use strict";

// eslint-disable-next-line prettier/prettier
// @ts-ignore
const sizeof = /** @type {(obj: unknown) => number} */ (/** @type {unknown} */ require("object-sizeof"));

const { LoggerFactory } = require("uu_appg01_core-logging");
const CacheConfigLoader = require("../../libs/cache-config-loader");

const NestedMap = require("./nested-map");

const LOGGER = LoggerFactory.get("UuApp.Cache.Realization.NestedMap", true);

/**
 * @type {{[key: string]: CacheConfigLoader.keyType}}
 */
const CONFIG_TYPES = {
  maxItemCount: "number",
  maxSoi: "number",
  warnOnBigItems: "boolean",
};

const DEFAULT_CONFIG = {
  maxItemCount: -1,
  maxSoi: -1,
  warnOnBigItems: false,
};

/**
 * Nested map with size limit.
 * @template S - scope type
 * @template K - key type
 * @template V - value type
 * @extends NestedMap<S,K,V>
 */
class SizedNestedMap extends NestedMap {
  /**
   * @param {string} code - unique code of the cache
   * @param {object} config - options
   * @param {number} [config.maxSoi] - max size of items in the cache
   * @param {number} [config.maxItemCount] - max number of items in the cache
   * @param {boolean} [config.warnOnBigItems] - whether to warn on items that are too big to be stored
   */
  constructor(code, config = {}) {
    config = CacheConfigLoader.loadAllOverrides(code, config, CONFIG_TYPES, DEFAULT_CONFIG);
    super(code, config);
    this._maxItemCount = this.config.maxItemCount;
    this._maxSoi = this.config.maxSoi;
    this._warnOnBigItems = this.config.warnOnBigItems;
    this._totalSize = 0;
    this._totalItemCount = 0;
  }

  /**
   * Sets an item in the cache.
   * @param {S} scope
   * @param {K} key
   * @param {V} value
   * @returns {V | undefined}
   */
  set(scope, key, value) {
    const size = [scope, key, value].reduce((s, item) => s + sizeof(item), 0);
    if (this._maxSoi > 0 && size > this._maxSoi) {
      this._warnOnBigItems &&
        LOGGER.warn(
          `Entry for cache '${this._code}' with scope '${scope}' and key '${key}' won't be saved, because its total size (${size}) is greater than max size (${this._maxSoi}). The old item is being removed.`
        );
      return this.delete(scope, key);
    }

    if (this._maxItemCount && this._totalItemCount + 1 >= this._maxItemCount) {
      this.remove(this._maxItemCount - this._totalItemCount + 1);
    }

    const oldValue = super.set(scope, key, value);

    this._totalItemCount += 1;
    this._totalSize += size;

    return oldValue;
  }

  /**
   * Deletes an item from the cache.
   * @param {S} scope
   * @param {K} key
   * @returns {V | undefined}
   */
  delete(scope, key) {
    if (super.has(scope, key)) {
      const oldValue = super.delete(scope, key);

      this._totalSize -= [scope, key, oldValue].reduce((s, item) => s + sizeof(item), 0);
      this._totalItemCount -= 1;

      return oldValue;
    }
  }

  getMetrics() {
    return {
      itemSize: this._totalSize,
      itemCount: this._totalItemCount,
    };
  }

  /**
   * Removes a random item from the cache. Should be overridden in subclasses.
   * @abstract
   * @param {number} atLeast - the number of items to remove at least
   */
  remove(atLeast = 1) {
    for (let i = 0; i < atLeast; i++) {
      const keys = super.keys();
      if (keys.length === 0) {
        return null;
      }

      const [scope, key] = keys[Math.floor(Math.random() * keys.length)];
      this.delete(scope, key);
      this._totalItemCount -= 1;
    }
  }

  /**
   * Removes all items from the cache.
   * @param {S} scope
   * @returns
   */
  clear(scope) {
    if (scope === undefined) {
      this._totalSize = 0;
      this._totalItemCount = 0;
      return super.clear();
    }

    const items = super.values(scope);
    this._totalSize -= items.reduce((s, item) => s + sizeof(item), 0);
    this._totalItemCount -= items.length;
    return super.clear(scope);
  }
}

module.exports = SizedNestedMap;
