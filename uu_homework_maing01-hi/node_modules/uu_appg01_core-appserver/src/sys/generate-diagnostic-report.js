"use strict";

const V8 = require("v8");
const Os = require("os");
const Fs = require("fs");
const Path = require("path");
const Crypto = require("crypto");
const Archiver= require("archiver");
const Http = require("http");
const Https = require("https");
const {URL} = require("url");
const FormData = require("form-data");
const {Config, OptsReader} = require("uu_appg01_core-utils");
const {LoggerFactory} = require("uu_appg01_core-logging");
const {Validator} = require("uu_appg01_core-validation");
const ValidationHelper = require("../utils/validation-helper.js");
const Sys = require("./sys.js");
const Errors = require("../error/diagnostic-report-error.js");

const WARNINGS = {
  unsupportedKeys: {
    code: `${Errors.Generate.UC_CODE}unsupportedKeys`,
  },
  gcNotAvailable: {
    code: `${Errors.Generate.UC_CODE}gcNotAvailable`,
    message: "GC is not available. To allow explicit GC, start uuApp with parameter \"--expose-gc\"."
  },
  uploadUrlNotConfigured: {
    code: `${Errors.Generate.UC_CODE}uploadUrlNotConfigured`,
    message: "Diagnostic report upload URL is not configured. Report is available only in configured container location."
  }
};

const ENV_NODE_NAME = "UU_CLOUD_NODE_NAME";

const CFG_REPORT_LOCATION = "uu_app_diagnostic_report_location";

const CFG_UPLOAD_URL = "uu_app_diagnostic_report_upload_url";

const CFG_UPLOAD_AUTH = "uu_app_diagnostic_report_upload_auth";

const CFG_UPLOAD_PARAM = "uu_app_diagnostic_report_upload_param";

const CFG_UPLOAD_METHOD = "uu_app_diagnostic_report_upload_method";

const CFG_UPLOAD_CON_TIMEOUT = "uu_app_diagnostic_report_upload_con_timeout";

const CFG_UPLOAD_REQ_TIMEOUT = "uu_app_diagnostic_report_upload_req_timeout";

const CFG_REPORT_CLEANUP = "uu_app_diagnostic_report_cleanup";

const DEFAULT_REPORT_LOCATION = "diagnosticReports";

const DEFAULT_UPLOAD_CON_TIMEOUT = 5; // 5 seconds

const DEFAULT_UPLOAD_REQ_TIMEOUT = 5 * 60; // 5 minutes

const DEFAULT_REPORT_CLEANUP = "always";

const DEFAULT_HEADER_USER_AGENT = "uuAppClient (Node.js)";

class GenerateDiagnosticReport {

  constructor() {
    this._logger = LoggerFactory.get("UuApp.Appserver.DiagnosticReport");
    this._validator = Validator.load();
    let opts = new OptsReader(Config);
    this._asid = opts.getString("asid", "00000000000000000000000000000000");
    this._reportLocation = opts.getString(CFG_REPORT_LOCATION, Path.join(Os.tmpdir(), DEFAULT_REPORT_LOCATION));
    this._uploadUrl = opts.getString(CFG_UPLOAD_URL);
    this._uploadAuth = opts.getString(CFG_UPLOAD_AUTH);
    this._uploadParam = opts.getString(CFG_UPLOAD_PARAM);
    this._uploadMethod = opts.getString(CFG_UPLOAD_METHOD, this._uploadParam ? "POST" : "PUT");
    this._uploadConTimeout = opts.getNumber(CFG_UPLOAD_CON_TIMEOUT, DEFAULT_UPLOAD_CON_TIMEOUT) * 1000;
    this._uploadReqTimeout = opts.getNumber(CFG_UPLOAD_REQ_TIMEOUT, DEFAULT_UPLOAD_REQ_TIMEOUT) * 1000;
    this._reportCleanup = opts.getString(CFG_REPORT_CLEANUP, DEFAULT_REPORT_CLEANUP);
    if (!this._uploadUrl && this._reportCleanup === "always") {
      this._logger.warn("Diagnostic report command is configured to directly provide output. For production use it is recommended to configure repository where reports are uploaded and securely stored.");
    }
  }

  async call(ucEnv) {
    Sys.authorize(ucEnv);
    let dtoIn = ucEnv.getDtoIn();

    let validationResult = this._validator.validate("sysGenerateDiagnosticReportDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      WARNINGS.unsupportedKeys.code,
      Errors.Generate.InvalidDtoInError
    );
    if (dtoIn.triggerGc && !global.gc) {
      ValidationHelper.addWarning(uuAppErrorMap, WARNINGS.gcNotAvailable.code, WARNINGS.gcNotAvailable.message, {});
    }

    let reportLocation = this._getDiagnosticReportLocation(ucEnv.getUri());
    let reportFile;
    try {
      reportFile = await this._generateDiagnosticReport(reportLocation, dtoIn);
    } catch (e) {
      throw new Errors.Generate.GeneratingOfReportFailed({ uuAppErrorMap }, {}, e);
    }

    if (this._uploadUrl) {
      this._uploadDiagnosticReport(reportFile).then((successful) => {
        this._cleanupDiagnosticReport(reportFile, successful);
      });
      return {uuAppErrorMap};
    } else if (this._reportCleanup === "always") {
      let filename = Path.basename(reportFile);
      let contentType = "application/octet-stream";
      let stream = Fs.createReadStream(reportFile);
      stream.on("end", () => this._cleanupDiagnosticReport(reportFile, true));
      stream.on("error", () => this._cleanupDiagnosticReport(reportFile, false));
      return ucEnv.setBinaryDtoOut({filename, contentType, stream}, "attachment");
    } else {
      ValidationHelper.addWarning(uuAppErrorMap, WARNINGS.uploadUrlNotConfigured.code, WARNINGS.uploadUrlNotConfigured.message, {});
      return {uuAppErrorMap};
    }
  }

  _getDiagnosticReportLocation(uri) {
    let nodeName = process.env[ENV_NODE_NAME];
    if (!nodeName) {
      nodeName = `${uri.getProduct()}-${this._asid}`
    }
    let randomId = Crypto.randomBytes(4).toString("hex");
    let reportDir = `${nodeName}-${Math.round(Date.now() / 1000)}-${randomId}`;
    return Path.join(this._reportLocation, reportDir);
  }

  async _generateDiagnosticReport(reportLocation, dtoIn) {
    this._logger.info(`Generating diagnostic report to ${reportLocation}`);
    Fs.mkdirSync(reportLocation, { recursive: true })

    if (dtoIn.triggerGc) {
      if (global.gc) {
        this._logger.debug("Triggering explicit GC");
        global.gc();
      } else {
        this._logger.warn(WARNINGS.gcNotAvailable.message);
      }
    }

    this._logger.debug("Creating process report");
    let reportFile = Path.join(reportLocation, `nodejs_pid${process.pid}.json`);
    process.report.writeReport(reportFile);

    let dumpFile;
    if (dtoIn.includeHeapDump !== false) {
      this._logger.debug("Creating heap dump");
      dumpFile = Path.join(reportLocation, `nodejs_pid${process.pid}.heapsnapshot`);
      V8.writeHeapSnapshot(dumpFile);
    }

    return this._compressDiagnosticReport(reportLocation);
  }

  async _compressDiagnosticReport(reportLocation) {
    this._logger.debug(`Compressing diagnostic report ${reportLocation}`);
    let reportArchive = `${reportLocation}.tar.gz`;
    try {
      await new Promise((resolve, reject) => {
        let output = Fs.createWriteStream(reportArchive);
        let archive = new Archiver('tar', {gzip: true, gzipOptions: {level: 9}});
        output.on("close", () => {resolve()});
        output.on("end", () => {resolve()});
        archive.on("warning", (error) => {resolve()});
        archive.on("error", (error) => {reject(error)});
        archive.pipe(output);
        let files = Fs.readdirSync(reportLocation);
        files.forEach((file) => {
          archive.file(Path.join(reportLocation, file), { name: file });
        });
        archive.finalize();
      });
    } catch (e) {
      Fs.exists(reportArchive, (exists) => {
        if (exists) {
          Fs.unlink(reportArchive, (error) => {});
        }
      });
      throw e;
    }
    Fs.exists(reportLocation, (exists) => {
      if (exists) {
        Fs.rm(reportLocation, {recursive: true}, (error) => {});
      }
    })
    this._logger.debug(`Diagnostic report compressed as ${reportArchive}`);
    return reportArchive;
  }

  async _uploadDiagnosticReport(reportFile) {
    return new Promise((resolve) => {
      try {
        this._logger.debug(`Uploading diagnostic report ${reportFile} to ${this._uploadUrl}`);
        let httpHeaders = {};
        httpHeaders["user-agent"] = DEFAULT_HEADER_USER_AGENT;
        httpHeaders["accept"] = "*/*";
        if (this._uploadAuth) {
          httpHeaders["authorization"] = this._uploadAuth;
        }
        let httpMethod = this._uploadMethod;
        let requestOptions = {
          method: httpMethod,
          headers: httpHeaders,
          timeout: this._uploadConTimeout
        };
        let finalUploadUrl;
        let requestBody;
        if (this._uploadParam) {
          finalUploadUrl = this._uploadUrl;
          let fileStream = Fs.createReadStream(reportFile);
          requestBody = new FormData();
          requestBody.append(this._uploadParam, fileStream, {contentType: "application/octet-stream"});
          Object.assign(httpHeaders, requestBody.getHeaders());
        } else {
          finalUploadUrl = `${this._uploadUrl.replace("/+$", "")}/${Path.basename(reportFile)}`;
          httpHeaders["content-type"] = "application/octet-stream";
          requestBody = Fs.createReadStream(reportFile);
        }
        let url = new URL(finalUploadUrl);
        requestOptions.hostname = url.hostname;
        requestOptions.port = url.port;
        requestOptions.path = url.pathname + url.search;
        let request = (url.protocol == "https:" ? Https : Http).request(requestOptions, (response) => {
          response.on("data", (data) => {});
          response.on("end", () => {
            if (response.statusCode >=200 && response.statusCode < 300) {
              resolve(true);
              this._logger.info(`Diagnostic report uploaded to ${finalUploadUrl}`);
            } else {
              resolve(false);
              this._logger.error(`Upload of diagnostic report to ${finalUploadUrl} failed with response status ${response.statusCode}.`);
            }
          });
        });
        request.setTimeout(this._uploadReqTimeout, () => {
          resolve(false);
          this._logger.error(`Upload of diagnostic report to ${this._uploadUrl} did not finish in ${this._uploadReqTimeout}ms.`);
        });
        request.on("error", (error) => {
          resolve(false);
          this._logger.error("Upload of diagnostic report to " + this._uploadUrl + " failed.", error);
        });
        requestBody.pipe(request);
      } catch (e) {
        resolve(false);
        this._logger.error("Upload of diagnostic report to " + this._uploadUrl + " failed.", e);
      }
    });
  }

  async _cleanupDiagnosticReport(reportFile, transmitSuccessful) {
    if (this._reportCleanup == "always" || (transmitSuccessful && this._reportCleanup == "onSuccessfulUpload")) {
      Fs.exists(reportFile, (exists) => {
        if (exists) {
          Fs.unlink(reportFile, (error) => {});
        }
      });
    }
  }

}

module.exports = new GenerateDiagnosticReport();
