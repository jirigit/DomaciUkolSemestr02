"use strict";

const UnexpectedError = require("../error/unexpected-error")

class ErrorConverter {

  /**
   * Builds standardized error dtoOut containing uuAppErrorMap, assigning default values
   * and headers where missing.
   * @param {BaseError, UseCaseError} error
   * @param {Boolean} verbose
   * @returns {{dtoOut: (*|{}), status: number, headers: {}}}
   */
  buildErrorDtoOut(error, verbose = false) {
    let status = error.status || 500;
    let headers = error.headers || {};
    headers["Connection"] = headers["Connection"] || "close";
    let dtoOut = error.dtoOut || {};
    let code = error.code || "uu-appg01/server/internalServerError";
    dtoOut["uuAppErrorMap"] = dtoOut["uuAppErrorMap"] || {};
    let isUnexpectedError = false;

    let messageBody = {};
    let raisedErrorMessage = {
      [code]: messageBody
    };

    // Throw custom UnexpectedError is production mode when we do not have error.id
    if (!error.id && !verbose) {
      error = new UnexpectedError(error);
      isUnexpectedError = true
    }

    if (error.id) {
      messageBody.id = error.id;
    }
    if (error.timestamp) {
      messageBody["timestamp"] = error.timestamp.toISOString();
    }
    if (error.type) {
      messageBody.type = error.type;
    } else {
      messageBody.type = "error";
    }
    if (verbose || error.message !== error.constructor.name) {
      messageBody.message = error.message;
    } else {
      messageBody.message = "Unexpected error";
    }
    if (error.paramMap && typeof error.paramMap === "object" && Object.keys(error.paramMap).length) {
      messageBody.paramMap = error.paramMap;
    }
    if (verbose) {
      messageBody.trace = error.stack;
      // !isUnexpectedError prevents buildErrorDtoOut() call in infinite call stack
      if (error.cause && !isUnexpectedError) {
        messageBody.cause = this.buildErrorDtoOut(error.cause, verbose).dtoOut;
      }
    } else {
      // !isUnexpectedError prevents buildErrorDtoOut() call in infinite call stack
      if (error.cause && error.cause.code && !isUnexpectedError) {
        messageBody.cause = this.buildErrorDtoOut(error.cause, verbose).dtoOut;
      }
    }

    delete dtoOut.uuAppErrorMap.code;
    dtoOut.uuAppErrorMap = Object.assign(raisedErrorMessage, dtoOut.uuAppErrorMap);

    return {
      dtoOut,
      status,
      headers,
      errorCode: code,
      errorMessage: messageBody.message
    };
  }

}

module.exports = new ErrorConverter();
