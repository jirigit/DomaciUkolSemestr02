"use strict";

const { AsyncLocalStorage, AsyncResource } = require("async_hooks");
const GlobalStore = require("./global-store.js");
const BaseError = require("./base-error.js");

/**
 * ThreadLocal alike context store.
 */
class ContextStore {

  /**
   * Creates new context store
   * @param ctxName Context store name.
   * @param fn Function to which should context store be bound.
   * @returns {*} Return value of invoked function.
   */
  static create(ctxName, fn) {
    let asyncLocalStorages = GlobalStore.get("uuAppAsyncLocalStorages");
    let asyncLocalStorage = asyncLocalStorages.get(ctxName);
    if (!asyncLocalStorage) {
      asyncLocalStorage = new AsyncLocalStorage();
      asyncLocalStorages.set(ctxName, asyncLocalStorage);
    } else if (asyncLocalStorage.getStore()) {
      throw new BaseError(`Context "${ctxName}" is already created.`);
    }
    let contextStore = new ContextStore(ctxName);
    let result;
    asyncLocalStorage.run(contextStore, () => {
      result = fn();
    });
    return result;
  }

  /**
   * Returns context store bound to current context.
   * @param ctxName Context store name.
   * @returns {ContextStore|null} Instance of context store or null.
   */
  static get(ctxName) {
    let asyncLocalStorages = GlobalStore.get("uuAppAsyncLocalStorages");
    let asyncLocalStorage = asyncLocalStorages.get(ctxName);
    return asyncLocalStorage ? asyncLocalStorage.getStore() || null : null;
  }

  /**
   * Creates new instance of context store.
   * @private
   */
  constructor(ctxName, parentStore = null) {
    this._ctxName = ctxName;
    this._parentStore = parentStore;
    this._attributes = {};
  }

  /**
   * Stores context attribute.
   * @param key Context attribute name.
   * @param value Context attribute value.
   */
  set(key, value) {
    this._attributes[key] = value;
  }

  /**
   * Returns context attribute.
   * @param key Context attribute name.
   * @returns {*} Context attribute value.
   */
  get(key) {
    if (this._attributes.hasOwnProperty(key)) {
      return this._attributes[key];
    } else if (this._parentStore) {
      return this._parentStore.get(key);
    } else {
      return undefined;
    }
  }

  /**
   * Deletes context attribute.
   * @param key Context attribute name.
   */
  delete(key) {
    delete this._attributes[key];
  }

  /**
   * Binds context store to emitter object. This is necessary to ensure context
   * is visible inside methods invoked by emitter events (like "on data" etc.).
   * @param emitter Emitter object (e.g. stream, socket, etc.)
   */
  bind(emitter) {
    if (emitter.on && !emitter._uuAppContextStoreOriginalOn) {
      emitter._uuAppContextStoreOriginalOn = (emitter.on).bind(emitter);
      emitter.on = (event, callback) => {
        let wrappedCallback;
        if (Number(process.versions.node.split(".")[0]) <= 15) {
          // Workaround for https://github.com/nodejs/node/issues/36051
          // (AsyncResource.bind were not passing parameters to bound function)
          let asyncResource = new AsyncResource(this._ctxName);
          wrappedCallback = function(...args) {
            return asyncResource.runInAsyncScope(callback, emitter, ...args);
          }
        } else {
          wrappedCallback = AsyncResource.bind(callback);
        }
        return emitter._uuAppContextStoreOriginalOn(event, wrappedCallback);
      };
    }
    if (emitter.addEventListener && !emitter._uuAppContextStoreOriginalAddEventListener) {
      emitter._uuAppContextStoreOriginalAddEventListener = (emitter.addEventListener).bind(emitter);
      emitter.addEventListener = (event, callback) => {
        let wrappedCallback;
        if (Number(process.versions.node.split(".")[0]) <= 15) {
          // Workaround for https://github.com/nodejs/node/issues/36051
          // (AsyncResource.bind were not passing parameters to bound function)
          let asyncResource = new AsyncResource(this._ctxName);
          wrappedCallback = function(...args) {
            return asyncResource.runInAsyncScope(callback, emitter, ...args);
          }
        } else {
          wrappedCallback = AsyncResource.bind(callback);
        }
        return emitter._uuAppContextStoreOriginalAddEventListener(event, wrappedCallback);
      };
    }
  }

  /**
   * @deprecated Use {@link bind}.
   */
  bindEmitter(emitter) {
    this.bind(emitter);
  }

  /**
   * Forks context and runs given function.
   * @param fn Function to which should forked context store be bound.
   * @returns {*} Return value of invoked function.
   */
  fork(fn) {
    let asyncLocalStorages = GlobalStore.get("uuAppAsyncLocalStorages");
    let asyncLocalStorage = asyncLocalStorages.get(this._ctxName);
    if (!asyncLocalStorage) {
      throw new BaseError(`Context "${this._ctxName}" is not initialized.`);
    }
    let contextStore = new ContextStore(this._ctxName, this);
    let result;
    asyncLocalStorage.run(contextStore, () => {
      result = fn();
    })
    return result;
  }

}

module.exports = ContextStore;
