"use strict"

const fs = require("fs");
const path = require("path");
const Glob = require("./glob.js");
const BaseError = require("./base-error.js");

let externalModules = [];

/**
 * Finder simplifies resolving configuration files, middleware
 * and startup listeners in node_modules by encapsulating the
 * logic necessary to separate NPM and PNPM folder structures.
 */
class Finder {

  /**
   * Deeply matches the provided pattern against node_modules in the given root
   * and returns an array of matched paths.
   *
   * @param root {string} project root
   * @param globPattern {string} glob pattern to match in individual package folders
   *
   * @example
   * To match a mappings.json, use "config/mappings.json"
   * To match all middleware, use "{src,app}/middleware/*.js"
   *
   *
   * @returns {Array<String>} matched paths
   */
  static findInModules(root = process.cwd(), globPattern = "") {
    root = (root || process.cwd()).replace(/\/$/, "");
    globPattern = (globPattern || "").replace(/^\//, "");

    let result = [];

    if (isPnpm(root)) {
      let partialRes = Glob.find(`node_modules/*/*/*/node_modules/*/${globPattern}`, root);
      if (!partialRes || partialRes.length === 0) {
        // pnpm 5.x changed structure of installed modules
        partialRes = Glob.find(`node_modules/*/*/node_modules/*/${globPattern}`, root);
      }
      result = result.concat(partialRes);
    } else {
      result = Glob.find(`node_modules/*/${globPattern}`, root);
    }

    externalModules.forEach((externalModule) => {
      result = result.concat(this.findInProject(externalModule, globPattern));
    });
    return result;
  }

  /**
   * Performs a search within the application.
   * @param root
   * @param globPattern
   * @returns {*}
   */
  static findInProject(root = process.cwd(), globPattern = "") {
    root = (root || process.cwd()).replace(/\/$/, "");
    globPattern = (globPattern || "").replace(/^\//, "");

    return Glob.find(globPattern, root);
  }

  /**
   * Finds a path to the provided package. Necessary with PNPM since
   * require.resolve() is useless while using PNPM.
   * @param root {string} project root
   * @param name {string} package name
   * @param throwOnMultipleResults {boolean}
   * @returns {Array}
   */
  static findPackage(root = process.cwd(), name, throwOnMultipleResults = true) {
    let matchingExternalModules = externalModules.filter(function(module) {return path.basename(module) === name});
    if (matchingExternalModules && matchingExternalModules.length) {
      if (matchingExternalModules.length !== 1 && throwOnMultipleResults) {
        throw new BaseError(`Invalid number of packages found:\n ${matchingExternalModules.join("\n")}`);
      }
      return matchingExternalModules;
    } else if (isPnpm(root)) {
      root = (root || process.cwd()).replace(/\/$/, "");
      let results = Glob.find(`node_modules/*/*/*/node_modules/${name}`, root);
      if (!results || results.length === 0) {
        // pnpm 5.x changed structure of installed modules
        results = Glob.find(`node_modules/*/*/node_modules/${name}`, root);
      }

      if (results.length !== 1 && throwOnMultipleResults) {
        throw new BaseError(`Invalid number of packages found:\n ${results.join("\n")}`);
      }
      return results;
    } else {
      let tailRegex = new RegExp(`${name}.*$`);
      try {
        return [require.resolve(name).replace(tailRegex, name)];
      } catch (err) {
        return null;
      }
    }
  }

  /**
   * Deeply matches the provided pattern against node_modules in the given root
   * and filters the result so only one config path is returned per module.
   * If module contains /config folder and /src|app/config folder, the second one is prefered.
   *
   * @param root {string} project root
   * @param globPattern {string} glob pattern to match in individual package folders
   *
   * @returns {Array<String>} matched paths
   */
  static findConfigInModules(root, globPattern = "") {
    let paths = Finder.findInModules(root, globPattern);

    const modules = new Map();
    paths.forEach(f => {
      f = f.replace(/\\/g, "/");
      let moduleName;
      f.replace(/node_modules\/([^\/]*)\//g, (m, g1) => {
        moduleName = g1;
      });
      if (!modules.has(moduleName) || f.match(/(app|src)\/config/)) {
        modules.set(moduleName, f);
      }
    });
    return Array.from(modules.values());
  }

  static findConfigInProject(root, globPattern = "") {
    let paths = Finder.findInProject(root, globPattern);

    let configPath;
    paths.forEach(f => {
      f = f.replace(/\\/g, "/");
      if (!configPath || f.match(/(app|src)\/config/)) {
        configPath = f;
      }
    });

    return configPath;
  }

  static injectExternalModule(modulePath) {
    modulePath = modulePath ? modulePath.replace(/\/$/, "") : "";
    if (modulePath && !externalModules.includes(modulePath)) {
      externalModules.push(modulePath);
    }
  }

  static removeExternalModule(modulePath) {
    modulePath = modulePath ? modulePath.replace(/\/$/, "") : "";
    let index = externalModules.indexOf(modulePath);
    if (index > -1) {
      externalModules.splice(index, 1);
    }
  }

  static clearExternalModules() {
    externalModules = [];
  }

}

module.exports = Finder;

function isPnpm(root) {
  return fs.existsSync(path.join(root, "node_modules", ".modules.yaml"));
}
