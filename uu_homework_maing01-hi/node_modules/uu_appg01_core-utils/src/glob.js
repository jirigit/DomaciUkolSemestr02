"use strict";

const Fs = require("fs");
const Path = require("path");

/**
 * The glob component finds all the pathnames matching a specified pattern
 * according to the rules used by the Unix shell. Only subset of rules
 * required by uuAppServer is supported:
 * * "*" Matches 0 or more characters in a single path portion
 * * "?" Matches 1 character
 * * "**" If a "globstar" is alone in a path portion, then it matches zero or more directories and subdirectories searching for matches
 * * "{a,b}" Expression representing one of values separated by comma; Only one expression per path portion is supported
 */
class Glob {

  /**
   * Finds all pathnames matching a specified pattern.
   * @param pattern Glob pattern
   * @param basePath Directory where to start (defaults to current workdir)
   * @returns {String[]} Found pathnames
   */
  static find(pattern, basePath = null) {
    basePath = basePath || process.cwd()
    let rules = this._parsePattern(pattern);
    // List contents of basePath and start searching
    let result = [];
    Fs.readdirSync(basePath).forEach((file) => {
      this._traverse(basePath, file, rules, result);
    });
    return result;
  }

  static _parsePattern(pattern) {
    // Parse pattern:
    // - split by forward slash
    // - remove repeated "**" rule
    // - transform rules
    let rules = [];
    let prevRule = null;
    let buffer = "";
    pattern.replace(/(^(\/|\\)|(\/|\\)$)/g, "").split(/\/|\\/).forEach(rule => {
      if (buffer) {
        buffer += `/${rule}`;
        if (buffer.includes("}")) {
          prevRule = buffer;
          rules.push(this._transformRule(buffer));
          buffer = "";
        }
      } else if (rule.includes("{") && !rule.includes("}")) {
        buffer += rule;
      } else {
        let keep = rule !== "**" || prevRule !== "**";
        prevRule = rule;
        if (keep) {
          rules.push(this._transformRule(rule));
        }
      }
    });
    if (buffer) {
      rules.push(this._transformRule(buffer));
    }
    //"{a".match(/([^\\]|^){/)
    return rules;
  }

  static _transformRule(rule) {
    if (rule == "**") {
      return rule;
    }
    let expandMatch = rule.match(/([^{]*)\{([^\}]*)\}(.*)/);
    if (!expandMatch) {
      return this._toRexExp(rule);
    }
    let [match, prefix, variants, suffix] = expandMatch;
    return variants.split(",").map(variant => {
      if (!variant) {
        return `${prefix}${suffix}`;
      } else if (variant.includes("/") || variant.includes("\\")) {
        return this._parsePattern(`${prefix}${variant}${suffix}`);
      } else {
        return this._transformRule(rule.replace(match, `${prefix}${variant.trim()}${suffix}`));
      }
    });
  }

  static _toRexExp(rule) {
    return new RegExp(`^${rule.
      replace(/([\{\}\[\]\(\)\.\-}])/g, "\\$1").
      replace(/\?/g, ".").
      replace(/\*/g, ".*")
    }$`);
  }

  static _traverse(basePath, file, rules, result) {
    if (Array.isArray(rules[0]) && rules[0].includes("")) {
      // In case of variant rule containing empty rule, skip
      // this rule and continue with next one as alternative
      // search branch.
      let nextRules = rules.slice(1, rules.length);
      this._traverse(basePath, file, nextRules, result);
    }

    if (!this._matches(file, rules[0])) {
      // File does not match, no need to go further
      return;
    }

    // In case of variant rule containing nested path
    // branch traversing using rule set containing this
    // nested path.
    if (Array.isArray(rules[0])) {
      let remainingRules = [];
      rules[0].forEach(rule => {
        if (Array.isArray(rule)) {
          let nestedRules = [...rule, ...rules.slice(1)];
          this._traverse(basePath, file, nestedRules, result);
        } else {
          remainingRules.push(rule);
        }
      });
      if (remainingRules.length === 0) {
        // If all variants of rule were nested paths
        // there is no need to go further.
        return;
      }
      // Replace variant rule with remaining rules
      // (rules not representing nested paths)
      rules = [remainingRules, ...rules.slice(1)];
    }

    let origFullPath = Path.join(basePath, file);
    let fileStats = Fs.lstatSync(origFullPath);
    // In case of symbolic link, resolve real file path
    let realFullPath;
    if (fileStats.isSymbolicLink()) {
      realFullPath = Fs.readlinkSync(origFullPath);
      if (!Path.isAbsolute(realFullPath)) {
        realFullPath = Path.join(basePath, realFullPath);
      }
      fileStats = Fs.lstatSync(realFullPath);
    } else {
      realFullPath = origFullPath;
    }

    // In case we have match and we are checking last rule in path, or we are checking "**" wildcard rule,
    // and there is only one rule left which is also matching (e.g. ["**", "matching.file"]), store found file
    if (rules.length === 1 || (rules.length === 2 && rules[0] === "**" && this._matches(file, rules[1]))) {
      result.push(origFullPath);
    }

    // In case of file, or in case of last non wildcard rule, do not search further
    if (!fileStats.isDirectory() || (rules.length === 1 && rules[0] !== "**")) {
      return;
    }

    // List files in directory
    let files = Fs.readdirSync(realFullPath);
    if (rules[0] === "**") {
      // In case of "**" wildcard we have to continue search also with same rule
      // set, because same pattern might be repeated also in nested structures.
      // So eg. pattern ["**", "matching_directory", "next_rule"] will apply to both:
      //   "matching_directory/anything"
      //   "some/deeper/path/matching_directory/anything"
      files.forEach((file) => {
        this._traverse(origFullPath, file, rules, result);
      });
      // In case we are checking "**" wildcard, there is more rules and directory is
      // matching also next one, continue search which shortened rule set:
      //   ["**", "matching_directory", "next_rule"] => ["next_rule"]
      if (rules.length > 1 && this._matches(file, rules[1])) {
        rules =  rules.slice(2, rules.length);
        files.forEach((file) => {
          this._traverse(origFullPath, file, rules, result);
        });
      }
    } else {
      // In case on non "**" wildcard rule, go one step deeper
      rules = rules.slice(1, rules.length);
      files.forEach((file) => {
        this._traverse(origFullPath, file, rules, result);
      })
    }
  }

  static _matches(file, rule) {
    if (rule === "**") {
      return true;
    } else if (Array.isArray(rule)) {
      return !!rule.find(r => Array.isArray(r) ? this._matches(file, r[0]) : this._matches(file, r));
    } else {
      return file.match(rule);
    }
  }

}

module.exports = Glob;
