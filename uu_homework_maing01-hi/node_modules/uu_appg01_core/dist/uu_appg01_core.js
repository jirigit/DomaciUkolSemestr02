/*!
 * Copyright (c) 2019 Unicorn a.s.
 * All rights reserved.
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("module"));
	else if(typeof define === 'function' && define.amd)
		define("uu_appg01_core", ["module"], factory);
	else if(typeof exports === 'object')
		exports["uu_appg01_core"] = factory(require("module"));
	else
		root["UuApp"] = factory(root["undefined"]);
})(this, (__WEBPACK_EXTERNAL_MODULE_module__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../node_modules/base64-js/index.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}

// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }
  return parts.join('');
}

/***/ }),

/***/ "../../node_modules/buffer/index.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



const base64 = __webpack_require__("../../node_modules/base64-js/index.js");
const ieee754 = __webpack_require__("../../node_modules/ieee754/index.js");
const customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
: null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
  console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}
function typedArraySupport() {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1);
    const proto = {
      foo: function () {
        return 42;
      }
    };
    Object.setPrototypeOf(proto, Uint8Array.prototype);
    Object.setPrototypeOf(arr, proto);
    return arr.foo() === 42;
  } catch (e) {
    return false;
  }
}
Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.buffer;
  }
});
Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.byteOffset;
  }
});
function createBuffer(length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer.prototype);
  return buf;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError('The "string" argument must be of type string. Received type number');
    }
    return allocUnsafe(arg);
  }
  return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192; // not used by this implementation

function from(value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset);
  }
  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value);
  }
  if (value == null) {
    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
  }
  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }
  if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  }
  const valueOf = value.valueOf && value.valueOf();
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length);
  }
  const b = fromObject(value);
  if (b) return b;
  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
  }
  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length);
};

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number');
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"');
  }
}
function alloc(size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  }
  return createBuffer(size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size);
};
function fromString(string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }
  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding);
  }
  const length = byteLength(string, encoding) | 0;
  let buf = createBuffer(length);
  const actual = buf.write(string, encoding);
  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
  }
  return buf;
}
function fromArrayLike(array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0;
  const buf = createBuffer(length);
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf;
}
function fromArrayView(arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView);
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
  }
  return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds');
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds');
  }
  let buf;
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype);
  return buf;
}
function fromObject(obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0;
    const buf = createBuffer(len);
    if (buf.length === 0) {
      return buf;
    }
    obj.copy(buf, 0, 0, len);
    return buf;
  }
  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0);
    }
    return fromArrayLike(obj);
  }
  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data);
  }
}
function checked(length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
  }
  return length | 0;
}
function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
  return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
};

Buffer.compare = function compare(a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }
  if (a === b) return 0;
  let x = a.length;
  let y = b.length;
  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};
Buffer.concat = function concat(list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer.alloc(0);
  }
  let i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }
  const buffer = Buffer.allocUnsafe(length);
  let pos = 0;
  for (i = 0; i < list.length; ++i) {
    let buf = list[i];
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
        buf.copy(buffer, pos);
      } else {
        Uint8Array.prototype.set.call(buffer, buf, pos);
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    } else {
      buf.copy(buffer, pos);
    }
    pos += buf.length;
  }
  return buffer;
};
function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);
  }
  const len = string.length;
  const mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) return 0;

  // Use a for loop to avoid recursion
  let loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
        }

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
  let loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }
  if (end === undefined || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return '';
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return '';
  }
  if (!encoding) encoding = 'utf8';
  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);
      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);
      case 'ascii':
        return asciiSlice(this, start, end);
      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);
      case 'base64':
        return base64Slice(this, start, end);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
  const i = b[n];
  b[n] = b[m];
  b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
  const len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};
Buffer.prototype.swap32 = function swap32() {
  const len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};
Buffer.prototype.swap64 = function swap64() {
  const len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};
Buffer.prototype.toString = function toString() {
  const length = this.length;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
  let str = '';
  const max = exports.INSPECT_MAX_BYTES;
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
  if (this.length > max) str += ' ... ';
  return '<Buffer ' + str + '>';
};
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
}
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength);
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + typeof target);
  }
  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  let x = thisEnd - thisStart;
  let y = end - start;
  const len = Math.min(x, y);
  const thisCopy = this.slice(thisStart, thisEnd);
  const targetCopy = target.slice(start, end);
  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  let indexSize = 1;
  let arrLength = arr.length;
  let valLength = val.length;
  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }
  let i;
  if (dir) {
    let foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      let found = true;
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }
  return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  const remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  const strLen = string.length;
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  let i;
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16);
    if (numberIsNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0;
    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }
  const remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;
  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }
  if (!encoding) encoding = 'utf8';
  let loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);
      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);
      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length);
      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  const res = [];
  let i = start;
  while (i < end) {
    const firstByte = buf[i];
    let codePoint = null;
    let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = '';
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function asciiSlice(buf, start, end) {
  let ret = '';
  end = Math.min(buf.length, end);
  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  let ret = '';
  end = Math.min(buf.length, end);
  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  const len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  let out = '';
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]];
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  const bytes = buf.slice(start, end);
  let res = '';
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
Buffer.prototype.slice = function slice(start, end) {
  const len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start) end = start;
  const newBuf = this.subarray(start, end);
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype);
  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  let val = this[offset];
  let mul = 1;
  let i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }
  let val = this[offset + --byteLength];
  let mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }
  return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  const first = this[offset];
  const last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }
  const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
  const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
  return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  const first = this[offset];
  const last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }
  const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
  const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
  return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  let val = this[offset];
  let mul = 1;
  let i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  let i = byteLength;
  let mul = 1;
  let val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  const val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  const val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  const first = this[offset];
  const last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }
  const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24); // Overflow

  return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  const first = this[offset];
  const last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }
  const val = (first << 24) +
  // Overflow
  this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
  return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  let mul = 1;
  let i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  let i = byteLength - 1;
  let mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  this[offset] = value & 0xff;
  return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset + 3] = value >>> 24;
  this[offset + 2] = value >>> 16;
  this[offset + 1] = value >>> 8;
  this[offset] = value & 0xff;
  return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7);
  let lo = Number(value & BigInt(0xffffffff));
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7);
  let lo = Number(value & BigInt(0xffffffff));
  buf[offset + 7] = lo;
  lo = lo >> 8;
  buf[offset + 6] = lo;
  lo = lo >> 8;
  buf[offset + 5] = lo;
  lo = lo >> 8;
  buf[offset + 4] = lo;
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
  buf[offset + 3] = hi;
  hi = hi >> 8;
  buf[offset + 2] = hi;
  hi = hi >> 8;
  buf[offset + 1] = hi;
  hi = hi >> 8;
  buf[offset] = hi;
  return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    const limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  let i = 0;
  let mul = 1;
  let sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    const limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  let i = byteLength - 1;
  let mul = 1;
  let sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  this[offset + 2] = value >>> 16;
  this[offset + 3] = value >>> 24;
  return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  const len = end - start;
  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
  }
  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0);
      if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code;
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } else if (typeof val === 'boolean') {
    val = Number(val);
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  let i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
    const len = bytes.length;
    if (len === 0) {
      throw new TypeError('The value "' + val + '" is invalid for argument "value"');
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {};
function E(sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor() {
      super();
      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      });

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`;
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack; // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name;
    }
    get code() {
      return sym;
    }
    set code(value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      });
    }
    toString() {
      return `${this.name} [${sym}]: ${this.message}`;
    }
  };
}
E('ERR_BUFFER_OUT_OF_BOUNDS', function (name) {
  if (name) {
    return `${name} is outside of buffer bounds`;
  }
  return 'Attempt to access memory outside buffer bounds';
}, RangeError);
E('ERR_INVALID_ARG_TYPE', function (name, actual) {
  return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E('ERR_OUT_OF_RANGE', function (str, range, input) {
  let msg = `The value of "${str}" is out of range.`;
  let received = input;
  if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
    received = addNumericalSeparator(String(input));
  } else if (typeof input === 'bigint') {
    received = String(input);
    if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
      received = addNumericalSeparator(received);
    }
    received += 'n';
  }
  msg += ` It must be ${range}. Received ${received}`;
  return msg;
}, RangeError);
function addNumericalSeparator(val) {
  let res = '';
  let i = val.length;
  const start = val[0] === '-' ? 1 : 0;
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`;
  }
  return `${val.slice(0, i)}${res}`;
}

// CHECK FUNCTIONS
// ===============

function checkBounds(buf, offset, byteLength) {
  validateNumber(offset, 'offset');
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1));
  }
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : '';
    let range;
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`;
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value);
  }
  checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
  }
}
function boundsError(value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type);
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
  }
  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
  }
  throw new errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value);
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0];
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  let codePoint;
  const length = string.length;
  let leadSurrogate = null;
  const bytes = [];
  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;
        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }
    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  let c, hi, lo;
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  let i;
  for (i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
  // For IE11 support
  return obj !== obj; // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function () {
  const alphabet = '0123456789abcdef';
  const table = new Array(256);
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16;
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j];
    }
  }
  return table;
}();

// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
  throw new Error('BigInt not supported');
}

/***/ }),

/***/ "../../node_modules/ieee754/index.js":
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
  buffer[offset + i - d] |= s * 128;
};

/***/ }),

/***/ "../../node_modules/js-sha1/src/sha1.js":
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 * [js-sha1]{@link https://github.com/emn178/js-sha1}
 *
 * @version 0.6.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var root = typeof window === 'object' ? window : {};
  var NODE_JS = !root.JS_SHA1_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = __webpack_require__.g;
  }
  var COMMON_JS = !root.JS_SHA1_NO_COMMON_JS && "object" === 'object' && module.exports;
  var AMD =  true && __webpack_require__.amdO;
  var HEX_CHARS = '0123456789abcdef'.split('');
  var EXTRA = [-2147483648, 8388608, 32768, 128];
  var SHIFT = [24, 16, 8, 0];
  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'arrayBuffer'];
  var blocks = [];
  var createOutputMethod = function (outputType) {
    return function (message) {
      return new Sha1(true).update(message)[outputType]();
    };
  };
  var createMethod = function () {
    var method = createOutputMethod('hex');
    if (NODE_JS) {
      method = nodeWrap(method);
    }
    method.create = function () {
      return new Sha1();
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createOutputMethod(type);
    }
    return method;
  };
  var nodeWrap = function (method) {
    var crypto = eval("require('crypto')");
    var Buffer = eval("require('buffer').Buffer");
    var nodeMethod = function (message) {
      if (typeof message === 'string') {
        return crypto.createHash('sha1').update(message, 'utf8').digest('hex');
      } else if (message.constructor === ArrayBuffer) {
        message = new Uint8Array(message);
      } else if (message.length === undefined) {
        return method(message);
      }
      return crypto.createHash('sha1').update(new Buffer(message)).digest('hex');
    };
    return nodeMethod;
  };
  function Sha1(sharedMemory) {
    if (sharedMemory) {
      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      this.blocks = blocks;
    } else {
      this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }
    this.h0 = 0x67452301;
    this.h1 = 0xEFCDAB89;
    this.h2 = 0x98BADCFE;
    this.h3 = 0x10325476;
    this.h4 = 0xC3D2E1F0;
    this.block = this.start = this.bytes = this.hBytes = 0;
    this.finalized = this.hashed = false;
    this.first = true;
  }
  Sha1.prototype.update = function (message) {
    if (this.finalized) {
      return;
    }
    var notString = typeof message !== 'string';
    if (notString && message.constructor === root.ArrayBuffer) {
      message = new Uint8Array(message);
    }
    var code,
      index = 0,
      i,
      length = message.length || 0,
      blocks = this.blocks;
    while (index < length) {
      if (this.hashed) {
        this.hashed = false;
        blocks[0] = this.block;
        blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      }
      if (notString) {
        for (i = this.start; index < length && i < 64; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < 64; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
            blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
          }
        }
      }
      this.lastByteIndex = i;
      this.bytes += i - this.start;
      if (i >= 64) {
        this.block = blocks[16];
        this.start = i - 64;
        this.hash();
        this.hashed = true;
      } else {
        this.start = i;
      }
    }
    if (this.bytes > 4294967295) {
      this.hBytes += this.bytes / 4294967296 << 0;
      this.bytes = this.bytes % 4294967296;
    }
    return this;
  };
  Sha1.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks,
      i = this.lastByteIndex;
    blocks[16] = this.block;
    blocks[i >> 2] |= EXTRA[i & 3];
    this.block = blocks[16];
    if (i >= 56) {
      if (!this.hashed) {
        this.hash();
      }
      blocks[0] = this.block;
      blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
    }
    blocks[14] = this.hBytes << 3 | this.bytes >>> 29;
    blocks[15] = this.bytes << 3;
    this.hash();
  };
  Sha1.prototype.hash = function () {
    var a = this.h0,
      b = this.h1,
      c = this.h2,
      d = this.h3,
      e = this.h4;
    var f,
      j,
      t,
      blocks = this.blocks;
    for (j = 16; j < 80; ++j) {
      t = blocks[j - 3] ^ blocks[j - 8] ^ blocks[j - 14] ^ blocks[j - 16];
      blocks[j] = t << 1 | t >>> 31;
    }
    for (j = 0; j < 20; j += 5) {
      f = b & c | ~b & d;
      t = a << 5 | a >>> 27;
      e = t + f + e + 1518500249 + blocks[j] << 0;
      b = b << 30 | b >>> 2;
      f = a & b | ~a & c;
      t = e << 5 | e >>> 27;
      d = t + f + d + 1518500249 + blocks[j + 1] << 0;
      a = a << 30 | a >>> 2;
      f = e & a | ~e & b;
      t = d << 5 | d >>> 27;
      c = t + f + c + 1518500249 + blocks[j + 2] << 0;
      e = e << 30 | e >>> 2;
      f = d & e | ~d & a;
      t = c << 5 | c >>> 27;
      b = t + f + b + 1518500249 + blocks[j + 3] << 0;
      d = d << 30 | d >>> 2;
      f = c & d | ~c & e;
      t = b << 5 | b >>> 27;
      a = t + f + a + 1518500249 + blocks[j + 4] << 0;
      c = c << 30 | c >>> 2;
    }
    for (; j < 40; j += 5) {
      f = b ^ c ^ d;
      t = a << 5 | a >>> 27;
      e = t + f + e + 1859775393 + blocks[j] << 0;
      b = b << 30 | b >>> 2;
      f = a ^ b ^ c;
      t = e << 5 | e >>> 27;
      d = t + f + d + 1859775393 + blocks[j + 1] << 0;
      a = a << 30 | a >>> 2;
      f = e ^ a ^ b;
      t = d << 5 | d >>> 27;
      c = t + f + c + 1859775393 + blocks[j + 2] << 0;
      e = e << 30 | e >>> 2;
      f = d ^ e ^ a;
      t = c << 5 | c >>> 27;
      b = t + f + b + 1859775393 + blocks[j + 3] << 0;
      d = d << 30 | d >>> 2;
      f = c ^ d ^ e;
      t = b << 5 | b >>> 27;
      a = t + f + a + 1859775393 + blocks[j + 4] << 0;
      c = c << 30 | c >>> 2;
    }
    for (; j < 60; j += 5) {
      f = b & c | b & d | c & d;
      t = a << 5 | a >>> 27;
      e = t + f + e - 1894007588 + blocks[j] << 0;
      b = b << 30 | b >>> 2;
      f = a & b | a & c | b & c;
      t = e << 5 | e >>> 27;
      d = t + f + d - 1894007588 + blocks[j + 1] << 0;
      a = a << 30 | a >>> 2;
      f = e & a | e & b | a & b;
      t = d << 5 | d >>> 27;
      c = t + f + c - 1894007588 + blocks[j + 2] << 0;
      e = e << 30 | e >>> 2;
      f = d & e | d & a | e & a;
      t = c << 5 | c >>> 27;
      b = t + f + b - 1894007588 + blocks[j + 3] << 0;
      d = d << 30 | d >>> 2;
      f = c & d | c & e | d & e;
      t = b << 5 | b >>> 27;
      a = t + f + a - 1894007588 + blocks[j + 4] << 0;
      c = c << 30 | c >>> 2;
    }
    for (; j < 80; j += 5) {
      f = b ^ c ^ d;
      t = a << 5 | a >>> 27;
      e = t + f + e - 899497514 + blocks[j] << 0;
      b = b << 30 | b >>> 2;
      f = a ^ b ^ c;
      t = e << 5 | e >>> 27;
      d = t + f + d - 899497514 + blocks[j + 1] << 0;
      a = a << 30 | a >>> 2;
      f = e ^ a ^ b;
      t = d << 5 | d >>> 27;
      c = t + f + c - 899497514 + blocks[j + 2] << 0;
      e = e << 30 | e >>> 2;
      f = d ^ e ^ a;
      t = c << 5 | c >>> 27;
      b = t + f + b - 899497514 + blocks[j + 3] << 0;
      d = d << 30 | d >>> 2;
      f = c ^ d ^ e;
      t = b << 5 | b >>> 27;
      a = t + f + a - 899497514 + blocks[j + 4] << 0;
      c = c << 30 | c >>> 2;
    }
    this.h0 = this.h0 + a << 0;
    this.h1 = this.h1 + b << 0;
    this.h2 = this.h2 + c << 0;
    this.h3 = this.h3 + d << 0;
    this.h4 = this.h4 + e << 0;
  };
  Sha1.prototype.hex = function () {
    this.finalize();
    var h0 = this.h0,
      h1 = this.h1,
      h2 = this.h2,
      h3 = this.h3,
      h4 = this.h4;
    return HEX_CHARS[h0 >> 28 & 0x0F] + HEX_CHARS[h0 >> 24 & 0x0F] + HEX_CHARS[h0 >> 20 & 0x0F] + HEX_CHARS[h0 >> 16 & 0x0F] + HEX_CHARS[h0 >> 12 & 0x0F] + HEX_CHARS[h0 >> 8 & 0x0F] + HEX_CHARS[h0 >> 4 & 0x0F] + HEX_CHARS[h0 & 0x0F] + HEX_CHARS[h1 >> 28 & 0x0F] + HEX_CHARS[h1 >> 24 & 0x0F] + HEX_CHARS[h1 >> 20 & 0x0F] + HEX_CHARS[h1 >> 16 & 0x0F] + HEX_CHARS[h1 >> 12 & 0x0F] + HEX_CHARS[h1 >> 8 & 0x0F] + HEX_CHARS[h1 >> 4 & 0x0F] + HEX_CHARS[h1 & 0x0F] + HEX_CHARS[h2 >> 28 & 0x0F] + HEX_CHARS[h2 >> 24 & 0x0F] + HEX_CHARS[h2 >> 20 & 0x0F] + HEX_CHARS[h2 >> 16 & 0x0F] + HEX_CHARS[h2 >> 12 & 0x0F] + HEX_CHARS[h2 >> 8 & 0x0F] + HEX_CHARS[h2 >> 4 & 0x0F] + HEX_CHARS[h2 & 0x0F] + HEX_CHARS[h3 >> 28 & 0x0F] + HEX_CHARS[h3 >> 24 & 0x0F] + HEX_CHARS[h3 >> 20 & 0x0F] + HEX_CHARS[h3 >> 16 & 0x0F] + HEX_CHARS[h3 >> 12 & 0x0F] + HEX_CHARS[h3 >> 8 & 0x0F] + HEX_CHARS[h3 >> 4 & 0x0F] + HEX_CHARS[h3 & 0x0F] + HEX_CHARS[h4 >> 28 & 0x0F] + HEX_CHARS[h4 >> 24 & 0x0F] + HEX_CHARS[h4 >> 20 & 0x0F] + HEX_CHARS[h4 >> 16 & 0x0F] + HEX_CHARS[h4 >> 12 & 0x0F] + HEX_CHARS[h4 >> 8 & 0x0F] + HEX_CHARS[h4 >> 4 & 0x0F] + HEX_CHARS[h4 & 0x0F];
  };
  Sha1.prototype.toString = Sha1.prototype.hex;
  Sha1.prototype.digest = function () {
    this.finalize();
    var h0 = this.h0,
      h1 = this.h1,
      h2 = this.h2,
      h3 = this.h3,
      h4 = this.h4;
    return [h0 >> 24 & 0xFF, h0 >> 16 & 0xFF, h0 >> 8 & 0xFF, h0 & 0xFF, h1 >> 24 & 0xFF, h1 >> 16 & 0xFF, h1 >> 8 & 0xFF, h1 & 0xFF, h2 >> 24 & 0xFF, h2 >> 16 & 0xFF, h2 >> 8 & 0xFF, h2 & 0xFF, h3 >> 24 & 0xFF, h3 >> 16 & 0xFF, h3 >> 8 & 0xFF, h3 & 0xFF, h4 >> 24 & 0xFF, h4 >> 16 & 0xFF, h4 >> 8 & 0xFF, h4 & 0xFF];
  };
  Sha1.prototype.array = Sha1.prototype.digest;
  Sha1.prototype.arrayBuffer = function () {
    this.finalize();
    var buffer = new ArrayBuffer(20);
    var dataView = new DataView(buffer);
    dataView.setUint32(0, this.h0);
    dataView.setUint32(4, this.h1);
    dataView.setUint32(8, this.h2);
    dataView.setUint32(12, this.h3);
    dataView.setUint32(16, this.h4);
    return buffer;
  };
  var exports = createMethod();
  if (COMMON_JS) {
    module.exports = exports;
  } else {
    root.sha1 = exports;
    if (AMD) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return exports;
      }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
  }
})();

/***/ }),

/***/ "../../node_modules/uu_appg01_core-authentication/src/application-identity.js":
/***/ ((module) => {

"use strict";


/**
 * The identity of an application.
 * @deprecated Use ClientIdentity
 */
class ApplicationIdentity {
  /**
   * Creates new instance of application identity.
   * @param {String} uuIdentity Unique identifier of the client application
   * @param {Object} data Additional identity data.
   * @param {String} data.name Name of the application
   * @param {String} data.code Code of the application
   * @private
   */
  constructor(uuIdentity, data = {}) {
    if (typeof data === "string") {
      this._code = uuIdentity;
      this._name = data;
    } else if (data) {
      this._uuIdentity = uuIdentity;
      this._code = data.code;
      this._name = data.name;
    }
  }

  /**
   * Returns unique identifier of the client application.
   * @returns {String|null} Unique identifier of the client application
   */
  getUuIdentity() {
    return this._uuIdentity;
  }

  /**
   * Returns unique identifier of the application.
   * @returns {String} String representation of the unique identifier
   */
  getCode() {
    return this._code;
  }

  /**
   * Returns name of the application.
   * @returns {String|null} Name of the application
   */
  getName() {
    return this._name;
  }
}
module.exports = ApplicationIdentity;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-authentication/src/authentication-service.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  BaseError,
  Config
} = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");
const DEFAULT_PROVIDER_PARAM = "uu_app_default_authn_provider";

/**
 * Component encapsulating authentication process.
 */
class AuthenticationService {
  /**
   * @returns {string} Name of configuration parameter for accessing default realization of authentication service.
   */
  static get DEFAULT_PROVIDER_PARAM() {
    return DEFAULT_PROVIDER_PARAM;
  }

  /**
   * Authenticates user.
   * @param {*} credentials User credentials to be verified
   * @param {String|null} scope Scope (single value or array) representing functionality to be invoked within session.
   * @param {Object|null} opts Authentication options.
   * @returns {Promise<Session>} User session for passed user credentials.
   * @throws {InvalidCredentials} In case credentials are not valid.
   * @throws {AuthenticationError} In case authentication fails.
   */
  static async authenticate(credentials, scope = null, opts = {}) {
    let realization = AuthenticationService.get();
    return await realization.authenticate(credentials, scope, opts);
  }

  /**
   * Authenticates system identity.
   * Awid system identity is used if called within awid context, otherwise asid system identity is used.
   * @param {String|null} scope Scope (single value or array) representing functionality to be invoked within session.
   * @param {Object|null} opts Authentication options.
   * @returns {Promise<Session>} System identity session for asid or awid resolved from the request context.
   * @throws {InvalidCredentials} In case credentials are not valid.
   * @throws {AuthenticationError} In case authentication fails.
   */
  static async authenticateSystemIdentity(scope = null, opts = {}) {
    let realization = AuthenticationService.get();
    return await realization.authenticateSystemIdentity(scope, opts);
  }

  /**
   * Returns particular realization of authentication service.
   * @param {String} realizationName Name of required authentication service realization
   * @returns {*} Object responding to "authenticate" method
   * @throws {BaseError} In case realization with given name does not exist
   */
  static get(realizationName = null) {
    let name = realizationName || Config.get(DEFAULT_PROVIDER_PARAM);
    if (!name) {
      throw new BaseError(`Unable to get default authentication provider. Configuration parameter ${DEFAULT_PROVIDER_PARAM} is not set.`);
    }
    let realization = AuthenticationService._realizations[name];
    if (realization) {
      return realization;
    } else {
      throw new BaseError(`There is no authentication provider with name "${name}".`);
    }
  }

  /**
   * Registers custom realization of authentication service.
   * @param {String} realizationName Custom authentication service realization name
   * @param {*} realization Object responding to "authenticate" method
   * @private
   */
  static _register(realizationName, realization) {
    AuthenticationService._realizations[realizationName] = realization;
  }
}
AuthenticationService._realizations = {};
module.exports = AuthenticationService;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-authentication/src/client-identity.js":
/***/ ((module) => {

"use strict";


/**
 * The identity of a client application.
 */
class ClientIdentity {
  /**
   * Creates new instance of client application identity.
   * @param {String} uuIdentity Unique identifier of the client application
   * @param {Object} data Additional identity data.
   * @param {String} data.uri Registered URI of client application
   * @param {String} data.product Client application product
   * @param {String} data.vendor Client application vendor
   * @param {String} data.app Client application name
   * @param {String} data.subApp Client application subapp
   * @param {String} data.asid Client application asid
   * @param {String} data.awid Client application awid
   * @param {String} data.type Type of the client identity
   * @param {String} data.authenticationLevelOfAssurance String representation of the means of client identity authentication
   * @param {UuAppKey} data.uuAppKey uuAppKey representing the system identity. Set only if the identity type is system identity.
   *
   * @private
   */
  constructor(uuIdentity, data = {}) {
    this._uuIdentity = uuIdentity;
    if (data) {
      this._uri = data.uri;
      this._product = data.product;
      this._vendor = data.vendor;
      this._app = data.app;
      this._subApp = data.subApp;
      this._asid = data.asid;
      this._awid = data.awid;
      this._type = data.type;
      this._authenticationLevelOfAssurance = data.authenticationLevelOfAssurance;
      this._uuAppKey = data.uuAppKey;
    }
  }

  /**
   * Returns unique identifier of the client application.
   * @returns {String|null} Unique identifier of the client application
   */
  getUuIdentity() {
    return this._uuIdentity;
  }

  /**
   * Returns registered URI of client application.
   * @returns {String|null} Registered URI of client application
   */
  getUri() {
    return this._uri;
  }

  /**
   * Returns client application product.
   * @returns {String|null} Client application product
   */
  getProduct() {
    return this._product;
  }

  /**
   * Returns client application vendor.
   * @returns {String|null} Client application vendor
   */
  getVendor() {
    return this._vendor;
  }

  /**
   * Returns client application name.
   * @returns {String|null} Client application name
   */
  getApp() {
    return this._app;
  }

  /**
   * Returns client application subapp.
   * @returns {String|null} Client application subapp
   */
  getSubApp() {
    return this._subApp;
  }

  /**
   * Returns client application asid.
   * @returns {String|null} Client application asid
   */
  getAsid() {
    return this._asid;
  }

  /**
   * Returns client application awid.
   * @returns {String|null} Client application awid
   */
  getAwid() {
    return this._awid;
  }

  /**
   * Returns type of the client identity.
   * @returns {String|null} Type of the client identity
   */
  getType() {
    return this._type;
  }

  /**
   * Returns the means of authentication (type of credentials) of client identity.
   * @returns {String} String representation of the means of authentication
   */
  getAuthenticationLevelOfAssurance() {
    return this._authenticationLevelOfAssurance;
  }

  /**
   * Returns uuAppKey representation of system identity.
   * @returns {UuAppKey} uuAppKey representation of the system identity
   */
  getUuAppKey() {
    return this._uuAppKey;
  }
}
module.exports = ClientIdentity;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-authentication/src/errors/authentication-error.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  BaseError
} = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");

/**
 * Base error of all authentication errors.
 */
class AuthenticationError extends BaseError {}
module.exports = AuthenticationError;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-authentication/src/errors/invalid-credentials.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AuthenticationError = __webpack_require__("../../node_modules/uu_appg01_core-authentication/src/errors/authentication-error.js");

/**
 * Error raised by AuthenticationService in case provided
 * credentials are not valid.
 */
class InvalidCredentials extends AuthenticationError {}
module.exports = InvalidCredentials;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-authentication/src/errors/untrusted-credentials.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AuthenticationError = __webpack_require__("../../node_modules/uu_appg01_core-authentication/src/errors/authentication-error.js");

/**
 * Error raised in case session does not meet required criteria
 * (e.g. login too old or authentication level of assurance not met )
 */
class UntrustedCredentials extends AuthenticationError {
  /**
   * Creates new instance of error.
   * @param {Session} session Instance of session not matching requried criteria
   * @param {string} message Error message
   * @param {Error} cause Error cause
   */
  constructor(session, message, cause = null) {
    if (typeof session === "string") {
      cause = message;
      message = session;
      session = null;
    }
    super(message, cause);
    this._session = session;
  }

  /**
   * Returns instance of untrusted session.
   * @returns {Session} Instance of untrusted session
   */
  getSession() {
    return this._session;
  }
}
module.exports = UntrustedCredentials;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-authentication/src/errors/uu-app-key-errors.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {
  BaseError
} = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");
const ERROR_PREFIX = "uu-app-key/";
class InvalidAppKey extends BaseError {
  constructor(invalidKey) {
    super(`The AppKey (${invalidKey}) is not valid.`, null);
    this.code = `${ERROR_PREFIX}invalidAppKey`;
  }
}
class InconsistentAppKey extends BaseError {
  constructor(partName, partValue) {
    super(`The AppKey is not valid. The ${partName} part (${partValue}) is not valid. Null value was expected because some AppKey part before was null.`, null);
    this.code = `${ERROR_PREFIX}inconsistentAppKey`;
  }
}
class InvalidAppKeyPart extends BaseError {
  constructor(partName, partValue) {
    super(`The AppKey is not valid. The ${partName} part (${partValue}) is not valid.`, null);
    this.code = `${ERROR_PREFIX}invalidAppKeyPart`;
  }
}
module.exports = {
  InvalidAppKey,
  InconsistentAppKey,
  InvalidAppKeyPart
};

/***/ }),

/***/ "../../node_modules/uu_appg01_core-authentication/src/identity.js":
/***/ ((module) => {

"use strict";


/**
 * The identity of a user.
 */
class Identity {
  /**
   * Creates new instance of user identity.
   * @param {String} uuIdentity Unique identifier of the user
   * @param {Object} data Additional identity data.
   * @param {String} data.name Name of the identity
   * @param {String} data.type Type of the identity
   * @param {number} data.levelOfAssurance Numeric representation of identity verification level
   * @param {String} data.authenticationLevelOfAssurance String representation of the means of identity authentication
   * @param {UuAppKey} data.uuAppKey uuAppKey representing the system identity. Set only if the identity type is system identity.
   * @private
   */
  constructor(uuIdentity, data) {
    this._uuIdentity = uuIdentity;
    if (typeof data === "string") {
      this._name = data;
    } else if (data) {
      this._name = data.name;
      this._type = data.type;
      this._accountType = data.accountType;
      this._levelOfAssurance = data.levelOfAssurance;
      this._authenticationLevelOfAssurance = data.authenticationLevelOfAssurance;
      this._uuAppKey = data.uuAppKey;
    }
  }

  /**
   * Returns a unique identifier of the user.
   * @returns {String} String representation of the unique identifier of the user
   */
  getUuIdentity() {
    return this._uuIdentity;
  }

  /**
   * Returns the name of the user.
   * @returns {String|null} User's name
   */
  getName() {
    return this._name;
  }

  /**
   * Type of the identity.
   * @returns {String|null} Type of the identity
   */
  getType() {
    return this._type;
  }

  /**
   * Type of the identity account.
   * @returns {String|null} Type of identityAccount
   */
  getAccountType() {
    return this._accountType;
  }

  /**
   * Numeric representation of identity verification level.
   * @returns {number|null} Numeric representation of identity verification level
   */
  getLevelOfAssurance() {
    return this._levelOfAssurance;
  }

  /**
   * Returns the means of authentication (type of credentials) of the identity.
   * @returns {String} String representation of the means of authentication
   */
  getAuthenticationLevelOfAssurance() {
    return this._authenticationLevelOfAssurance;
  }

  /**
   * Returns uuAppKey representation of system identity.
   * @returns {UuAppKey|null} uuAppKey representation of the system identity. null if type of identity is not system identity.
   */
  getUuAppKey() {
    return this._uuAppKey;
  }

  // TODO Only for backward compatibility, drop for "1.0.0" release
  /**
   * Only for backward compatibility.
   * @private
   */
  getUUIdentity() {
    return this.getUuIdentity();
  }
}
module.exports = Identity;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-authentication/src/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = {
  get AuthenticationService() {
    return __webpack_require__("../../node_modules/uu_appg01_core-authentication/src/authentication-service.js");
  },
  get Session() {
    return __webpack_require__("../../node_modules/uu_appg01_core-authentication/src/session.js");
  },
  get Identity() {
    return __webpack_require__("../../node_modules/uu_appg01_core-authentication/src/identity.js");
  },
  get ClientIdentity() {
    return __webpack_require__("../../node_modules/uu_appg01_core-authentication/src/client-identity.js");
  },
  get ApplicationIdentity() {
    return __webpack_require__("../../node_modules/uu_appg01_core-authentication/src/application-identity.js");
  },
  get UuAppKey() {
    return __webpack_require__("../../node_modules/uu_appg01_core-authentication/src/uu-app-key.js");
  },
  get TokenSanitizer() {
    return __webpack_require__("../../node_modules/uu_appg01_core-authentication/src/token-sanitizer.js");
  },
  get AuthenticationError() {
    return __webpack_require__("../../node_modules/uu_appg01_core-authentication/src/errors/authentication-error.js");
  },
  get InvalidCredentials() {
    return __webpack_require__("../../node_modules/uu_appg01_core-authentication/src/errors/invalid-credentials.js");
  },
  get UntrustedCredentials() {
    return __webpack_require__("../../node_modules/uu_appg01_core-authentication/src/errors/untrusted-credentials.js");
  },
  get uuAppKeyErrors() {
    return __webpack_require__("../../node_modules/uu_appg01_core-authentication/src/errors/uu-app-key-errors.js");
  }
};

/***/ }),

/***/ "../../node_modules/uu_appg01_core-authentication/src/session.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const UntrustedCredentials = __webpack_require__("../../node_modules/uu_appg01_core-authentication/src/errors/untrusted-credentials.js");

/**
 * Object providing result of authentication process. It holds information about the user's identity, the information
 * about the application and also attributes related to authentication process itself.
 */
class Session {
  /**
   * Creates new instance of session.
   * @param {Object} data Authentication data.
   * @param {String} data.id Unique session instance ID.
   * @param {String} data.authenticationId Unique ID of authentication process (in whose scope was this session instance created).
   * @param {Date} data.authenticationTime Time of authentication process invocation (in whose scope was this session instance created).
   * @param {number} data.authenticationLevelOfAssurance Numeric representation of the means of authentication
   * @param {Identity} data.identity User identity
   * @param {ApplicationIdentity} data.applicationIdentity Application identity (deprecated, use clientIdentity)
   * @param {ClientIdentity} data.clientIdentity Client Application identity
   * @param {Object} data.attributes Implementation specific session attributes
   * @private
   */
  constructor(data = {}) {
    this._id = data.id || null;
    this._authenticationId = data.authenticationId || null;
    this._authenticationTime = data.authenticationTime || new Date();
    this._authenticationLevelOfAssurance = data.authenticationLevelOfAssurance ? parseInt(data.authenticationLevelOfAssurance) : 0;
    this._identity = data.identity;
    this._actorIdentity = data.actorIdentity;
    this._clientIdentity = data.clientIdentity;
    this._applicationIdentity = data.applicationIdentity;
    this._attributes = data.attributes || {};
    this._authenticated = !!(this._authenticationLevelOfAssurance && (this._identity || this._applicationIdentity || this._clientIdentity));
  }

  /**
   * Returns unique session instance ID.
   * @returns {String|null} Session ID.
   */
  getId() {
    return this._id;
  }

  /**
   * Returns unique ID of authentication process (in whose scope was this session instance created).
   * @returns {String|null} Unique ID of global session
   */
  getAuthenticationId() {
    return this._authenticationId;
  }

  /**
   * Returns the time of authentication process invocation (in whose scope was this session instance created).
   * @returns {Date|null} Time of authentication
   */
  getAuthenticationTime() {
    return this._authenticationTime;
  }

  /**
   * Returns the means of authentication (type of credentials) for current user.
   * @returns {number} Numeric representation of the means of authentication
   */
  getAuthenticationLevelOfAssurance() {
    return this._authenticationLevelOfAssurance;
  }

  /**
   * Returns user identity.
   * @returns {Identity} User identity
   */
  getIdentity() {
    return this._identity;
  }

  /**
   * Returns actor user identity.
   * @returns {Identity} Actor user identity
   */
  getActorIdentity() {
    return this._actorIdentity;
  }

  /**
   * Returns client application identity.
   * @returns {ClientIdentity|null} Client application identity
   */
  getClientIdentity() {
    return this._clientIdentity;
  }

  /**
   * Returns application identity.
   * @returns {ApplicationIdentity|null} Application identity
   * @deprecated Use getClientIdentity.
   */
  getApplicationIdentity() {
    return this._applicationIdentity;
  }

  /**
   * Returns true if the user is not anonymous.
   * @returns {boolean} True if user is not anonymous
   */
  isAuthenticated() {
    return !!this._authenticated;
  }

  /**
   * Returns call token scope based on URI of invoked command. This value may be then used for obtaining of
   * actual call token provided by method getCallToken.
   * @param {String|URI} uri URI of command to be invoked (for which to obtain call token scope).
   * @param {Object} opts Call token options.
   * @param {String|null} otps.scopeMode Scope mode (one of [useCase, allUseCases, none]).
   * @returns {Promise<String>} Call token scope
   */
  async getCallTokenScope(uri, opts = {}) {
    // Default implementation only removes parameters from given URI.
    return uri ? uri.toString().split("?")[0] : uri;
  }

  /**
   * Returns token to be used by client to call functionality provided by other application server.
   * @param {String|URI} scope Scope (single value or array) representing functionality to be invoked with token.
   * @param {Object} opts Call token options.
   * @param {boolean|null} otps.useTokenExchange Flag if call should use new token (derived from existing) or directly reuse existing one.
   * @param {boolean|null} opts.excludeAuthenticationType Flag if call token should be returned without authentication type prefix.
   * @param {boolean|null} opts.callTokenType Variant of call token (possible values depends on actual authentication implementation).
   * @returns {Promise<String>} Call token
   */
  async getCallToken(scope, opts = {}) {
    throw new Error("Method not implemented.");
  }

  /**
   * Allows to switch to another user (switch is allowed only in case there is existing actor-impersonation association
   * between current user and user to switch to).
   * @param {String} uuIdentity Identification of user to switch to.
   * @param {String|URI|null} scope Scope representing functionality to be invoked within new session.
   * @param {Object|null} opts User switch options.
   * @param {boolean|null} opts.callTokenType Variant of call token (possible values depends on actual authentication implementation).
   * @returns {Promise<Session>} User session.
   */
  async actAs(uuIdentity, scope = null, opts = {}) {
    throw new Error("Method not implemented.");
  }

  /**
   * Checks if processed authentication conforms to required constraints.
   * @param {Object} constraints Session constraint object
   * @param {number|null} constraints.maxAuthenticationAge Maximum age of authentication in seconds
   * @param {number|null} constraints.minAuthenticationLevelOfAssurance Minimum required level of assurance
   * @throws {UntrustedCredentials} In case processed authentication does not conform to required constraints.
   */
  assertTrustiness(constraints = {}) {
    let mla = constraints.minAuthenticationLevelOfAssurance;
    if (mla != undefined && mla != null && mla > this.getAuthenticationLevelOfAssurance()) {
      throw new UntrustedCredentials(this, "Minimum login level of assurance not met.");
    }
    let maxAge = constraints.maxAuthenticationAge;
    if (maxAge != undefined && maxAge != null) {
      let epochAuthTime = this.getAuthenticationTime().getTime() / 1000;
      let epochCurTime = Date.now / 1000;
      if (epochAuthTime + maxAge < epochCurTime) {
        throw new UntrustedCredentials(this, "User re-authentication required.");
      }
    }
  }

  /**
   * Returns custom session attribute (actual attributes are dependant on particular session instance based on
   * technology used for authentication process)
   * @param {String} name Name of session attribute
   * @returns {*} Attribute value
   */
  getAttribute(name) {
    return this._attributes[name];
  }

  /**
   * Performs the log out of the user.
   */
  close() {
    this._authenticated = false;
  }

  /**
   * Serializes user and client data. Does not contain ids so that result can
   * be used for comparison between multiple instances of session.
   * @returns {String}
   */
  toJSON() {
    return {
      identity: this._identity,
      clientIdentity: this._clientIdentity,
      applicationIdentity: this._applicationIdentity
    };
  }
}
module.exports = Session;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-authentication/src/token-sanitizer.js":
/***/ ((module) => {

"use strict";


const AUTH_HEADER_REGEX = /^([Bb]asic|[Bb]earer)[ ](.+)$/;
const QUERY_PARAM_REGEX = /[?&](access_token|id_token)=([^&]+)/;
const JWT_TOKEN_REGEX = /^[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+$/;
class TokenSanitizer {
  static processToken(token) {
    if (!token) {
      return token;
    } else if (token.match(JWT_TOKEN_REGEX)) {
      return `...${token.split(".")[1]}...`;
    } else {
      let partLength = Math.ceil(token.length / 5);
      return `${token.substring(0, partLength)}...${token.substring(token.length - partLength)}`;
    }
  }
  static processHeader(header) {
    let match;
    if (!header || !(match = header.match(AUTH_HEADER_REGEX))) {
      return header;
    }
    let type = match[1];
    let token = match[2];
    return `${type} ${this.processToken(token)}`;
  }
  static processUri(uri) {
    let match;
    if (!uri || !(match = uri.match(QUERY_PARAM_REGEX))) {
      return uri;
    }
    let param = match[1];
    let token = match[2];
    return uri.replace(`${param}=${token}`, `${param}=${this.processToken(token)}`);
  }
}
module.exports = TokenSanitizer;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-authentication/src/uu-app-key.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Errors = __webpack_require__("../../node_modules/uu_appg01_core-authentication/src/errors/uu-app-key-errors.js");
const APP_KEY_URN_PREFIX = "urn:uuappkey:";
const IDENTIFIER = "[a-zA-Z0-9_]";
const VENDOR = `(${IDENTIFIER}{1,32})`;
const APP = `(${IDENTIFIER}{1,32})`;
const SUB_APP = `(${IDENTIFIER}{1,32})`;
const ASID = `(${IDENTIFIER}{1,32})`;
const AWID = `(${IDENTIFIER}{1,32})`;
const APP_KEY_REGEXP = new RegExp(`^(?:${APP_KEY_URN_PREFIX})?${VENDOR}(?:\\-(?:${APP}(?:\\-(?:${SUB_APP}(?:\\/(?:${ASID}(?:\\-(?:${AWID})?)?)?)?)?)?)?)?$`);

/**
 * Class is used for designing relations. Holds information about product, asid and awid.
 * The value is entered from the left (right-side parts can be left empty).
 *
 * <pre>Format: {vendor}-{app}-{subApp}/{asid}-{awid}
 *
 * Valid values:
 * {vendor}-{app}-{subApp}/{awid}
 * {vendor}-{app}-{subApp}
 * {vendor}-{app}
 * {vendor}</pre>
 */
class UuAppKey {
  /**
   * New instance of UuAppKey should be created using {@link UuAppKey.parse} or {@link UuAppKey.valueOf}.
   * @private
   */
  constructor(vendor, app = null, subApp = null, asid = null, awid = null) {
    this._vendor = vendor;
    this._product = vendor;
    this._app = app;
    if (app) {
      this._product += `-${app}`;
    }
    this._subApp = subApp;
    if (subApp) {
      this._product += `-${subApp}`;
    }
    this._asid = asid;
    this._awid = awid;
    Object.freeze(this);
  }

  /**
   * Parses a string value to instance.
   *
   * @param {string} value value to be parsed
   * @return {UuAppKey} instance
   */
  static parse(value) {
    if (value instanceof UuAppKey) {
      return value;
    }
    let result = (value || "").match(APP_KEY_REGEXP);
    if (!result) {
      throw new Errors.InvalidAppKey(value);
    }
    let asid, awid;
    if (result[5]) {
      asid = result[4];
      awid = result[5];
    } else {
      awid = result[4];
      asid = null;
    }
    return new UuAppKey(result[1], result[2], result[3], asid, awid);
  }

  /**
   * Creates instance.
   *
   * @param {string} vendor vendor
   * @param {string} app app
   * @param {string} supApp sub application
   * @param {string} asid asid
   * @param {string} awid awid
   * @return {UuAppKey} instance
   */
  static valueOf(vendor, app, supApp, asid, awid) {
    // check consistency
    // vendor is mandatory
    if (!(vendor || "").match(`^${VENDOR}$`)) {
      throw new Errors.InvalidAppKeyPart("vendor", vendor);
    }
    // other parts are optional, but they has to be entered from the left
    let partialAppKey = false;
    [[APP, app, "app"], [SUB_APP, supApp, "subApp"], [AWID, awid, "awid"], [ASID, asid, "asid"]].forEach(([regexp, partValue, partName]) => {
      if (!partValue) {
        partialAppKey = true;
      } else {
        if (partialAppKey) {
          throw new Errors.InconsistentAppKey(partName, partValue);
        }
        if (!partValue.match(`^${regexp}$`)) {
          throw new Errors.InvalidAppKeyPart(partName, partValue);
        }
      }
    });
    const appKey = new UuAppKey(vendor, app, supApp, asid, awid);
    return appKey;
  }

  /**
   * Getter for composed product property.
   *
   * @return {string} product
   */
  getProduct() {
    return this._product;
  }

  /**
   * Getter for property vendor.
   *
   * @return {string} vendor
   */
  getVendor() {
    return this._vendor;
  }

  /**
   * Getter for property app.
   *
   * @return {string} app
   */
  getApp() {
    return this._app;
  }

  /**
   * Getter for property subApp.
   *
   * @return {string} subApp
   */
  getSubApp() {
    return this._subApp;
  }

  /**
   * Getter for property asid.
   *
   * @return {string} asid
   */
  getAsid() {
    return this._asid;
  }

  /**
   * Getter for property awid.
   *
   * @return {string} awid
   */
  getAwid() {
    return this._awid;
  }

  /**
   * Creates string representation of the appKey.
   *
   * @return {string} UuAppKey string value
   */
  toString() {
    let parts = this._asid ? [["/", this._asid], ["-", this._awid]] : [["/", this._awid]];
    let result = this._product;
    for (let partPair of parts) {
      if (partPair[1]) {
        result += partPair.join("");
      } else {
        break;
      }
    }
    return result;
  }

  /**
   * Returns regular expression (based on attributes of UuAppKey instance).
   *
   * @return {string} regular expression
   */
  getRegExp() {
    let parts = [["\\-", this._app], ["\\-", this._subApp]];
    parts = parts.concat(this._asid || !this._awid ? [["\\/", this._asid], ["\\-", this._awid]] : [["\\/(.+\\-)?", this._awid]]);
    let result = this._vendor;
    for (let partPair of parts) {
      if (partPair[1]) {
        result += partPair.join("");
      } else {
        result += partPair[0] + ".*";
        break;
      }
    }
    return result;
  }

  /**
   * Indicates whether some other object is equal to this one.
   *
   * @param {UuAppKey} UuAppKey UuAppKey with which to compare
   * @return {boolean} true if equal
   */
  equals(appKey) {
    if (appKey == this) {
      return true;
    }
    if (!appKey || !(appKey instanceof UuAppKey)) {
      return false;
    }
    return this.getVendor() == appKey.getVendor() && this.getApp() == appKey.getApp() && this.getSubApp() == appKey.getSubApp() && this.getAwid() == appKey.getAwid() && this.getAsid() == appKey.getAsid();
  }

  /**
   * Compares parts of UuAppKey instance with set value against parts of UuAppKey argument.
   * This method doesn't ensure symmetric comparison (e.g. if a==b then b==a) as it compares only non-null parts of the UuAppKey instance it is called on.
   *
   * @param {UuAppKey} appKey UuAppKey with which to compare
   * @return {boolean} true if this non null appKey parts are the same as parts of the appKey argument
   */
  compareNonNullParts(appKey) {
    if (appKey == this) {
      return true;
    }
    if (!appKey || !(appKey instanceof UuAppKey)) {
      return false;
    }
    return this.getVendor() == appKey.getVendor() && (!this.getApp() || this.getApp() == appKey.getApp()) && (!this.getSubApp() || this.getSubApp() == appKey.getSubApp()) && (!this.getAwid() || this.getAwid() == appKey.getAwid()) && (!this.getAsid() || this.getAsid() == appKey.getAsid());
  }
}
module.exports = UuAppKey;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-logging/src/index.browser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Logger = __webpack_require__("../../node_modules/uu_appg01_core-logging/src/logger.js");
const LoggerFactory = __webpack_require__("../../node_modules/uu_appg01_core-logging/src/logger-factory.js");
const LogLevel = __webpack_require__("../../node_modules/uu_appg01_core-logging/src/log-level.js");
const MessageFormatter = __webpack_require__("../../node_modules/uu_appg01_core-logging/src/message-formatter.js");
const StdoutOutputter = __webpack_require__("../../node_modules/uu_appg01_core-logging/src/stdout-outputter.browser.js");
const LoggerMDC = __webpack_require__("../../node_modules/uu_appg01_core-logging/src/logger_mdc/logger-mdc.js");
module.exports = {
  Logger,
  LoggerFactory,
  LogLevel,
  MessageFormatter,
  StdoutOutputter,
  LoggerMDC
};

/***/ }),

/***/ "../../node_modules/uu_appg01_core-logging/src/log-level.js":
/***/ ((module) => {

"use strict";


const LogLevel = {
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
  FATAL: 4,
  UNKNOWN: 5,
  OFF: 6
};
module.exports = LogLevel;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-logging/src/logger-factory.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Logger = __webpack_require__("../../node_modules/uu_appg01_core-logging/src/logger.js");
const {
  BaseError,
  Config
} = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");
const loggers = {};

/**
 * @class UuApp.Logging.LoggerFactory
 * @classdesc
 * Factory class for getting access to loggers. See {@link UuApp.Logging.Logger Logger} for more information.
 */

/**
 * Returns an instance of the logger with given name. Settings of the logger are
 * taken from global configuration (see {@link UuApp.Util.Config.init Config.init}).
 * Default global logLevel is Logger.{@link UuApp.Logging.Logger.LEVEL_WARN LEVEL_WARN}.
 *
 * Successive calls with the same logger name return the same logger instance.
 *
 * @param {string} name The name of the logger. Typically, it's a fully-qualified name of
 *   the component that uses the logger, e.g. "My.Namespace.Component".
 * @param {boolean} hierarchical Whether the logger shall inherit settings from its parent
 *   package names, e.g. whether logger with name "My.Namespace" should inherit logLevel from "My"
 *   or from root (hierarchical = true, default) or only settings directly for "My.Namespace" apply
 *   (hierarchical = false). The parameter is used only during 1st invocation for given logger name,
 *   in successive calls it's ignored.
 * @return {UuApp.Logging.Logger} An instance of the logger with given name.
 * @method UuApp.Logging.LoggerFactory.get
 */
class LoggerFactory {
  static get(name, hierarchical = true) {
    if (typeof name != "string") {
      throw new BaseError("LoggerFactory.get() must be called with a string argument (logger name).");
    }
    let cname = name.toLowerCase();
    if (loggers[cname]) {
      return loggers[cname].logger;
    } else {
      let logger = new Logger(name);
      LoggerFactory.configure(logger, hierarchical);
      loggers[cname] = {
        logger: logger,
        hierarchical: hierarchical
      };
      return logger;
    }
  }
  static configure(logger, hierarchical) {
    let cname = logger.getName().toString().toLowerCase();
    let logSeverityLabels = Config.get(cname + ".log_severity_labels", hierarchical !== false);
    let logMessageFormat = Config.get(cname + ".log_message_format", hierarchical !== false);
    let logErrorFormat = Config.get(cname + ".log_error_format", hierarchical !== false);
    let logCauseFormat = Config.get(cname + ".log_cause_format", hierarchical !== false);
    let logLevel = Config.get(cname + ".log_level", hierarchical !== false);
    logger.setSeverityLabels(logSeverityLabels);
    logger.setMessageFormat(logMessageFormat);
    logger.setErrorFormat(logErrorFormat);
    logger.setCauseFormat(logCauseFormat);
    logger.setLevel(logLevel);
  }
  static configureAll() {
    Object.keys(loggers).map(function (name) {
      let reg = loggers[name];
      LoggerFactory.configure(reg.logger, reg.hirearchical);
    });
  }
}
module.exports = LoggerFactory;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-logging/src/logger.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const LogLevel = __webpack_require__("../../node_modules/uu_appg01_core-logging/src/log-level.js");
const StdoutOutputter = __webpack_require__("../../node_modules/uu_appg01_core-logging/src/stdout-outputter.browser.js");
const {
  BaseError
} = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");

/**
 * @class UuApp.Logging.Logger
 * @classdesc
 * Component for logging. Each logged message has a severity level and each logger can be
 * configured to process only messages with sufficient severity level. Loggers are hierarchical,
 * i.e. when configuration is processed they inherit severity level from parent modules/packages.
 *
 * Contrary to usual <code>console.log</code>, <code>console.error</code>, ... statements (which
 * are typically removed from production code), statements using Logger-s are intended to be
 * preserved in the production environment and turned on/off via {@link UuApp.Util.Config Config}
 * configuration.
 *
 * **Configuration**
 *
 * Default severity level for loggers is Logger.LEVEL_WARN. Logging is automatically configured from the
 * global configuration (initialized via {@link UuApp.Util.Config Config.init} call).
 * Supported environment options:
 *
 *     {
 *       "log_level": "ERROR",
 *       "My.Namespace.log_level": "WARN"
 *     }
 *
 * As already said, loggers are hierarchical - with configuration above, logger "My.Namespace.Component"
 * would have logLevel "WARN" whereas logger "My" would have logLevel "ERROR". Hierarchical logging can
 * be turned off when initializing a logger - see {@link UuApp.Logging.LoggerFactory.get LoggerFactory.get}.
 *
 * **Typical usage**
 *
 *     // get logger instance and log a message
 *     var logger = UuApp.Logging.LoggerFactory.get("My.Namespace.Component");
 *     logger.warn("Universe expansion is accelerating.", {speedBefore: 68, speedAfter: 68.01});
 *
 *     // if logging requires lengthy computation, it can be made conditional so that it
 *     // doesn't slow down the rest of page if the message wouldn't get logged in the end
 *     if (logger.isDebugLoggable()) {
 *       var computedValue = ...; // some lengthy computation
 *       logger.debug("Value computed to", computedValue);
 *     }
 *
 */
class Logger {
  constructor(name, outputter = null) {
    this._name = name;
    this._level = LogLevel.WARN;
    this._outputter = outputter || new StdoutOutputter();
  }
  getName() {
    return this._name;
  }

  /**
   * Sets severity level of this Logger to given value. Messages with lower (less important)
   * severity will be ignored when attempted to be logged via this logger. Order of importance:
   * DEBUG < INFO < WARN < ERROR < FATAL < UNKNOWN < OFF.
   *
   * **It's strongly advised not to configure loggers directly using this method** because
   * if such code gets deployed to production, it'll effectively override settings from
   * environment and therefore could prevent logging of necessary information.
   * **Use environment configuration instead - see Configuration chapter in {@link UuApp.Logging.Logger Logger}.
   *
   * @param {(number|string)} level Severity level to set. See Logger.LEVEL_* constants. If null
   *   is given, default is used (LEVEL_WARN).
   * @method UuApp.Logging.Logger#setLevel
   */
  setLevel(level) {
    if (typeof level === "number") {
      this._level = level;
    } else if (typeof level === "string") {
      let lvl = LogLevel[level.toUpperCase()] !== undefined ? LogLevel[level.toUpperCase()] : Number(level);
      if (lvl !== undefined && !isNaN(lvl)) {
        this._level = lvl;
      }
    } else if (!level) {
      this._level = LogLevel.WARN;
    } else {
      throw new BaseError(`Invalid logger level "${level}"`);
    }
    return this;
  }

  /**
   * @return {number} Level of this logger.
   * @method UuApp.Logging.Logger#getLevel
   */
  getLevel() {
    return this._level;
  }
  setSeverityLabels(severityLabels) {
    this._outputter.setSeverityLabels(severityLabels);
    return this;
  }
  getSeverityLabels() {
    return this._outputter.getSeverityLabels();
  }
  setMessageFormat(messageFormat) {
    this._outputter.setMessageFormat(messageFormat);
    return this;
  }
  getMessageFormat() {
    return this._outputter.getMessageFormat();
  }
  setErrorFormat(errorFormat) {
    this._outputter.setErrorFormat(errorFormat);
    return this;
  }
  getErrorFormat() {
    return this._outputter.getErrorFormat();
  }
  setCauseFormat(causeFormat) {
    this._outputter.setCauseFormat(causeFormat);
    return this;
  }
  getCauseFormat() {
    return this._outputter.getCauseFormat();
  }
  setOutputter(outputter) {
    this._outputter = outputter;
    return this;
  }
  getOutputter() {
    return this._outputter;
  }

  /**
   * @return {boolean} Whether this logger logs message with severity level "DEBUG".
   * @method UuApp.Logging.Logger#isDebugLoggable
   */
  isDebugLoggable() {
    return this._level <= LogLevel.DEBUG;
  }

  /**
   * Logs message with severity level "DEBUG".
   *
   * @param {string} message The message to log.
   * @param {Error} error Error to be logged with message.
   * @method UuApp.Logging.Logger#debug
   */
  debug(message, error = null) {
    this._add(LogLevel.DEBUG, message, error);
  }

  /**
   * @return {boolean} Whether this logger logs message with severity level "INFO".
   * @method UuApp.Logging.Logger#isInfoLoggable
   */
  isInfoLoggable() {
    return this._level <= LogLevel.INFO;
  }

  /**
   * Logs message with severity level "INFO".
   *
   * @param {string} message The message to log.
   * @param {Error} error Error to be logged with message.
   * @method UuApp.Logging.Logger#info
   */
  info(message, error = null) {
    this._add(LogLevel.INFO, message, error);
  }

  /**
   * @return {boolean} Whether this logger logs message with severity level "WARN".
   * @method UuApp.Logging.Logger#isWarnLoggable
   */
  isWarnLoggable() {
    return this._level <= LogLevel.WARN;
  }

  /**
   * Logs message with severity level "WARN".
   *
   * @param {string} message The message to log.
   * @param {Error} error Error to be logged with message.
   * @method UuApp.Logging.Logger#warn
   */

  warn(message, error = null) {
    this._add(LogLevel.WARN, message, error);
  }

  /**
   * @return {boolean} Whether this logger logs message with severity level "ERROR".
   * @method UuApp.Logging.Logger#isErrorLoggable
   */
  isErrorLoggable() {
    return this._level <= LogLevel.ERROR;
  }

  /**
   * Logs message with severity level "ERROR".
   *
   * @param {string} message The message to log.
   * @param {Error} error Error to be logged with message.
   * @method UuApp.Logging.Logger#error
   */
  error(message, error = null) {
    this._add(LogLevel.ERROR, message, error);
  }

  /**
   * @return {boolean} Whether this logger logs message with severity level "FATAL".
   * @method UuApp.Logging.Logger#isFatalLoggable
   */
  isFatalLoggable() {
    return this._level <= LogLevel.FATAL;
  }

  /**
   * Logs message with severity level "FATAL".
   *
   * @param {string} message The message to log.
   * @param {Error} error Error to be logged with message.
   * @method UuApp.Logging.Logger#error
   */
  fatal(message, error = null) {
    this._add(LogLevel.FATAL, message, error);
  }

  /**
   * Logs message with "UNKNOWN" severity.
   *
   * @param {string} message The message to log.
   * @param {Error} error Error to be logged with message.
   * @method UuApp.Logging.Logger#error
   */
  log(message, error = null) {
    this._add(LogLevel.UNKNOWN, message, error);
  }

  // ======================== Private methods ================================

  _add(level, message, error) {
    if (this._level <= level) {
      this._write(new Date(), level, message, error);
    }
  }
  async _write(datetime, level, message, error) {
    await this._outputter.write(datetime, this._name, level, message, error);
  }
}
module.exports = Logger;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-logging/src/logger_mdc/get-set.browser.js":
/***/ ((module) => {

/**
 * LoggerMDC implementation of get and set
 * for Browser environment.
 */
module.exports = {
  setFactory(ContextStore, CTX_STORE_NAME, MDC_KEY) {
    return function set(key, value) {
      let store = ContextStore.get(CTX_STORE_NAME);
      if (!store) {
        ContextStore.create(CTX_STORE_NAME, noop);
        store = ContextStore.get(CTX_STORE_NAME);
      }
      let mdc = store.get(MDC_KEY);
      if (!mdc) {
        mdc = {};
        store.set(MDC_KEY, mdc);
      }
      mdc[key] = value;
    };
  },
  getFactory(ContextStore, CTX_STORE_NAME, MDC_KEY) {
    return function get(key) {
      let store = ContextStore.get(CTX_STORE_NAME);
      if (!store) {
        ContextStore.create(CTX_STORE_NAME, noop);
        store = ContextStore.get(CTX_STORE_NAME);
      }
      let mdc = store.get(MDC_KEY);
      if (mdc) {
        return mdc[key];
      }
    };
  }
};
function noop() {}

/***/ }),

/***/ "../../node_modules/uu_appg01_core-logging/src/logger_mdc/logger-mdc.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  ContextStore,
  Json
} = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");

// environment specific implementations
const {
  getFactory,
  setFactory
} = __webpack_require__("../../node_modules/uu_appg01_core-logging/src/logger_mdc/get-set.browser.js");
const CTX_STORE_NAME = "uuapp.logging";
const MDC_KEY = "mdc";

/**
 * Mapped diagnostic context.
 */
class LoggerMDC {
  /**
   * Initializes MDC
   * @param emitters Context emitters.
   * @param fn Function within which should be MDC available
   * @returns {*} Return value of invoked function.
   */
  static create(emitters = null, fn) {
    if (typeof emitters === "function") {
      fn = emitters;
      emitters = null;
    }
    return ContextStore.create(CTX_STORE_NAME, () => {
      let ctxStore = ContextStore.get(CTX_STORE_NAME);
      if (emitters) {
        emitters.forEach(e => ctxStore.bindEmitter(e));
      }
      return fn();
    });
  }

  /**
   * Stores context attribute.
   * @param key Context attribute name.
   * @param value Context attribute value.
   */
  static set(key, value) {
    // implementation available in get-set.js
    // due to environment differences
  }

  /**
   * Reads value of context attribute.
   * @param key Context attribute name.
   * @returns {*} Context attribute value.
   */
  static get(key) {
    // implementation available in get-set.js
    // due to environment differences
  }

  /**
   * Clears MDC in current context.
   */
  static clear() {
    let store = ContextStore.get(CTX_STORE_NAME);
    if (store) {
      store.set(MDC_KEY, {});
    }
  }

  /**
   * Serializes current state of MDC to JSON.
   * @returns {string} Serialized MDC
   */
  static toJson() {
    let store = ContextStore.get(CTX_STORE_NAME);
    if (store) {
      let mdc = store.get(MDC_KEY);
      if (mdc) {
        return Json.stringify(mdc);
      }
    }
    return "{}";
  }
}

// remapping environment specific methods
LoggerMDC.set = setFactory(ContextStore, CTX_STORE_NAME, MDC_KEY);
LoggerMDC.get = getFactory(ContextStore, CTX_STORE_NAME, MDC_KEY);
module.exports = LoggerMDC;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-logging/src/message-formatter.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const LogLevel = __webpack_require__("../../node_modules/uu_appg01_core-logging/src/log-level.js");
const {
  BaseError,
  Json
} = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");
const LoggerMDC = __webpack_require__("../../node_modules/uu_appg01_core-logging/src/logger_mdc/logger-mdc.js");

// Regexp to match formatting tags.
// @private
const FORMAT_TAGS = /(%(?:{([^}]*)})?([a-zA-Z%]))/g;

// Default set of severity labels (matching standard ruby
//    {http://ruby-doc.org/stdlib/libdoc/logger/rdoc/Logger/Severity.html
// Logger::Severity} with addition of level +OFF+).
const DEFAULT_SEVERITY_LABELS = "DEBUG INFO WARN ERROR FATAL ANY OFF";

//  Format of message to be used. Following tags are supported:
// * <b>%%</b> - Escaped percent tag.
// * <b>%C</b> - Full {UuApp::Logging::LoggerMdc logger MDC} in JSON format.
// * <b>%d</b> - Date and time in format matching {#datetime_format}.
// * <b>%e</b> - Error formatted using {#error_format} or empty string if there is no error.
// * <b>%m</b> - Actual log message provided by application.
// * <b>%n</b> - Logger name.
// * <b>%p</b> - System process ID.
// * <b>%s</b> - Logging event severity.
// * <b>%t</b> - ID of thread where message was captured.
// * <b>%T</b> - Name of thread where message was captured.
// * <b>%{ KEY }C</b> - Custom attribute from logger {UuApp::Logging::LoggerMdc logger MDC} with name KEY.
//      Time values are printed in format matching {#datetime_format}.
// * <b>%{ FMT }d</b> - Date and time in format matching FMT.
// * <b>%{ FMT }m</b> - Log message provided by application with additional escaping based on FMT value. There are
//      two escaping variants. First is keyword +JSON+ resulting in message with escaped quotes and line separators.
//      In case of any other value, this value will be used to replace new line separators (CR(LF)).
//  * <b>%{ NUM }s</b> - Logging event severity with NUM representing total length of severity with padding.*/

// Default message format (see {#message_format} for tag description).
const DEFAULT_MESSAGE_FORMAT = "[%d] %{5}s %n: %m%e";

// Format of error. In case there is instance of error to be logged (given as explicit logger parameter or implicit
// error reference available inside rescue block), error message is injected into message replacing +%e+ tag. That
// means error format should start with some separator (e.g. new line) to be able to distinguish text of log message
// from printed error. Following tags are supported:
// * <b>%%</b> - Escaped percent tag.
// * <b>%b</b> - Invocation stack (backtrace), lines are joined with new line.
// * <b>%c</b> - Error class name.
// * <b>%C</b> - Error cause formatted using {#cause_format} or {#error_format}, or empty string if there is no cause.
// * <b>%i</b> - Unique error ID.
// * <b>%I</b> - Error code.
// * <b>%m</b> - Actual error message.
// * <b>%t</b> - Timestamp of error instantiation in format matching {#datetime_format}.
// * <b>%{ FMT }b</b> - Invocation stack (backtrace) with additional escaping based on FMT value. There are two escaping variants.
//   First is keyword +JSON+ resulting in message with escaped characters. New line (\n) will be used as backtrace line separator.
//   In case of any other value, this value will be used to replace new line separators (CR(LF)).
// * <b>%{ PFX }C</b> - Error cause with prefix PFX to be used before printing error cause).
// * <b>%{ FMT }m</b> - Error message with additional escaping based on FMT value. There are two escaping variants.
//   First is keyword +JSON+ resulting in message with escaped quotes and line separators. In case of any other value,
//   this value will be used to replace new line separators (CR(LF)).
// * <b>%{ FMT }t</b> - Timestamp of error instantiation in format matching FMT.

// # Default message format (see {#error_format} for tag description).
const DEFAULT_ERROR_FORMAT = "\n  %i [%t] %c: %m\n    %{\n    }b%{\n  Caused by:}C";

//# Default log messages separator.
//# @private
const ENTRY_SEPARATOR = "\n";
class MessageFormatter {
  constructor(messageFormat = null, errorFormat = null, severityLabels = null) {
    this.setSeverityLabels(severityLabels || DEFAULT_SEVERITY_LABELS);
    this.setMessageFormat(messageFormat || DEFAULT_MESSAGE_FORMAT);
    this.setErrorFormat(errorFormat || DEFAULT_ERROR_FORMAT);
  }
  setSeverityLabels(severityLabels) {
    if (severityLabels) {
      this._severityLabels = severityLabels.split(" ");
    }
  }
  getSeverityLabels() {
    return this._severityLabels.join(" ");
  }
  setMessageFormat(messageFormat) {
    if (messageFormat) {
      this._messageFormat = messageFormat;
      let formatterSrc = `(function (datetime, name, severity, message, error) {
        return ${this._transformFormat(messageFormat, this._processMessageFormatTag)};
      }).bind(this);`;
      this._messageFormatter = eval(formatterSrc);
    }
  }
  getMessageFormat() {
    return this._messageFormat;
  }
  setErrorFormat(errorFormat) {
    if (errorFormat) {
      this._errorFormat = errorFormat;
      let formatterSrc = `(function (error) {
        return ${this._transformFormat(errorFormat, this._processErrorFormatTag)};
      }).bind(this);`;
      this._errorFormatter = eval(formatterSrc);
    }
  }
  getErrorFormat() {
    return this._errorFormat;
  }
  setCauseFormat(causeFormat) {
    if (causeFormat) {
      this._causeFormat = causeFormat;
      let formatterSrc = `(function (error) {
        return ${this._transformFormat(causeFormat, this._processErrorFormatTag)};
      }).bind(this);`;
      this._causeFormatter = eval(formatterSrc);
    } else {
      this._causeFormat = null;
      this._causeFormatter = null;
    }
  }
  getCauseFormat() {
    return this._causeFormat;
  }
  formatMessage(datetime, name, severity, message, error = null) {
    if (!datetime) {
      datetime = new Date();
    }
    if (!name) {
      name = "";
    }
    if (severity == null) {
      severity = LogLevel.UNKNOWN;
    }
    if (!message) {
      message = "";
    }
    return this._messageFormatter(datetime, name, severity, message, error);
  }

  // ======================== Private methods ================================

  _formatError(error) {
    return this._errorFormatter(error);
  }
  _formatCause(error) {
    return (this._causeFormatter || this._errorFormatter)(error);
  }
  _processStack(error) {
    let result = [];
    let stack = error.stack;
    if (typeof stack === "string") {
      result = stack.split("\n");
    } else if (stack instanceof Array) {
      result = stack;
    } else if (stack) {
      result = stack.toString().split("\n");
    }
    return result;
  }
  _processMessageFormatTag(tag, opts) {
    let result;
    switch (tag) {
      case "C":
        if (opts) {
          result = `LoggerMDC.get("${opts}")`;
        } else {
          result = "LoggerMDC.toJson()";
        }
        break;
      case "d":
        // TODO Format date
        result = "datetime.toISOString()";
        break;
      case "e":
        result = 'error ? this._formatError(error): ""';
        break;
      case "m":
        switch (opts) {
          case null:
          case undefined:
            result = "message";
            break;
          case "JSON":
            result = 'message ? Json.stringify(message).slice(1,-1) : ""';
            break;
          default:
            result = `message ? message.replace(/\\r\\n|\\r|\\n/g, "${opts}"): ""`;
        }
        break;
      case "n":
        result = "name";
        break;
      case "p":
        // TODO Process ID
        result = '"-"';
        break;
      case "s":
        if (opts) {
          result = `(Array(${opts} + 1).join(" ") + (this._severityLabels[severity] || "ANY")).slice(-${opts})`;
        } else {
          result = 'this._severityLabels[severity] || "ANY"';
        }
        break;
      case "t":
        // TODO Thread ID
        result = '"-"';
        break;
      case "T":
        // TODO Thread name
        result = '"-"';
        break;
    }
    return result;
  }
  _processErrorFormatTag(tag, opts) {
    let result;
    switch (tag) {
      case "b":
        {
          switch (opts) {
            case null:
            case undefined:
              result = `this._processStack(error).join("${ENTRY_SEPARATOR}")`;
              break;
            case "JSON":
              result = `Json.stringify(this._processStack(error).join("${ENTRY_SEPARATOR}")).slice(1, -1)`;
              break;
            default:
              result = `this._processStack(error).join("${opts}")`;
          }
          break;
        }
      case "c":
        result = 'error.name || "Error"';
        break;
      case "C":
        result = `error.cause ? ("${opts || ""}" + this._formatCause(error.cause)) : ""`;
        break;
      case "i":
        result = 'error.id ? error.id : ""';
        break;
      case "I":
        result = 'error.code ? error.code : ""';
        break;
      case "m":
        {
          let errorMessage = 'error.message ? (error.message + ((error.paramMap && Object.keys(error.paramMap).length > 0) ? " (paramMap: " + Json.stringify(error.paramMap) + ")" : "")) : (typeof error === "string" ? error : "")';
          switch (opts) {
            case null:
            case undefined:
              result = errorMessage;
              break;
            case "JSON":
              result = `Json.stringify(${errorMessage}).slice(1,-1)`;
              break;
            default:
              result = `(${errorMessage}).replace(/\\r\\n|\\r|\\n/g, "${opts}")`;
          }
          break;
        }
      case "t":
        result = 'error.timestamp ? error.timestamp.toISOString() : "-"';
        break;
    }
    return result;
  }
  _transformFormat(format, callback) {
    let tags = [];
    format.replace(FORMAT_TAGS, function () {
      tags.push(Array.prototype.slice.call(arguments, 1, -2));
    });
    let result = `("${format.replace(/"/gm, '\\"')}")`;
    tags.forEach(([full_tag, opts, tag]) => {
      let replacement;
      if (tag === "%" && !opts) {
        replacement = "%";
      } else {
        replacement = callback(tag, opts);
      }
      if (replacement === null || replacement === undefined) {
        throw new BaseError(`unsupported format tag "${full_tag}" for ${this.constructor.name}`);
      }
      replacement = `" + (${replacement}) + "`;
      result = result.replace(full_tag, replacement);
    });
    return result.replace(/\n/gm, "\\n").replace();
  }
}
module.exports = MessageFormatter;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-logging/src/stdout-outputter.browser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const LogLevel = __webpack_require__("../../node_modules/uu_appg01_core-logging/src/log-level.js");
const MessageFormatter = __webpack_require__("../../node_modules/uu_appg01_core-logging/src/message-formatter.js");
class BrowserStdoutOutputter {
  constructor(formatter = null) {
    this._formatter = formatter || new MessageFormatter();
  }
  setFormatter(formatter) {
    this._formatter = formatter;
    return this;
  }
  getFormatter() {
    return this._formatter;
  }
  setSeverityLabels(severityLabels) {
    this._formatter.setSeverityLabels(severityLabels);
    return this;
  }
  getSeverityLabels() {
    return this._formatter.getSeverityLabels();
  }
  setMessageFormat(messageFormat) {
    this._formatter.setMessageFormat(messageFormat);
    return this;
  }
  getMessageFormat() {
    return this._formatter.getMessageFormat();
  }
  setErrorFormat(errorFormat) {
    this._formatter.setErrorFormat(errorFormat);
    return this;
  }
  getErrorFormat() {
    return this._formatter.getErrorFormat();
  }
  setCauseFormat(causeFormat) {
    this._formatter.setCauseFormat(causeFormat);
    return this;
  }
  getCauseFormat() {
    return this._formatter.getCauseFormat();
  }
  async write(datetime, name, level, message, error) {
    // use native browser functionality to display error info
    // error is not formatted by formatter, but passed to console directly
    const formattedMessage = this._formatter.formatMessage(datetime, name, level, message);
    const output = [formattedMessage];
    if (error != null && typeof error === "object") {
      output.push(error, "\n", {
        ...error
      });
    } else if (error != null) {
      output.push(error);
    }
    switch (level) {
      case LogLevel.FATAL:
      case LogLevel.ERROR:
        console.error(...output);
        break;
      case LogLevel.WARN:
        console.warn(...output);
        break;
      case LogLevel.INFO:
      case LogLevel.UNKNOWN:
        console.info(...output);
        break;
      case LogLevel.DEBUG:
        console.debug(...output);
        break;
      default:
        console.log(...output);
    }
  }
}
module.exports = BrowserStdoutOutputter;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-perflog/src/index.browser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = {
  Perflog: __webpack_require__("../../node_modules/uu_appg01_core-perflog/src/perflog.browser.js"),
  Section: __webpack_require__("../../node_modules/uu_appg01_core-perflog/src/section.browser.js"),
  SectionId: __webpack_require__("../../node_modules/uu_appg01_core-perflog/src/section-id.js"),
  Logger: __webpack_require__("../../node_modules/uu_appg01_core-perflog/src/logger.js"),
  MessageFormatter: __webpack_require__("../../node_modules/uu_appg01_core-perflog/src/message-formatter.js")
};

/***/ }),

/***/ "../../node_modules/uu_appg01_core-perflog/src/logger.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  Config
} = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");
const LoggerFactory = (__webpack_require__("../../node_modules/uu_appg01_core-logging/src/index.browser.js").LoggerFactory);
const BaseLogger = (__webpack_require__("../../node_modules/uu_appg01_core-logging/src/index.browser.js").Logger);
const LogLevel = (__webpack_require__("../../node_modules/uu_appg01_core-logging/src/index.browser.js").LogLevel);
const StdoutOutputter = (__webpack_require__("../../node_modules/uu_appg01_core-logging/src/index.browser.js").StdoutOutputter);
const MessageFormatter = __webpack_require__("../../node_modules/uu_appg01_core-perflog/src/message-formatter.js");
const LOGGER_NAME = "UuApp.Perflog.Logger";

/**
 * Logger component internally used by Perflog for providing gathered performance
 * statistics data. Logger is transparently managed via LoggerFactory and
 * therefore supports external configuration via following configuration parameters:
 *
 * * <b>uuapp.perflog.logger.log_level</b><br>
 *   Defines log level. Level can be defined either via name, or its numeric representation. Defaults to +INFO+.
 *
 * * <b>uuapp.perflog.logger.log_message_format</b><br>
 *   Allows to define custom message format. See {UuApp::Perflog::MessageFormatter#message_format} for details.
 */
class Logger {
  /**
   * Overrides default message format.
   * @param messageFormat Format string.
   */
  static setMessageFormat(messageFormat) {
    Logger._getLogger().setMessageFormat(messageFormat);
  }

  /**
   * Logging severity threshold. Possible values are:
   # * OFF - Logger is disabled.
   # * INFO - Logger logs data of first level measured sections only.
   # * DEBUG - Logger logs data of all measured sections.
   * @param level Log level.
   */
  static setLevel(level) {
    Logger._getLogger().setLevel(level);
  }

  /**
   * Checks if performance log is enabled (log level is set to anything other than "OFF").
   * @returns {boolean} True if log is enabled, else false.
   */
  static isEnabled() {
    return Logger._getLogger().getLevel() < LogLevel.OFF;
  }

  /**
   * Checks verbosity of performance log. If log is in verbose mode (log
   * level is set to "DEBUG") it prints data of all measured sections. Else
   * it logs only first level sections.
   * @returns {boolean} True if perfomance log is in verbose mode, else false.
   */
  static isVerbose() {
    return Logger._getLogger().getLevel() < LogLevel.INFO;
  }

  /**
   * Transforms given section to log message and prints it.
   * @param section Section to be logged.
   */
  static log(section) {
    if (!section) {
      return;
    }
    Logger._getLogger().log(section);
  }
  static _getLogger() {
    if (!this._logger) {
      let formatter = new MessageFormatter();
      let outputter = new StdoutOutputter(formatter);
      let logger = new BaseLogger(LOGGER_NAME, outputter);
      if (!Config.get(`${LOGGER_NAME.toLowerCase()}.log_level`, false)) {
        Config.set(`${LOGGER_NAME.toLowerCase()}.log_level`, "OFF");
      }
      LoggerFactory.configure(logger, false);
      this._logger = logger;
    }
    return this._logger;
  }
}
module.exports = Logger;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-perflog/src/message-formatter.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseMessageFormatter = (__webpack_require__("../../node_modules/uu_appg01_core-logging/src/index.browser.js").MessageFormatter);
const DEFAULT_MESSAGE_FORMAT = '[%d] PRFLG {"id":"%i","name":"%n","attributes":%a,"checkpoints":%c,"start":"%t","duration":"%D"}';

/**
 * Default log message formatter used by Perflog logger.
 */
class MessageFormatter extends BaseMessageFormatter {
  constructor() {
    super(DEFAULT_MESSAGE_FORMAT, null, null);
  }

  /**
   * Sets format of performance log message. Following tags are supported:
   * * <b>%%</b> - Escaped percent tag.
   * * <b>%a</b> - Section attributes in JSON format.
   * * <b>%c</b> - Section checkpoints in JSON format.
   * * <b>%C</b> - Full logger MDC in JSON format.
   * * <b>%d</b> - Date and time.
   * * <b>%D</b> - Section duration in nanos.
   * * <b>%f</b> - Section finish date and time.
   * * <b>%i</b> - Section ID.
   * * <b>%n</b> - Section name.
   * * <b>%t</b> - Section start date and time.
   * * <b>%{ KEY }a</b> - Section attribute with name KEY.
   * * <b>%{ KEY }c</b> - Duration of particular checkpoint with name KEY.
   * * <b>%{ KEY }C</b> - Custom attribute from logger MDC with name KEY.
   * * <b>%{ FMT }d</b> - Date and time in format matching FMT.
   * * <b>%{ FMT }f</b> - Section finish date and time in format matching FMT.
   * * <b>%{ ELM }i</b> - Section ID part, ELM = trace|parent|child|level.
   * * <b>%{ FMT }t</b> - Section start date and time in format matching FMT.
   * @param messageFormat Message format.
   */
  setMessageFormat(messageFormat) {
    super.setMessageFormat(messageFormat);
  }
  _processMessageFormatTag(tag, opts) {
    let result;
    switch (tag) {
      case "a":
        if (opts) {
          // TODO Format date if needed
          result = `message.getAttribute("${opts}")`;
        } else {
          result = "Json.stringify(message.getAttributes())";
        }
        break;
      case "c":
        if (opts) {
          result = `message.getCheckpoint("${opts}")`;
        } else {
          result = "Json.stringify(message.getCheckpoints())";
        }
        break;
      case "C":
        if (opts) {
          // TODO Format date if needed
          result = `LoggerMDC.get("${opts}")`;
        } else {
          result = "LoggerMDC.toJson()";
        }
        break;
      case "d":
        // TODO Format date
        result = "datetime.toISOString()";
        break;
      case "D":
        result = "message.getDuration()";
        break;
      case "f":
        // TODO Format date
        result = "message.getFinish() ? message.getFinish().toISOString() : null";
        break;
      case "i":
        switch (opts) {
          case /trace/i:
            result = "message.getId().getTraceId()";
            break;
          case /parent/i:
            result = "message.getId().getParentId()";
            break;
          case /child/i:
            result = "message.getId().getId()";
            break;
          case /level/i:
            result = "message.getLevel()";
            break;
          default:
            result = "message.getId().toString()";
        }
        break;
      case "I":
        // TODO Thread ID
        result = '"-"';
        break;
      case "n":
        result = "message.getName()";
        break;
      case "t":
        // TODO Format date
        result = "message.getStart().toISOString()";
        break;
    }
    return result;
  }
}
module.exports = MessageFormatter;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-perflog/src/perflog.browser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  ContextStore,
  Config
} = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");
const Section = __webpack_require__("../../node_modules/uu_appg01_core-perflog/src/section.browser.js");
const SectionId = __webpack_require__("../../node_modules/uu_appg01_core-perflog/src/section-id.js");
const Logger = __webpack_require__("../../node_modules/uu_appg01_core-perflog/src/logger.js");
let localStorageAvailable;
try {
  let check = localStorage;
  localStorageAvailable = !!check;
} catch (e) {
  localStorageAvailable = false;
}
const CTX_STORE_NAME = "uuapp.perflog";
const SECTION_FILTER_PARAM = "uuapp.perflog.section_filter";
const TRACE_ID_PRARAM = "uu_app_client_trace_id";
let traceId = localStorageAvailable && localStorage.getItem(TRACE_ID_PRARAM);
if (!traceId) {
  traceId = ("00000000" + Math.floor(Math.random() * 4294967295).toString(16)).slice(-8);
  localStorageAvailable && localStorage.setItem(TRACE_ID_PRARAM, traceId);
}
class Perflog {
  // In browser, section nesting is not supported

  static initialize(parentId = null, fn) {
    if (typeof parentId === "function") {
      fn = parentId;
      parentId = null;
    }
    return ContextStore.create(CTX_STORE_NAME, () => {
      let ctxStore = ContextStore.get(CTX_STORE_NAME);
      if (parentId) {
        parentId = SectionId.create(parentId);
      } else {
        parentId = parentId = SectionId.create(traceId, traceId);
      }
      ctxStore.set("parentId", parentId);
      return fn();
    });
  }
  static measureSection(name = null, attributes = {}, fn) {
    if (typeof name === "function") {
      fn = name;
      name = null;
      attributes = {};
    }
    if (typeof name === "object") {
      fn = attributes;
      attributes = name;
      name = null;
    }
    if (typeof attributes === "function") {
      fn = attributes;
      attributes = {};
    }
    let sectionWrapper = async () => {
      let ctxStore = ContextStore.get(CTX_STORE_NAME);
      let parentId = ctxStore.get("parentId");
      // Section is logged in case verbose logging is enabled or
      // if section matches filter regular expression.
      let isTraceable = Perflog._isTraceable(name);
      // In browser all sections have level 0 (they are not nested).
      let sectionId = isTraceable ? new SectionId(parentId.getTraceId(), parentId.getId(), -1) : parentId;
      let section = new Section(sectionId, name, attributes, isTraceable);
      try {
        let result = await fn(section);
        section.close();
        return result;
      } catch (e) {
        section.close();
        throw e;
      }
    };
    let ctxStore = ContextStore.get(CTX_STORE_NAME);
    if (ctxStore) {
      return ctxStore.fork(sectionWrapper);
    } else {
      return Perflog.initialize(sectionWrapper);
    }
  }
  static setSectionFilter(filter) {
    Config.set(SECTION_FILTER_PARAM, filter || ".*");
  }
  static _isTraceable(name) {
    if (Logger.isVerbose()) {
      return true;
    } else {
      let secFilter = Config.get(SECTION_FILTER_PARAM);
      if (secFilter) {
        return new RegExp(secFilter).test(name);
      } else {
        return false;
      }
    }
  }
}
module.exports = Perflog;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-perflog/src/section-id.js":
/***/ ((module) => {

"use strict";


// TODO Generate trace ID based on fingerprint
const TRACE_ID_PREFIX = ("0000" + Math.floor(Math.random() * 65535).toString(16)).slice(-4);

/**
 * Object representation of Perflog mesured section ID.
 */
class SectionId {
  /**
   * Creates new section ID from qualified section ID.
   * @param qualifiedId Qualified section ID.
   * @returns {SectionId} Section ID.
   */
  static create(qualifiedId) {
    let match;
    if (!qualifiedId) {
      return new SectionId(null, null);
    } else if (match = /^([^-]+)-([^-]+)-([^-]+)-([^-]+)$/.exec(qualifiedId.toString())) {
      return new SectionId(match[1], match[2], match[3], Number(match[4] || 0));
    } else {
      let traceId = qualifiedId.toString().replace(/-/g, "");
      return new SectionId(traceId, traceId);
    }
  }

  /**
   * Creates new section ID instance.
   * @param traceId Trace ID.
   * @param parentId Parent section ID.
   * @param childId Child section ID.
   * @param level Nesting level. In case childId
   *   is given, level is considered as "child level". In case
   *   childId is not set, level is considered as "parent
   *   level" and thus will be increased in new section ID.
   */
  constructor(traceId, parentId, childId = null, level = null) {
    if (typeof childId === "number") {
      level = childId;
      childId = null;
    }
    this._traceId = traceId || TRACE_ID_PREFIX + ("0000" + Math.floor(Math.random() * 65535).toString(16)).slice(-4);
    this._parentId = parentId || this._traceId;
    this._id = childId || ("00000000" + Math.floor(Math.random() * 4294967295).toString(16)).slice(-8);
    if (typeof level === "number") {
      this._level = childId ? level : level + 1;
    } else {
      this._level = 0;
    }
    this._qualifiedId = `${this._traceId}-${this._parentId}-${this._id}-${("0000" + this._level.toString()).slice(-4)}`;
  }

  /**
   * Trace ID shared by all sections within request scope (spanned
   * across clients and servers). For root section this ID is same
   * as parent ID.
   * @returns {*|string} Trace ID.
   */
  getTraceId() {
    return this._traceId;
  }

  /**
   * ID of parent section. For root section this ID is same as
   * trace ID.
   * @returns {*|string} Parent ID.
   */
  getParentId() {
    return this._parentId;
  }

  /**
   * ID of current section. This ID will be used as parent ID for
   * all nested sections.
   * @returns {*|string} Child/section ID.
   */
  getId() {
    return this._id;
  }

  /**
   * Section nesting level. For root section level is 0.
   * @returns {*|number} Nesting level.
   */
  getLevel() {
    return this._level;
  }

  /**
   * Returns formatted qualified section ID.
   * @returns {string} Formatted qualified section ID.
   */
  toString() {
    return this._qualifiedId;
  }
}
module.exports = SectionId;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-perflog/src/section.browser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Logger = __webpack_require__("../../node_modules/uu_appg01_core-perflog/src/logger.js");

/**
 * Object provided by {UuApp::Perflog} representing
 * measured section.
 */
class Section {
  /**
   * Creates new instance of section.
   * @param id Section ID.
   * @param name Section name.
   * @param attributes Section attributes.
   * @param traceable Flag if section is traceable
   *   and thus should be visible in performance log.
   */
  constructor(id, name, attributes, traceable) {
    this._id = id;
    this._name = name || "";
    this._attributes = attributes || {};
    this._traceable = traceable;
    this._checkpoints = {};
    this._start = new Date();
    this._startRaw = window.performance.now();
  }

  /**
   * Section ID.
   * @returns {*} Section ID.
   */
  getId() {
    return this._id;
  }

  /**
   * User defined section name.
   * @returns {*} User defined section name.
   */
  getName() {
    return this._name;
  }

  /**
   * Sets user defined section attribute.
   * @param name Attribute name.
   * @param value Attribute value.
   */
  setAttribute(name, value) {
    this.getAttributes()[name] = value;
  }

  /**
   * User defined section attributes.
   * @returns {*|{}} User defined section attributes.
   */
  getAttributes() {
    return this._attributes;
  }

  /**
   * Returns user defined section attribute.
   * @param name Attribute name.
   * @returns {*} Attribute value.
   */
  getAttribute(name) {
    return this.getAttributes()[name];
  }

  /**
   * Sets section checkpoint (important milestone of section processing
   * which is not important enough to create nested measured section).
   * Name of checkpoint must be unique in scope of section.
   * @param name Checkpoint name.
   */
  setCheckpoint(name) {
    this._checkpoints[name] = Math.round((window.performance.now() - this._startRaw) * 1000000);
  }

  /**
   * Set of currently processed checkpoints. Returned as
   * object where key is checkpont name, value is duration
   * (in nanoseconds) elapsed from section start.
   * @returns {{}|*} Processed checkpoints.
   */
  getCheckpoints() {
    return this._checkpoints;
  }

  /**
   * Returns duration of particular checkpoint (in nanoseconds).
   * @param name Checkpoint name
   * @returns {number|*} Checkpoint duration.
   */
  getCheckpoint(name) {
    return this.getCheckpoints()[name];
  }

  /**
   * Section start time.
   * @returns {Date} Section start time.
   */
  getStart() {
    return this._start;
  }

  /**
   * Section finish time. Returns null until section is closed.
   * @returns {Date} Section finish time.
   */
  getFinish() {
    return this._finish;
  }

  /**
   * Section duration (in nanoseconds). Returns null until
   * section is closed.
   * @returns {number|*} Section duration.
   */
  getDuration() {
    return this._duration;
  }

  /**
   * Closes section and publishes section data via Perflog logger
   * (based on Perflog logger verbosity configuration).
   */
  close() {
    if (this._finish) {
      return;
    }
    this._finish = new Date();
    this._duration = Math.round((window.performance.now() - this._startRaw) * 1000000);
    if (this._traceable) {
      Logger.log(this);
    }
  }
}
module.exports = Section;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-uri/src/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Uri = __webpack_require__("../../node_modules/uu_appg01_core-uri/src/uri.js");
const UriBuilder = __webpack_require__("../../node_modules/uu_appg01_core-uri/src/uri-builder.js");
const InvalidUriPartError = __webpack_require__("../../node_modules/uu_appg01_core-uri/src/invalid-uri-part-error.js");
module.exports = {
  Uri,
  UriBuilder,
  InvalidUriPartError
};

/***/ }),

/***/ "../../node_modules/uu_appg01_core-uri/src/invalid-uri-part-error.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {
  BaseError
} = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");
class InvalidUriPartError extends BaseError {
  constructor(partName, value, expected) {
    let message = "";
    if (typeof expected !== "string") {
      expected = expected === String ? "string" : expected;
      message = `Value "${value}" of URI part [${partName}] must be ${expected} but its typeof is ${typeof value}.`;
    } else {
      message = `Value "${value}" of URI part [${partName}] does not match regular expression /${expected.replace(/\//g, "\\/")}/.`;
    }
    super(message || "Unexpected error occurred during operation execution.", null);
    this.code = "uu-app-uri/InvalidUriPartError";
  }
}
module.exports = InvalidUriPartError;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-uri/src/uri-builder.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {
  BaseError
} = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");
const Uri = __webpack_require__("../../node_modules/uu_appg01_core-uri/src/uri.js");
const UriParser = __webpack_require__("../../node_modules/uu_appg01_core-uri/src/uri-parser.js");

/**
 * Creates an instance of UriBuilder.
 *
 * @class UuApp.Uri.UriBuilder
 * @classdesc
 * Class for building uuUri. Typical usage:
 *
 *     // starting from current location
 *     let uriBuilder = UriBuilder.parse(location.protocol + "//" + location.host + location.pathname);
 *     let uri1 = uriBuilder.setUseCase("/sys/init").setParameters({ p1: "v1" }).toUri();
 *     console.log(uri1.toString()); // <gateway>/<product>/<workspace>/sys/init?p1=v1
 *
 *     // starting anew, using gateway from main HTML page location
 *     let gateway = location.origin || (location.protocol + "//" + location.host);
 *     let uri2 = UriBuilder.set({
 *       gateway: gateway,
 *       product: "uu-demoapp-main",
 *       workspace: "tid123-awid456",
 *       parameters: { p1: "v1", p2: "v2" }
 *     }).toUri(); // <gatewayFromMainPage>/uu-demoapp-main/tid123-awid456?p1=v1&p2=v2
 *
 *     // parameters example
 *     let uriBuilder = UriBuilder.parse(uri2);
 *     let uri3 = uriBuilder.deleteParameter("p1").mergeParameters({ p3: "v3" }).toUri();
 *     console.log(uri3.toString()); // <gatewayFromMainPage>/uu-demoapp-main/tid123-awid456?p2=v2&p3=v3
 *
 * @see {@link UuApp.Uri.UriBuilder.parse UriBuilder.parse}
 * @see {@link UuApp.Uri.UriBuilder.set UriBuilder.set}
 * @see {@link UuApp.Uri.UriBuilder#toUri UriBuilder#toUri}
 */
class UriBuilder {
  constructor() {
    this._parameters = {};
  }

  /**
   * Sets query parameter with given name to given value.
   *
   * @param {string} name The parameter name.
   * @param {string} value The parameter value.
   * @return This UriBuilder instance for chaining operations.
   * @method UuApp.Uri.UriBuilder#setParameter
   */
  setParameter(name, value) {
    UriParser.validateParameterName(name);
    UriParser.validateParameterValue(value);
    if (this._parameters.hasOwnProperty(name)) {
      if (Array.isArray(this._parameters[name])) {
        this._parameters[name].push(value);
      } else {
        this._parameters[name] = [this._parameters[name], value];
      }
    } else {
      this._parameters[name] = value;
    }
    return this;
  }

  /**
   * Removes query parameter with given name.
   *
   * @param {string} name The parameter name.
   * @return This UriBuilder instance for chaining operations.
   * @method UuApp.Uri.UriBuilder#deleteParameter
   */
  deleteParameter(name) {
    UriParser.validateParameterName(name);
    delete this._parameters[name];
    return this;
  }

  /**
   * Removes all query parameters.
   *
   * @return This UriBuilder instance for chaining operations.
   * @method UuApp.Uri.UriBuilder#clearParameters
   */
  clearParameters() {
    this._parameters = {};
    return this;
  }

  /**
   * Parses URI string (or Uri instance) and resets all fields of this UriBuilder
   * to parsed values.
   *
   * @param {(string|UuApp.Uri.Uri)} uriObj URI to parse.
   * @return This UriBuilder instance.
   * @method UuApp.Uri.UriBuilder#parse
   */
  parse(uriObj) {
    let uri = typeof uriObj === "string" ? UriParser.parse(uriObj, this).toUri() : uriObj;
    this.setGateway(uri.getGateway());
    this.setProduct(uri.getProduct());
    this.setWorkspace(uri.getWorkspace());
    this.setUseCase(uri.getUseCase());
    this.setParameters(uri.getParameters());
    return this;
  }

  /**
   * Equivalent to <code>new UriBuilder().parse(uri)</code>.
   *
   * @param {(string|UuApp.Uri.Uri)} uri URI to parse.
   * @return New UriBuilder instance.
   * @method UuApp.Uri.UriBuilder.parse
   * @see UuApp.Uri.UriBuilder#parse
   */
  static parse(uri) {
    return new UriBuilder().parse(uri);
  }
  format() {
    return UriBuilder.format(this.toUri());
  }
  static format(uri) {
    return UriParser.format(uri);
  }
  static formatGateway(scheme, hostname, port) {
    return UriParser.formatGateway(scheme, hostname, port);
  }
  static formatProduct(vendor, app, subApp, spp) {
    return UriParser.formatProduct(vendor, app, subApp, spp);
  }
  static formatWorkspace(tid, awid) {
    return UriParser.formatWorkspace(tid, awid);
  }
  static formatParameters(params) {
    return UriParser.formatParameters(params);
  }
  toString() {
    return UriBuilder.format(this.toUri());
  }

  /**
   * Returns Uri instance from current values of this UriBuilder.
   *
   * @return {UuApp.Uri.Uri} Uri instance from current values of this UriBuilder.
   * @method UuApp.Uri.UriBuilder#toUri
   */
  toUri() {
    let missing = [];
    if (this.getScheme() == null && (this.getHostname() != null || this.getPort() != null)) missing.push("scheme");
    if (this.getHostname() == null && (this.getScheme() != null || this.getPort() != null)) missing.push("hostname");
    if (this.getVendor() == null && (this.getSubApp() != null || this.getSpp() != null)) missing.push("vendor");
    if (this.getApp() == null) missing.push("app");
    if (this.getSubApp() == null && this.getSpp() != null) missing.push("subApp");
    if (this.getAwid() == null) missing.push("awid");
    if (missing.length) throw new BaseError("Missing Uri parts: " + missing.join(", "));
    return new Uri(this.getScheme(), this.getHostname(), this.getPort(), this.getVendor(), this.getApp(), this.getSubApp(), this.getSpp(), this.getTid(), this.getAwid(), this.getUseCase(), this.getParameters());
  }

  /**
   * Replaces current path with specified absolute path (or adds a relative path to the current path) for this UriBuilder.
   * Works exactly the same way as {@link UuApp.Uri.Uri#join Uri#join} but returns UriBuilder instead of Uri.
   *
   * @param {...string} path Absolute or relative paths to replace / add.
   * @return This UriBuilder instance.
   * @method UuApp.Uri.UriBuilder#join
   * @see UuApp.Uri.Uri#join
   * @example
   *  // replace path with an absolute path
   *  let srcUri = "https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1";
   *  let uriBuilder = UriBuilder.parse(srcUri);
   *  uriBuilder.join("/vendor2-app2/tid2-awid2"); // https://uuos9.plus4u.net/vendor2-app2/tid2-awid2
   *
   *  // add relative paths
   *  let uriBuilder = UriBuilder.parse(srcUri);
   *  uriBuilder.join("./sys/init?p=v");         // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/sys/init
   *  let uriBuilder = UriBuilder.parse(srcUri);
   *  uriBuilder.join("+/sys/init?p=v");         // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1/sys/init
   */
  join( /* ... */
  ) {
    let uri = this.toUri();
    return this.parse(uri.join.apply(uri, arguments));
  }

  /**
   * Sets fields of this UriBuilder to given values.
   *
   * @param {...Object} fieldMap Object(s) containing fields to set to this UriBuilder. If more objects are given,
   *   fields in latter ones override fields in former ones.
   * @return This UriBuilder instance.
   * @method UuApp.Uri.UriBuilder#set
   * @example
   *   // replace spp, awid & remove useCase
   *   let resUri = UriBuilder.parse(someUri).set({
   *     spp: "async",
   *     awid: "12345",
   *     useCase: null
   *   }).toUri();
   *
   *   // multiple settings
   *   let defaults = { gateway: "...", product: "uu-demoapp-main", tid: "0", awid: "0" };
   *   let resUri = UriBuilder.set(defaults, {
   *     tid: "12f34", // overrides the one from "defaults" variable
   *     useCase: "/getData"
   *   }).toUri();
   */
  set( /* ... */
  ) {
    for (let i = 0; i < arguments.length; ++i) {
      let hash = arguments[i];
      if (!hash) continue;
      if (typeof hash !== "object") continue;
      for (let k in hash) {
        this["set" + k.replace(/^./, m => m.toUpperCase())](hash[k]);
      } // this[k] = hash[k];
    }

    return this;
  }

  /**
   * Equivalent to <code>new UriBuilder().set(...)</code>.
   *
   * @param {...Object} fieldMap Object(s) containing fields to set to the UriBuilder. If more objects are given,
   *   fields in latter ones override fields in former ones.
   * @return New UriBuilder instance.
   * @method UuApp.Uri.UriBuilder.set
   * @see UuApp.Uri.UriBuilder#set
   */
  static set( /* ... */
  ) {
    let builder = new UriBuilder();
    return builder.set.apply(builder, arguments);
  }

  /**
   * Equivalent to <code>new UriBuilder().setParameter(name, value)</code>.
   *
   * @param {string} name The parameter name.
   * @param {string} value The parameter value.
   * @return New UriBuilder instance.
   * @method UuApp.Uri.UriBuilder.setParameter
   * @see UuApp.Uri.UriBuilder#setParameter
   */
  static setParameter(name, value) {
    return new UriBuilder().setParameter(name, value);
  }

  /**
   * Merges (replaces / adds) provided parameters into the ones already present
   * in this UriBuilder.
   *
   * @param {Object} map Map with parameters to merge.
   * @return This UriBuilder instance.
   * @method UuApp.Uri.UriBuilder#mergeParameters
   */
  mergeParameters(value) {
    if (value) for (let k in value) this.setParameter(k, value[k]);
    return this;
  }

  //---------------------------------------------

  getScheme() {
    return this._scheme;
  }
  get scheme() {
    return this.getScheme();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set scheme(attr) {
    this.throwOnSet("scheme");
  }
  getHostname() {
    return this._hostname;
  }
  get hostname() {
    return this.getHostname();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set hostname(attr) {
    this.throwOnSet("hostname");
  }
  getVendor() {
    return this._vendor;
  }
  get vendor() {
    return this.getVendor();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set vendor(attr) {
    this.throwOnSet("vendor");
  }
  getApp() {
    return this._app;
  }
  get app() {
    return this.getApp();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set app(attr) {
    this.throwOnSet("app");
  }
  getSubApp() {
    return this._subApp;
  }
  get subApp() {
    return this.getSubApp();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set subApp(attr) {
    this.throwOnSet("subApp");
  }
  getSpp() {
    return this._spp;
  }
  get spp() {
    return this.getSpp();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set spp(attr) {
    this.throwOnSet("spp");
  }
  getTid() {
    return this._tid;
  }
  get tid() {
    return this.getTid();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set tid(attr) {
    this.throwOnSet("tid");
  }
  getAwid() {
    return this._awid;
  }
  get awid() {
    return this.getAwid();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set awid(attr) {
    this.throwOnSet("awid");
  }

  /**
   * Map containing query parameters. If there're no parameters, empty map is returned (not a null).
   * Note that each access returns new copy of the map (to prevent modification of the map without
   * validating the values / keys).
   *
   *     // GOOD
   *     uriBuilder.setParameter("myParam", "value");
   *
   * @name UuApp.Uri.UriBuilder#parameters
   */
  getParameters() {
    return Object.assign({}, this._parameters);
  }
  get parameters() {
    return this.getParameters();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set parameters(attr) {
    this.throwOnSet("parameters");
  }

  /**
   * Equivalent to <code>new UriBuilder().setScheme(value)</code>.
   *
   * @param {string} value Scheme to set.
   * @return New UriBuilder instance.
   * @method UuApp.Uri.UriBuilder.setScheme
   * @see UuApp.Uri.UriBuilder#setScheme
   */
  setScheme(value) {
    // "instance" method
    if (value != null) UriParser.validateScheme(value);
    this._scheme = value != null ? value : null;
    return this;
  }

  /**
   * Chainable setter for scheme.
   *
   * @param {string} value Scheme to set.
   * @return This UriBuilder instance.
   * @method UuApp.Uri.UriBuilder#setScheme
   */
  static setScheme(value) {
    // "static" method
    return new UriBuilder().setScheme(value);
  }

  /**
   * Equivalent to <code>new UriBuilder().setHostname(value)</code>.
   *
   * @param {string} value Hostname to set.
   * @return New UriBuilder instance.
   * @method UuApp.Uri.UriBuilder.setHostname
   * @see UuApp.Uri.UriBuilder#setHostname
   */
  setHostname(value) {
    // "instance" method
    if (value != null) UriParser.validateHostname(value);
    this._hostname = value != null ? value : null;
    return this;
  }

  /**
   * Chainable setter for hostname.
   *
   * @param {string} value Hostname to set.
   * @return This UriBuilder instance.
   * @method UuApp.Uri.UriBuilder#setHostname
   */
  static setHostname(value) {
    // "static" method
    return new UriBuilder().setHostname(value);
  }

  /**
   * Chainable setter for port.
   *
   * @param {string} value Port to set.
   * @return This UriBuilder instance.
   * @method UuApp.Uri.UriBuilder#setPort
   */
  static setPort(value) {
    // "static" method
    return new UriBuilder().setPort(value);
  }

  /**
   * Chainable setter for gateway.
   *
   * @param {string} value Gateway to set.
   * @return This UriBuilder instance.
   * @method UuApp.Uri.UriBuilder#setGateway
   */
  static setGateway(value) {
    // "static" method
    return new UriBuilder().setGateway(value);
  }

  /**
   * Equivalent to <code>new UriBuilder().setVendor(value)</code>.
   *
   * @param {string} value Vendor to set.
   * @return New UriBuilder instance.
   * @method UuApp.Uri.UriBuilder.setVendor
   * @see UuApp.Uri.UriBuilder#setVendor
   */
  setVendor(value) {
    // "instance" method
    if (value != null) UriParser.validateVendor(value);
    this._vendor = value != null ? value : null;
    return this;
  }

  /**
   * Chainable setter for vendor.
   *
   * @param {string} value Vendor to set.
   * @return This UriBuilder instance.
   * @method UuApp.Uri.UriBuilder#setVendor
   */
  static setVendor(value) {
    // "static" method
    return new UriBuilder().setVendor(value);
  }

  /**
   * Equivalent to <code>new UriBuilder().setApp(value)</code>.
   *
   * @param {string} value Application to set.
   * @return New UriBuilder instance.
   * @method UuApp.Uri.UriBuilder.setApp
   * @see UuApp.Uri.UriBuilder#setApp
   */
  setApp(value) {
    // "instance" method
    if (value != null) UriParser.validateApp(value);
    this._app = value != null ? value : null;
    return this;
  }

  /**
   * Chainable setter for application.
   *
   * @param {string} value Application to set.
   * @return This UriBuilder instance.
   * @method UuApp.Uri.UriBuilder#setApp
   */
  static setApp(value) {
    // "static" method
    return new UriBuilder().setApp(value);
  }

  /**
   * Equivalent to <code>new UriBuilder().setSubApp(value)</code>.
   *
   * @param {string} value Sub-application to set.
   * @return New UriBuilder instance.
   * @method UuApp.Uri.UriBuilder.setSubApp
   * @see UuApp.Uri.UriBuilder#setSubApp
   */
  setSubApp(value) {
    // "instance" method
    if (value != null) UriParser.validateSubApp(value);
    this._subApp = value != null ? value : null;
    return this;
  }

  /**
   * Chainable setter for sub-application.
   *
   * @param {string} value Sub-application to set.
   * @return This UriBuilder instance.
   * @method UuApp.Uri.UriBuilder#setSubApp
   */
  static setSubApp(value) {
    // "static" method
    return new UriBuilder().setSubApp(value);
  }

  /**
   * Equivalent to <code>new UriBuilder().setSpp(value)</code>.
   *
   * @param {string} value SPP to set.
   * @return New UriBuilder instance.
   * @method UuApp.Uri.UriBuilder.setSpp
   * @see UuApp.Uri.UriBuilder#setSpp
   */
  setSpp(value) {
    // "instance" method
    if (value != null) UriParser.validateSpp(value);
    this._spp = value != null ? value : null;
    return this;
  }

  /**
   * Chainable setter for SPP.
   *
   * @param {string} value SPP to set.
   * @return This UriBuilder instance.
   * @method UuApp.Uri.UriBuilder#setSpp
   */
  static setSpp(value) {
    // "static" method
    return new UriBuilder().setSpp(value);
  }

  /**
   * Chainable setter for product.
   *
   * @param {string} value Product to set.
   * @return This UriBuilder instance.
   * @method UuApp.Uri.UriBuilder#setProduct
   */
  static setProduct(value) {
    // "static" method
    return new UriBuilder().setProduct(value);
  }

  /**
   * Equivalent to <code>new UriBuilder().setTid(value)</code>.
   *
   * @param {string} value Tenant ID to set.
   * @return New UriBuilder instance.
   * @method UuApp.Uri.UriBuilder.setTid
   * @see UuApp.Uri.UriBuilder#setTid
   */
  setTid(value) {
    // "instance" method
    if (value != null) UriParser.validateTid(value);
    this._tid = value != null ? value : null;
    return this;
  }

  /**
   * Chainable setter for tenant ID.
   *
   * @param {string} value Tenant ID to set.
   * @return This UriBuilder instance.
   * @method UuApp.Uri.UriBuilder#setTid
   */
  static setTid(value) {
    // "static" method
    return new UriBuilder().setTid(value);
  }

  /**
   * Equivalent to <code>new UriBuilder().setAwid(value)</code>.
   *
   * @param {string} value awid to set.
   * @return New UriBuilder instance.
   * @method UuApp.Uri.UriBuilder.setAwid
   * @see UuApp.Uri.UriBuilder#setAwid
   */
  setAwid(value) {
    // "instance" method
    if (value != null) UriParser.validateAwid(value);
    this._awid = value != null ? value : null;
    return this;
  }

  /**
   * Chainable setter for awid.
   *
   * @param {string} value awid to set.
   * @return This UriBuilder instance.
   * @method UuApp.Uri.UriBuilder#setAwid
   */
  static setAwid(value) {
    // "static" method
    return new UriBuilder().setAwid(value);
  }

  /**
   * Equivalent to <code>new UriBuilder().setWorkspace(value)</code>.
   *
   * @param {string} value Workspace to set.
   * @return New UriBuilder instance.
   * @method UuApp.Uri.UriBuilder.setWorkspace
   * @see UuApp.Uri.UriBuilder#setWorkspace
   */
  static setWorkspace(value) {
    // "static" method
    return new UriBuilder().setWorkspace(value);
  }

  /**
   * Chainable setter for use case.
   *
   * @param {string} value Use case to set.
   * @return This UriBuilder instance.
   * @method UuApp.Uri.UriBuilder#setUseCase
   */
  static setUseCase(value) {
    // "static" method
    return new UriBuilder().setUseCase(value);
  }

  /**
   * Equivalent to <code>new UriBuilder().setParameters(value)</code>.
   *
   * @param {string} value Parameters to set.
   * @return New UriBuilder instance.
   * @method UuApp.Uri.UriBuilder.setParameters
   * @see UuApp.Uri.UriBuilder#setParameters
   */
  setParameters(value) {
    // "instance" method
    this._parameters = {};
    if (value) for (let k in value) this.setParameter(k, value[k]);
    return this;
  }

  /**
   * Chainable setter for parameters (replaces all parameters).
   *
   * @param {string} value Parameters to set.
   * @return This UriBuilder instance.
   * @method UuApp.Uri.UriBuilder#setParameters
   */
  static setParameters(value) {
    // "static" method
    return new UriBuilder().setParameters(value);
  }
  getPort() {
    return this._port != null ? Number(this._port) : this._port;
  }
  get port() {
    return this.getPort();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set port(attr) {
    this.throwOnSet("port");
  }

  /**
   * Equivalent to <code>new UriBuilder().setPort(value)</code>.
   *
   * @param {(string|number)} value Port to set.
   * @return New UriBuilder instance.
   * @method UuApp.Uri.UriBuilder.setPort
   * @see UuApp.Uri.UriBuilder#setPort
   */
  setPort(value) {
    if (value != null) UriParser.validatePort(value);
    this._port = value != null ? value : null;
    return this;
  }
  getGateway() {
    return UriBuilder.formatGateway(this._scheme, this._hostname, this._port);
  }
  get gateway() {
    return this.getGateway();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set gateway(attr) {
    this.throwOnSet("gateway");
  }

  /**
   * Equivalent to <code>new UriBuilder().setGateway(value)</code>.
   *
   * @param {string} value Gateway to set.
   * @return New UriBuilder instance.
   * @method UuApp.Uri.UriBuilder.setGateway
   * @see UuApp.Uri.UriBuilder#setGateway
   */
  setGateway(value) {
    let obj = value != null ? UriParser.parseGateway(value) : null;
    this._scheme = obj && obj.scheme || null;
    this._hostname = obj && obj.hostname || null;
    this._port = obj && obj.port != null ? obj.port : null;
    return this;
  }
  getProduct() {
    return UriBuilder.formatProduct(this._vendor, this._app, this._subApp, this._spp);
  }
  get product() {
    return this.getProduct();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set product(attr) {
    this.throwOnSet("product");
  }

  /**
   * Equivalent to <code>new UriBuilder().setProduct(value)</code>.
   *
   * @param {string} value Product to set.
   * @return New UriBuilder instance.
   * @method UuApp.Uri.UriBuilder.setProduct
   * @see UuApp.Uri.UriBuilder#setProduct
   */
  setProduct(value) {
    let obj = value ? UriParser.parseProduct(value) : {};
    this._vendor = obj.vendor || null;
    this._app = obj.app || null;
    this._subApp = obj.subApp || null;
    this._spp = obj.spp || null;
    return this;
  }
  getWorkspace() {
    return UriBuilder.formatWorkspace(this._tid, this._awid);
  }
  get workspace() {
    return this.getWorkspace();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set workspace(attr) {
    this.throwOnSet("workspace");
  }

  /**
   * Chainable setter for workspace ID.
   *
   * @param {string} value Workspace ID to set.
   * @return This UriBuilder instance.
   * @method UuApp.Uri.UriBuilder#setWorkspace
   */
  setWorkspace(value) {
    let obj = value ? UriParser.parseWorkspace(value) : {};
    this._tid = obj.tid || null;
    this._awid = obj.awid || null;
    return this;
  }
  getUseCase() {
    return this._useCase;
  }
  get useCase() {
    return this.getUseCase();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set useCase(attr) {
    this.throwOnSet("useCase");
  }

  /**
   * Equivalent to <code>new UriBuilder().setUseCase(value)</code>.
   *
   * @param {string} value Use case to set.
   * @return New UriBuilder instance.
   * @method UuApp.Uri.UriBuilder.setUseCase
   * @see UuApp.Uri.UriBuilder#setUseCase
   */
  setUseCase(value) {
    if (value != null) {
      value = value.replace(/(^\/+|\/+$)/g, "");
      if (value) {
        UriParser.validateUseCase(encodeURIComponent(value));
      } else {
        value = null;
      }
    }
    this._useCase = value;
    return this;
  }
  throwOnSet(attr) {
    throw new BaseError(`
Setting of "${attr}" and other properties via property access 
is prohibited with UriBuilder to prevent typos. 
Use get${attr[0].toUpperCase()}${attr.substr(1)}() and 
set${attr[0].toUpperCase()}${attr.substr(1)}(value) instead.
`);
  }
}
Uri.prototype.Builder = UriBuilder;
module.exports = UriBuilder;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-uri/src/uri-parser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {
  BaseError
} = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");
const InvalidUriPartError = __webpack_require__("../../node_modules/uu_appg01_core-uri/src/invalid-uri-part-error.js");
const UNRESERVED = "[\\w\\.\\-~]";
const UNRESERVED_ENCODED = "[\\w\\.\\-~%]";
const IDENTIFIER = "[a-zA-Z0-9_]";
const SCHEME = `(${UNRESERVED}+)`;

// No reason to match IPv4 (invalid IP address is always
// matched as generic hostname - we cannot distinguish them)
// IPV4_PART = "(25[0-5]|2[0-5][0-9]|1[0-9][0-9]|[0-9][0-9]?)"
// IPV4 = "(#{IPV4_PART}(\\.#{IPV4_PART}){3})"

// Only rough validation
// see http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses

const IPV6_PART = "([0-9a-fA-F]{1,4})";
const IPV6 = `(\\[${IPV6_PART}(:(${IPV6_PART})?){1,7}\\])`;
const HOSTNAME = `(${IPV6}|${UNRESERVED}+)`;
const PORT = "(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[0-5][0-9]{4}|[1-9][0-9]{0,3})";
const GATEWAY = `(${SCHEME}://${HOSTNAME}(:${PORT})?)`;
const VENDOR = `(${IDENTIFIER}{1,32})`;
const APP = `(${IDENTIFIER}{1,32})`;
const SUB_APP = `(${IDENTIFIER}{1,32})`;
const SPP = `(${IDENTIFIER}{1,32})`;
const PRODUCT = `(?=[^/]{1,131}(?:/|$))((?:${VENDOR}\\-)?${APP}(?:\\-${SUB_APP}(?:\\-${SPP})?)?)`;
const TID = `(${IDENTIFIER}{1,32})`;
const AWID = `(${IDENTIFIER}{1,32})`;
const WORKSPACE = `(?=[^/\\?]{1,65}(?:/|\\?|$))((?:${TID}\\-)?${AWID})`;
const USE_CASE = `(${UNRESERVED_ENCODED}+(?:/${UNRESERVED_ENCODED}+)*)`;
const PARAMETER_NAME = `(?:${UNRESERVED_ENCODED}+)`;
const PARAMETER_NAME_DECODED = "(?:[\\w\\.\\-~\\[\\]]+)";
const PARAMETER_VALUE = "(?:[^=&#]*)";
const PARAMETER = `(?:(?:${PARAMETER_NAME}(?:=${PARAMETER_VALUE})?)?)`;
const PARAMETERS = `(${PARAMETER}(?:&${PARAMETER})*)`;
const URI_REGEXP = new RegExp(`^(?:${GATEWAY})?\\/${PRODUCT}\\/${WORKSPACE}(?:/${USE_CASE})?\\/?(?:\\?${PARAMETERS}?)?$`);
const SCHEME_REGEXP = new RegExp(`^${SCHEME}$`);
const HOSTNAME_REGEXP = new RegExp(`^${HOSTNAME}$`);
const PORT_REGEXP = new RegExp(`^${PORT}$`);
const GATEWAY_REGEXP = new RegExp(`^${GATEWAY}$`);
const VENDOR_REGEXP = new RegExp(`^${VENDOR}$`);
const APP_REGEXP = new RegExp(`^${APP}$`);
const SUB_APP_REGEXP = new RegExp(`^${SUB_APP}$`);
const SPP_REGEXP = new RegExp(`^${SPP}$`);
const PRODUCT_REGEXP = new RegExp(`^${PRODUCT}$`);
const TID_REGEXP = new RegExp(`^${TID}$`);
const AWID_REGEXP = new RegExp(`^${AWID}$`);
const WORKSPACE_REGEXP = new RegExp(`^${WORKSPACE}$`);
const USE_CASE_REGEXP = new RegExp(`^${USE_CASE}$`);
const PARAMETER_NAME_DECODED_REGEXP = new RegExp(`^${PARAMETER_NAME_DECODED}$`);
class UriParser {
  parse(str, UriBuilder) {
    if (!UriBuilder) throw new BaseError("UriBuilder must be provided.");
    let result = (str || "").match(URI_REGEXP);
    //      console.log(result);
    if (!result) throw new BaseError("Parse error - invalid uri: " + (str || ""));
    UriBuilder.setScheme(result[2]);
    UriBuilder.setHostname(result[3]);
    UriBuilder.setPort(result[10]);
    UriBuilder.setVendor(result[12]);
    UriBuilder.setApp(result[13]);
    UriBuilder.setSubApp(result[14]);
    UriBuilder.setSpp(result[15]);
    UriBuilder.setTid(result[17]);
    UriBuilder.setAwid(result[18]);
    UriBuilder.setUseCase(result[19] ? decodeURIComponent(result[19]) : null);
    let uriBuilder = UriBuilder;
    let params = result[20];
    if (params) {
      params.split("&").forEach(function (pair) {
        if (!pair) return;
        let eqlSignIdx = pair.indexOf("=");
        let k = eqlSignIdx !== -1 ? pair.substr(0, eqlSignIdx) : pair;
        let v = eqlSignIdx !== -1 ? pair.substr(eqlSignIdx + 1) : "";
        uriBuilder.setParameter(decodeURIComponent(k), decodeURIComponent(v));
      });
    }
    return uriBuilder;
  }
  format(uri) {
    let parts = [];
    parts.push(`${uri.getGateway() || ""}/${uri.getProduct() || ""}/${uri.getWorkspace() || ""}`);
    let uc = uri.getUseCase();
    if (uc) {
      if (uc.charAt(0) !== "/") parts.push("/");
      parts.push(encodeURI(uc));
    }
    parts = [parts.join("").replace(/\/+$/, "")]; // remove all trailing slashes
    let params = uri.getParameters();
    let paramParts = this._createParamParts(params);
    parts = parts.concat(paramParts);
    return parts.join("");
  }
  parseGateway(value) {
    if (typeof value !== "string") throw new InvalidUriPartError("gateway", value, GATEWAY_REGEXP);
    let result = value.match(GATEWAY_REGEXP);
    if (!result) throw new InvalidUriPartError("gateway", value, GATEWAY_REGEXP);
    //  console.log(result);
    //      ["http://example.com:123", "http://example.com:123", "http",
    //       "example.com", undefined, undefined,
    //       undefined, undefined, undefined,
    //       ":123", "123"]
    return {
      scheme: result[2],
      hostname: result[3],
      port: result[10]
    };
  }
  formatGateway(scheme, hostname, port) {
    if (!scheme && !hostname && !port) return null;
    this.validateScheme(scheme);
    this.validateHostname(hostname);
    if (port != null) this.validatePort(port);
    return `${scheme}://${hostname}${port != null ? ":" + port : ""}`;
  }
  parseProduct(value) {
    if (typeof value !== "string") throw new InvalidUriPartError("product", value, PRODUCT_REGEXP);
    let result = value.match(PRODUCT_REGEXP);
    if (!result) throw new InvalidUriPartError("product", value, PRODUCT_REGEXP);
    return {
      vendor: result[2],
      app: result[3],
      subApp: result[4],
      spp: result[5]
    };
  }
  formatProduct(vendor, app, subApp, spp) {
    if (!vendor && !app && !subApp && !spp) return null;
    if (vendor) this.validateVendor(vendor);
    this.validateApp(app);
    if (subApp) this.validateSubApp(subApp);
    if (spp) this.validateSpp(spp);
    let result = [];
    if (vendor) result.push(vendor + "-");
    result.push(app);
    if (subApp) result.push("-" + subApp);
    if (spp) result.push("-" + spp);
    return result.join("");
  }
  parseWorkspace(value) {
    if (typeof value !== "string") throw new InvalidUriPartError("workspace", value, WORKSPACE_REGEXP);
    let result = value.match(WORKSPACE_REGEXP);
    if (!result) throw new InvalidUriPartError("workspace", value, WORKSPACE_REGEXP);
    return {
      tid: result[2],
      awid: result[3]
    };
  }
  formatWorkspace(tid, awid) {
    if (!tid && !awid) return null;
    if (tid) this.validateTid(tid);
    this.validateAwid(awid);
    let result = [];
    if (tid) result.push(tid + "-");
    result.push(awid);
    return result.join("");
  }
  formatParameters(params) {
    let parts = this._createParamParts(params);
    return parts.join("");
  }
  _createParamParts(params) {
    let parts = [];
    let paramKeys = Object.keys(params);
    paramKeys.sort();
    let first = true;
    for (let i = 0; i < paramKeys.length; i++) {
      let k = paramKeys[i];
      let value = params[k];
      if (Array.isArray(value)) {
        value.forEach(v => {
          this._encodeParams(first, k, v, parts);
          first = false;
        });
      } else {
        this._encodeParams(first, k, value, parts);
        first = false;
      }
    }
    return parts;
  }
  _encodeParams(first, k, v, parts) {
    parts.push(first ? "?" : "&");
    parts.push(encodeURIComponent(k));
    if (v == null || v === "") return parts;
    parts.push("=");
    parts.push(encodeURIComponent(v));
    return parts;
  }
  validate(value, regExp, name) {
    if (typeof value !== "string") {
      throw new InvalidUriPartError(name, value, regExp);
    }
    if (typeof regExp === "string") {
      regExp = new RegExp("^" + regExp + "$");
    }
    if (!value.match(regExp)) {
      throw new InvalidUriPartError(name, value, regExp);
    }
  }
  validateScheme(value, regExp = SCHEME_REGEXP) {
    this.validate(value, regExp, "scheme");
  }
  validateHostname(value, regExp = HOSTNAME_REGEXP) {
    this.validate(value, regExp, "hostname");
  }
  validatePort(value, regExp = PORT_REGEXP) {
    value = typeof value === "number" ? value + "" : value;
    this.validate(value, regExp, "port");
  }
  validateGateway(value, regExp = GATEWAY_REGEXP) {
    this.validate(value, regExp, "gateway");
  }
  validateVendor(value, regExp = VENDOR_REGEXP) {
    this.validate(value, regExp, "vendor");
  }
  validateApp(value, regExp = APP_REGEXP) {
    this.validate(value, regExp, "app");
  }
  validateSubApp(value, regExp = SUB_APP_REGEXP) {
    this.validate(value, regExp, "subApp");
  }
  validateSpp(value, regExp = SPP_REGEXP) {
    this.validate(value, regExp, "spp");
  }
  validateProduct(value, regExp = PRODUCT_REGEXP) {
    this.validate(value, regExp, "product");
  }
  validateTid(value, regExp = TID_REGEXP) {
    this.validate(value, regExp, "tid");
  }
  validateAwid(value, regExp = AWID_REGEXP) {
    this.validate(value, regExp, "awid");
  }
  validateWorkspace(value, regExp = WORKSPACE_REGEXP) {
    this.validate(value, regExp, "workspace");
  }
  validateUseCase(value, regExp = USE_CASE_REGEXP) {
    this.validate(value, regExp, "useCase");
  }
  validateParameterName(value, regExp = PARAMETER_NAME_DECODED_REGEXP) {
    this.validate(value, regExp, "parameterName");
  }
  validateParameterValue(value, regExp = null) {
    if (value != null && !(typeof value === "string" || Array.isArray(value))) throw new InvalidUriPartError("parameterValue", value, String);
    // for our generic uuUri following check is always true; will skip for optimization
    //      if (value != null && !encodeURIComponent(value).match(new RegExp("^" + PARAMETER_VALUE + "$"))) throw new InvalidUriPartError("parameterValue", value, PARAMETER_VALUE);
  }
}

module.exports = new UriParser();

/***/ }),

/***/ "../../node_modules/uu_appg01_core-uri/src/uri.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  BaseError
} = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");
const EMPTY = {};

/**
 * @class UuApp.Uri.Uri
 * @classdesc
 * Immutable representation of uuUri. An instance of the Uri can be obtained either by
 * {@link UuApp.Uri.Uri.parse Uri.parse} or by using {@link UuApp.Uri.UriBuilder UriBuilder} class.
 * Note that minimal Uri consists of at least "app" and "tid".
 *
 * Examples of usage:
 *
 *     // uri from parsing current location
 *     let locationUri = Uri.parse(location.protocol + "//" + location.host + location.pathname); // "http://example.com/vendor-app/0-0/some/uc"
 *     let baseUri = locationUri.baseUri; // "http://example.com/vendor-app/0-0"
 *     let callUri = baseUri.join("+/getConfig"); // "http://example.com/vendor-app/0-0/getConfig"
 *
 *     // uri from parsing
 *     let uri = UuApp.Uri.Uri.parse("https://uuos9.plus4u.net/vendor-app-subapp-spp/tid-awid/useCase?p1=v1");
 *     console.log(uri.gateway, uri.product, uri.workspace, uri.useCase);
 *     let params = uri.parameters; // always returns new copy of parameter map
 *     for (let k in params) console.log(k, "=", params[k]); // p1 = v1
 *
 *     // uri from UriBuilder
 *     let uri2 = UuApp.Uri.UriBuilder.parse(uri).setWorkspace("0-0").setUseCase("sys/init").toUri();
 *     console.log(uri2.toString()); // https://uuos9.plus4u.net/vendor-app-subapp-spp/0-0/sys/init?p1=v1
 *
 *     // uri from parsing (with ECMAScript6 template string, e.g. when using transpilers like Babel)
 *     // Note that query parameter values shouldn't be injected via template string as they might need
 *     // to be encoded first.
 *     let product = "vendor-app";
 *     let workspace = "tid-awid";
 *     let uri3 = UuApp.Uri.Uri.parse(`https://uuos9.plus4u.net/${product}/${workspace}`);
 *
 * @see UuApp.Uri.UriBuilder
 */
class Uri {
  /**
   * New instance of URI should be created using {@link UuApp.Uri.Uri.parse}.
   * @private
   */
  constructor(scheme, hostname, port, vendor, app, subApp, spp, tid, awid, useCase, parameters) {
    this._scheme = scheme;
    this._hostname = hostname;
    this._port = port;
    this._vendor = vendor;
    this._app = app;
    this._subApp = subApp;
    this._spp = spp;
    this._tid = tid;
    this._awid = awid;
    this._useCase = useCase;
    this._memory = {};
    this._useCase = useCase ? useCase.replace(/^\//, "") : useCase;
    if (this._port && typeof this._port !== "number") {
      this._port = parseInt(this._port + "", 10);
    }
    this._memory.gatewayValue = EMPTY;
    this._memory.productValue = EMPTY;
    this._memory.workspaceValue = EMPTY;
    this._memory.baseUriValue = undefined;
    this._memory.relativeUriValue = undefined;
    this._memory.strValue = undefined;
    this._paramsValue = Object.assign({}, parameters);
    Object.freeze(this);
  }

  /**
   * Returns string representation of URI.
   * @return {string}
   * @method UuApp.Uri.Uri#toString
   */
  toString() {
    if (this._memory.strValue !== undefined) {
      return this._memory.strValue;
    } else {
      this._memory.strValue = this.Builder.format(this);
      return this._memory.strValue;
    }
  }

  /**
   * @see {@link UuApp.Uri.Uri#toString} for further information.
   * Getter to ensure consistency with Node.js URL.
   * @private
   */
  get href() {
    return this.toString();
  }
  toJSON() {
    return this.toString();
  }

  /**
   * Returns URI containing only mandatory routing data
   * (including only {#gateway}, {#product} and {#workspace}).
   * @throws {BaseError} In case URI does not contain all required parts.
   * @returns {UuApp.Uri.Uri}
   * @method UuApp.Uri.Uri#getBaseUri
   */
  getBaseUri() {
    if (this._memory.baseUriValue !== undefined) {
      return this._memory.baseUriValue;
    }
    if (this.getGateway() == null || this.getProduct() == null || this.getWorkspace() == null) {
      throw new BaseError("Insufficient URI - at least one of gateway, product and workspace is not set. Uri: " + this.toString());
    }
    this._memory.baseUri = this.Builder.parse(this).set({
      useCase: null
    }).clearParameters().toUri();
    return this._memory.baseUri;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getBaseUri} for further information.
   * @private
   */
  get baseUri() {
    return this.getBaseUri();
  }

  /**
   * Returns URI without gateway part.
   * @returns {UuApp.Uri.Uri}
   * @method UuApp.Uri.Uri#getRelativeUri
   */
  getRelativeUri() {
    if (this._memory.relativeUriValue !== undefined) {
      return this._memory.relativeUriValue;
    }
    this._memory.relativeUriValue = this.Builder.parse(this).set({
      gateway: null
    }).toUri();
    return this._memory.relativeUriValue;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getRelativeUri} for further information.
   * @private
   */
  get relativeUri() {
    return this.getRelativeUri();
  }

  /**
   * Returns Pathname (String representation of URI without gateway and parameters).
   * Getter to ensure consistency with Node.js URL.
   * @private
   * @returns {string}
   */
  get pathname() {
    return this.Builder.parse(this).set({
      gateway: null
    }).clearParameters().toString();
  }

  /**
   * Returns Gateway (formatted {#scheme}, {#hostname} and {#port})
   * @returns {string}
   * @method UuApp.Uri.Uri#getGateway
   */
  getGateway() {
    if (this._memory.gatewayValue !== EMPTY) {
      return this._memory.gatewayValue;
    } else {
      this._memory.gatewayValue = this.Builder.formatGateway(this._scheme, this._hostname, this._port);
      return this._memory.gatewayValue;
    }
  }

  /**
   * @see {@link UuApp.Uri.Uri#getGateway} for further information.
   * @private
   */
  get gateway() {
    return this.getGateway();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set gateway(attr) {
    this.throwOnSet(attr);
  }

  /**
   * @see {@link UuApp.Uri.Uri#getGateway} for further information.
   * Getter to ensure consistency with Node.js URL.
   * @private
   */
  get origin() {
    return this.getGateway();
  }

  /**
   * Returns Product (formatted {#vendor}, {#app}, {#sub_app} and {#spp})
   * @returns {string}
   * @method UuApp.Uri.Uri#getProduct
   */
  getProduct() {
    if (this._memory.productValue !== EMPTY) {
      return this._memory.productValue;
    } else {
      this._memory.productValue = this.Builder.formatProduct(this._vendor, this._app, this._subApp, this._spp);
      return this._memory.productValue;
    }
  }

  /**
   * @see {@link UuApp.Uri.Uri#getProduct} for further information.
   * @private
   */
  get product() {
    return this.getProduct();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set product(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Returns Workspace (formatted {#tid} and {#awid})
   * @returns {string}
   * @method UuApp.Uri.Uri#getWorkspace
   */
  getWorkspace() {
    if (this._memory.workspaceValue !== EMPTY) {
      return this._memory.workspaceValue;
    } else {
      this._memory.workspaceValue = this.Builder.formatWorkspace(this._tid, this._awid);
      return this._memory.workspaceValue;
    }
  }

  /**
   * @see {@link UuApp.Uri.Uri#getWorkspace} for further information.
   * @private
   */
  get workspace() {
    return this.getWorkspace();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set workspace(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Returns Scheme
   * @returns {string}
   * @method UuApp.Uri.Uri#getScheme
   */
  getScheme() {
    return this._scheme;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getScheme} for further information.
   * @private
   */
  get scheme() {
    return this.getScheme();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set scheme(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Returns Scheme with colon (:) on the end.
   * Getter to ensure consistency with Node.js URL.
   * @private
   * @returns {string}
   */
  get protocol() {
    return this.getScheme() + ":";
  }

  /**
   * Returns Hostname
   * @returns {string}
   * @method UuApp.Uri.Uri#getHostname
   */
  getHostname() {
    return this._hostname;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getHostname} for further information.
   * @private
   */
  get hostname() {
    return this.getHostname();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set hostname(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Returns Host (formatted {#hostname} and {#port})
   * Getter to ensure consistency with Node.js URL.
   * @private
   * @returns {string}
   */
  get host() {
    return this.getHostname() + ":" + this.getPort();
  }

  /**
   * Returns Port
   * @returns {number}
   * @method UuApp.Uri.Uri#getPort
   */
  getPort() {
    if (this._port) {
      return this._port;
    }
    if (this._scheme) {
      return this._scheme.match(/^https$/) ? 443 : 80;
    }
    return null;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getPort} for further information.
   * @private
   */
  get port() {
    return this.getPort();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set port(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Returns Vendor
   * @returns {string}
   * @method UuApp.Uri.Uri#getVendor
   */
  getVendor() {
    return this._vendor;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getVendor} for further information.
   * @private
   */
  get vendor() {
    return this.getVendor();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set vendor(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Returns Application
   * @returns {string}
   * @method UuApp.Uri.Uri#getApp
   */
  getApp() {
    return this._app;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getApp} for further information.
   * @private
   */
  get app() {
    return this.getApp();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set app(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Returns Sub-application
   * @returns {string}
   * @method UuApp.Uri.Uri#getSubApp
   */
  getSubApp() {
    return this._subApp;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getSubApp} for further information.
   * @private
   */
  get subApp() {
    return this.getSubApp();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set subApp(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Returns SPP
   * @returns {string}
   * @method UuApp.Uri.Uri#getSpp
   */
  getSpp() {
    return this._spp;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getSpp} for further information.
   * @private
   */
  get spp() {
    return this.getSpp();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set spp(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Returns Tenant ID
   * @returns {string}
   * @method UuApp.Uri.Uri#getTid
   */
  getTid() {
    return this._tid;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getTid} for further information.
   * @private
   */
  get tid() {
    return this.getTid();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set tid(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Returns Application workspace ID
   * @returns {string}
   * @method UuApp.Uri.Uri#getAwid
   */
  getAwid() {
    return this._awid;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getAwid} for further information.
   * @private
   */
  get awid() {
    return this.getAwid();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set awid(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Returns Use Case
   * @returns {string}
   * @method UuApp.Uri.Uri#getUseCase
   */
  getUseCase() {
    return this._useCase;
  }

  /**
   * @see {@link UuApp.Uri.Uri#getUseCase} for further information.
   * @private
   */
  get useCase() {
    return this.getUseCase();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set useCase(attr) {
    this.throwOnSet(attr);
  }

  /**
   * Map containing query parameters. If there're no parameters, empty map is returned (not a null).
   * Note that each access returns new copy of the map (to achieve immutability of the Uri class),
   * therefore usage should look like this:
   *
   *     // OPTIMAL (single read of "parameters" field on uri)
   *     let params = uri.parameters;
   *     for (let k in params) console.log(params[k]);
   *
   *     // SUB-OPTIMAL (multiple reads and therefore multiple copying of parameter map)
   *     // for (let k in uri.parameters) console.log(uri.parameters[k]);
   *
   * @method UuApp.Uri.Uri#getParameters
   */
  getParameters() {
    return Object.assign({}, this._paramsValue);
  }

  /**
   * @see {@link UuApp.Uri.Uri#getParameters} for further information.
   * @private
   */
  get parameters() {
    return this.getParameters();
  }

  /**
   * throws error to prevent from using setter
   * @param attr
   */
  set parameters(attr) {
    this.throwOnSet(attr);
  }

  /**
   * @see {@link UuApp.Uri.Uri#getParameters} for further information.
   * Getter to ensure consistency with Node.js URL.
   * @private
   */
  get searchParams() {
    return this.getParameters();
  }

  /**
   * Returns string representation of all URI parameters
   * Getter to ensure consistency with Node.js URL.
   * @private
   * @returns {string}
   */
  get search() {
    return this.Builder.formatParameters(this.getParameters());
  }

  /**
   * Replaces current path with specified absolute path (or adds a relative path to the current path) returning new Uri.
   * Query parameters are preserved only on last path. Resolving relative path and usage of "./" and "../" works as in standard
   * URLs (see {@link https://tools.ietf.org/html/rfc2396#appendix-C RFC 2396, examples}).
   *
   * Additionally, it's possible to use "+/" at the beginning of paths - paths starting
   * with "+/" are joined as if current path (to which new path is being joined) denoted a "folder", i.e. current path
   * is appended with slash (unless it already ends with slash) and new path is appended afterwards (see examples).
   *
   * @param {...string} path Absolute or relative paths to replace / add.
   * @return New Uri whose path is the result of the join.
   * @method UuApp.Uri.Uri#join
   * @example
   *  // replace path with an absolute path (effectively removing also query parameters)
   *  let uri = Uri.parse("https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1?a=b");
   *  let uri2 = uri.join("/vendor2-app2/tid2-awid2"); // https://uuos9.plus4u.net/vendor2-app2/tid2-awid2
   *
   *  // add relative paths
   *  let uri = Uri.parse("https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1");
   *  let uri2 = uri.join("sys/init?p=v");             // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/sys/init?p=v
   *  let uri3 = uri.join("+/sys/init?p=v");           // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1/sys/init?p=v
   *  let uri4 = uri.join("+/sys/?a=b", "init?c=d");   // https://uuos9.plus4u.net/vendor-app-subApp/tid-awid/uc1/sys/init?c=d
   */
  join( /* ... */
  ) {
    if (arguments.length <= 0) {
      return this;
    }
    let root = this.getGateway() || "";
    let path = this.toString().substr(root.length);
    for (let i = 0; i < arguments.length; ++i) {
      let pathPart = arguments[i];
      if (!pathPart) {
        continue;
      }
      path = path.replace(/[?#].*/, ""); // remove query part because we're going to add / replace path
      pathPart = pathPart.replace(/((^|\/)\.\.?)$/, "$1/"); // if new path part ends with two dots / one dot, treat it as a "folder", i.e. append "/"
      if (pathPart.charAt(0) === "/") {
        path = pathPart;
      } // new path part is absolute => replace whole path
      else if (pathPart.match(/^\+(\/|$)/)) {
        path = path.replace(/\/?$/, "/") + pathPart;
      } // new path part is relative with "+/" => append "/" and then new path
      else if (path.charAt(path.length - 1) === "/") {
        path += pathPart;
      } // new path part is relative and current path is a "folder" => append new path
      else {
        path = path.replace(/(^|\/)[^/]*$/, "$1") + pathPart;
      } // new path part is relative and current path is not a "folder" => replace last segment of current path
    }

    // normalize (modify segments to eliminate "../" and "./" from the path)
    let segments = [];
    path.split("/").forEach(function (part) {
      if (part === "..") {
        segments.pop();
      } else if (part !== "." && part !== "+") {
        segments.push(part);
      }
    });
    if (segments[0] !== "") {
      segments.unshift("");
    } // make sure that after "join" operation the path starts with "/"
    let resultPath = segments.join("/");
    return Uri.parse(root + resultPath);
  }
  throwOnSet(attr) {
    throw new BaseError("Cannot set " + attr + "on Uri because instances of Uri are immutable. Use UriBuilder instead.");
  }

  /**
   * Checks whether the other URI is equal to this one and returns true iff it is.
   *
   * @param {UuApp.Uri.Uri} uri Uri to check equality against.
   * @return True iff the specified uri is equal to this one.
   * @method UuApp.Uri.Uri#equals
   */
  equals(Uri) {
    return this.toString() === (Uri || "").toString();
  }

  /**
   * Get Uri Builder instance initialized with this Uri properties.
   *
   * @returns {UuApp.Uri.UriBuilder}
   * @method UuApp.Uri.Uri#getBuilder
   */
  getBuilder() {
    return this.Builder.parse(this);
  }

  /**
   * @param {(string|UuApp.Uri.Uri)} uriStr The string to parse as URI. If an instance of Uri class is given, it's returned as-is.
   * @return {UuApp.Uri.Uri} Parsed URI.
   * @method UuApp.Uri.Uri.parse
   * @example
   *    let uri = UuApp.Uri.Uri.parse("https://uuos9.plus4u.net/vendor-app/tid-awid/useCase?p1=v1");
   */
  static parse(uriStr) {
    if (uriStr instanceof Uri) {
      return uriStr;
    }
    return this.prototype.Builder.parse(uriStr).toUri();
  }
  static createBuilder() {
    return new this.prototype.Builder();
  }
}
module.exports = Uri;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-utils/src/base-error.js":
/***/ ((module) => {

"use strict";


/**
 * Ancestor of all errors raised by UAF. Extends standard
 * JavaScript error by unique error id, timestamp and also
 * option to provide error cause.
 */
class BaseError extends Error {
  /**
   * Creates new instance of error
   * @param message Error message
   * @param cause Error cause
   */
  constructor(message, cause = null) {
    if (message instanceof Error) {
      cause = message;
      message = null;
    }
    super(message ? message.toString() : "");
    this._id = "00000000000000000000000000000000".replace(/0/g, function () {
      return (~~(Math.random() * 16)).toString(16);
    });
    this._timestamp = new Date();
    this._cause = cause;
    this._name = this.constructor.name;
  }

  /**
   * Returns unique error ID (helps with lookup of error in logs).
   * @returns {string} Unique error ID
   */
  get id() {
    return this._id;
  }

  /**
   * Sets error id.
   * @param {string} id error ID
   */
  set id(id) {
    this._id = id;
  }

  /**
   * Returns timestamp of error instantiation (may differ from error log time).
   * @returns {Date} Timestamp of error instantiation
   */
  get timestamp() {
    return this._timestamp;
  }

  /**
   * Returns error cause
   * @returns {Error|null} Error cause
   */
  get cause() {
    return this._cause;
  }

  /**
   * Sets error cause.
   * @param {Error|null} error Error cause
   */
  set cause(error) {
    this._cause = error;
  }

  /**
   * Returns error name
   * @return {string} Error name
   */
  get name() {
    return this._name;
  }
}
module.exports = BaseError;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-utils/src/base64.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Buffer = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/buffer.compat.js");
class Base64 {
  static encode(value, encoding = "utf8") {
    return Buffer.from(value, encoding).toString('base64');
  }
  static decode(value, encoding = "utf8") {
    let rawData = Buffer.from(value, 'base64');
    if (encoding === "binary") {
      return rawData;
    } else {
      return rawData.toString(encoding);
    }
  }
  static urlSafeEncode(value, encoding = "utf8", noPadding = true) {
    if (typeof encoding === "boolean") {
      noPadding = encoding;
      encoding = "utf8";
    }
    let base64 = this.encode(value, encoding);
    base64 = base64.replace(/\+/g, '-').replace(/\//g, '_');
    if (noPadding) {
      base64 = base64.replace(/=/g, '');
    }
    return base64;
  }
  static urlSafeDecode(value, encoding = "utf8") {
    let base64 = value.replace(/-/g, '+').replace(/_/g, '/');
    return this.decode(base64, encoding);
  }
}
module.exports = Base64;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-utils/src/buffer.compat.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Workaround to add Buffer polyfill for Base64 komponent which nees it. We need to
// keep using Buffer for backward compatibility as it is returned from "decode" method.
// TODO Might be removed in next major version.
module.exports = typeof Buffer !== "undefined" ? Buffer : (__webpack_require__("../../node_modules/buffer/index.js").Buffer);

/***/ }),

/***/ "../../node_modules/uu_appg01_core-utils/src/config/config-chain.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/base-error.js");
const ValueConverter = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/value-converter.js");
const Json = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/json.js");
const expression = /(?:^|[^\\])(\${([\w_.]+)(?::([^}]*))?}|#{([^}]+)})/;
class ConfigChain {
  constructor(sources, profiles) {
    this._sources = sources;
    this._profiles = profiles;
    this._custom = {};
  }
  activeProfiles() {
    return Json.parse(Json.stringify(this._profiles));
  }
  get(name, recursive = true, loopCheck = []) {
    let result;
    let self = this;
    if (recursive) {
      let parts = name.split(".");
      while (parts.length > 0) {
        let name = parts.join(".");
        if (this._custom[name] !== undefined) return this._custom[name];
        this._sources.forEach(function (source) {
          let value = source.get(name);
          if (value !== undefined && result === undefined) result = self._resolve(value, loopCheck);
        });
        if (result !== undefined) return result;
        let length = parts.length;
        let idx = length === 1 ? 0 : length - 2;
        parts.splice(idx, 1);
      }
    } else {
      if (this._custom[name] !== undefined) return this._custom[name];
      this._sources.forEach(function (source) {
        let value = source.get(name);
        if (value !== undefined && result === undefined) result = self._resolve(value, loopCheck);
      });
      if (result !== undefined) return result;
    }
    return result;
  }
  getString(name, recursive = true) {
    let value = this.get(name, recursive);
    return ValueConverter.toString(value);
  }
  getNumber(name, recursive = true) {
    let value = this.get(name, recursive);
    return ValueConverter.toNumber(value);
  }
  getBoolean(name, recursive = true) {
    let value = this.get(name, recursive);
    return ValueConverter.toBoolean(value);
  }
  getTime(name, recursive = true) {
    let value = this.get(name, recursive);
    return ValueConverter.toTime(value);
  }
  getClass(name, sourcePath, recursive = true) {
    let value = this.get(name, recursive);
    sourcePath = !sourcePath ? this._serverSourcePath() : sourcePath;
    return ValueConverter.toClass(value, sourcePath);
  }
  getArray(name, type = null, recursive = true, sourcePath = null) {
    let value = this.get(name, recursive);
    sourcePath = !sourcePath ? this._serverSourcePath() : sourcePath;
    return ValueConverter.toArray(value, type, sourcePath);
  }
  set(name, value) {
    this._custom[name] = value;
  }
  delete(name) {
    delete this._custom[name];
  }
  hasKey(name, recursive = true) {
    let hasKey = false;
    if (recursive) {
      let parts = name.split(".");
      while (parts.length > 0) {
        let name = parts.join(".");
        if (this._custom[name] !== undefined) return true;
        this._sources.forEach(function (source) {
          if (!hasKey && source.hasKey(name)) hasKey = true;
        });
        if (hasKey) {
          return hasKey;
        }
        let length = parts.length;
        let idx = length === 1 ? 0 : length - 2;
        parts.splice(idx, 1);
      }
    } else {
      if (this._custom[name] !== undefined) return true;
      this._sources.forEach(function (source) {
        if (source.hasKey(name)) {
          hasKey = true;
        }
      });
    }
    return hasKey;
  }
  toJSON() {
    let result = {};
    let resolver = this._resolve.bind(this);
    this._sources.reverse();
    this._sources.forEach(function (source) {
      let sourceJson = source.toJSON();
      let keys = Object.keys(sourceJson);
      keys.forEach(function (key) {
        result[key] = resolver(sourceJson[key]);
      });
    });
    this._sources.reverse();
    let keys = Object.keys(this._custom);
    let custom = this._custom;
    keys.forEach(function (key) {
      result[key] = resolver(custom[key]);
    });
    return result;
  }
  load(failOnError = false) {
    this._sources.reverse();
    this._sources.forEach(function (source) {
      source.load(failOnError);
    });
    this._sources.reverse();
  }
  _resolve(value, loopCheck = []) {
    if (!!value && value.constructor === Object) {
      let newObject = {};
      for (let key of Object.keys(value)) {
        newObject[key] = this._resolve(value[key]);
      }
      return newObject;
    }
    if (!(typeof value === "string") && !(value instanceof String)) return value;
    let matchResult = value.match(expression);
    if (!matchResult) {
      return value;
    } else {
      let expression = matchResult[1];
      let key = matchResult[2];
      let defolt = matchResult[3];
      let prog = matchResult[4];
      if (prog) {
        value = eval(prog);
        return this._resolve(value);
      } else {
        if (loopCheck.includes(key)) throw new BaseError("endless configuration loop caused by [" + loopCheck + "]");
        loopCheck.push(key);
        let resolved = this.get(key, true, loopCheck);
        if (!resolved) resolved = defolt;
        value = value.replace(new RegExp(expression.replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&"), "g"), resolved);
        return this._resolve(value);
      }
    }
  }
  _serverSourcePath() {
    return this.get("server_root");
  }
}
module.exports = ConfigChain;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-utils/src/config/config-source.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Json = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/json.js");
if (typeof window == "undefined") {
  var fs = __webpack_require__("?b0ca");
}
const SRC_TTL = "_ttl";
class ConfigSource {
  constructor(source, ttl = -1) {
    this._ttl = ttl;
    if (typeof source === "string" || source instanceof String) {
      let match = /^file:\/\/(.*)/i.exec(source);
      if (match !== null) {
        if (typeof window != "undefined") throw new TypeError("Unable to use " + source + " as configuration source in browser environment.");
        this._fileSrc = match[1];
      } else {
        match = /^env:\/\/([a-z_][a-z0-9_]*)/i.exec(source);
        if (match !== null) {
          this._senvSrc = match[1];
        } else {
          throw new TypeError("unable to use " + source + " as configuration source");
        }
      }
    } else if (source instanceof RegExp) {
      this._menvSrc = source;
    } else if (source && typeof source === "object") {
      this._data = source;
    } else {
      throw new TypeError("unable to use " + typeof source.constructor + " as configuration source");
    }
  }
  load(failOnError = false) {
    let loadedSrc;
    try {
      if (this._fileSrc !== undefined && this._fileSrc) {
        loadedSrc = this._fileSrc;
        let data = fs.readFileSync(this._fileSrc, "utf8");
        this._data = this._parse(data);
      } else if (this._senvSrc !== undefined && this._senvSrc) {
        loadedSrc = this._senvSrc;
        let data = ({"NAME":"uu_appg01_core","VERSION":"5.20.1","NAMESPACE":"UuApp","OUTPUT_NAME":"uu_appg01_core","NODE_ENV":(typeof process !== "undefined" && process.env && (process.env.NODE_ENV) || "development"),"TARGET_ENVIRONMENT":"browser","MOCK_DATA_BASE_URI":""})[this._senvSrc] || "";
        this._data = this._parse(data);
      } else if (this._menvSrc !== undefined && this._menvSrc) {
        loadedSrc = this._menvSrc;
        let regex = this._menvSrc;
        let envKeys = Object.keys(({"NAME":"uu_appg01_core","VERSION":"5.20.1","NAMESPACE":"UuApp","OUTPUT_NAME":"uu_appg01_core","NODE_ENV":(typeof process !== "undefined" && process.env && (process.env.NODE_ENV) || "development"),"TARGET_ENVIRONMENT":"browser","MOCK_DATA_BASE_URI":""}));
        let result = {};
        envKeys.forEach(function (key) {
          if (regex.test(key)) {
            result[key.toLowerCase()] = ({"NAME":"uu_appg01_core","VERSION":"5.20.1","NAMESPACE":"UuApp","OUTPUT_NAME":"uu_appg01_core","NODE_ENV":(typeof process !== "undefined" && process.env && (process.env.NODE_ENV) || "development"),"TARGET_ENVIRONMENT":"browser","MOCK_DATA_BASE_URI":""})[key];
          }
        });
        this._data = result;
      }
      if (this._data[SRC_TTL] != null) {
        this._ttl = Number(this._data[SRC_TTL]);
      }
      this._loaded = new Date();
    } catch (err) {
      let errMsg = `Loading of configuration from source [${loadedSrc}] failed: ${err.toString()}`;
      if (failOnError) {
        throw new Error(errMsg);
      } else {
        console.log(errMsg);
      }
    }
  }
  get(name) {
    if (this._reload()) this.load();
    return this._data[name];
  }
  setTtl(ttl) {
    this._ttl = ttl;
  }
  hasKey(name) {
    if (this._reload()) this.load();
    return this._data[name] !== undefined;
  }
  toJSON(failOnError = false) {
    if (this._reload()) this.load(failOnError);
    return Json.parse(Json.stringify(this._data));
  }
  _parse(sourceData) {
    if (/^[\r\n\t ]*{[\s\S]*}[\r\n\t ]*$/.test(sourceData)) {
      return Json.parse(sourceData);
    } else {
      let result = {};
      sourceData = sourceData.replace(/\r\n?/g, "\n");
      let splitData = sourceData.split("\n");
      splitData.forEach(function (line) {
        line = line.trim();
        if (/^[#!]/.test(line)) return;
        let splitLine = line.split(/[=:](.*)/, 2);
        let name = splitLine[0];
        let value = splitLine[1];
        if (name === null) return;
        name = name.trim();
        if (name.length === 0) return;
        if (value === undefined) {
          value = null;
        } else {
          value = value.trimLeft();
          try {
            value = Json.parse(value.trim());
          } catch (err) {
            // do nothing
          }
        }
        result[name] = value;
      });
      return result;
    }
  }
  _reload() {
    if (!this._loaded) return true;
    if (this._ttl < 0) return false;
    let t = new Date();
    let reload = t.getTime() > this._loaded.getTime() + this._ttl * 1000;
    if (this._fileSrc && reload) {
      let stats = fs.statSync(this._fileSrc);
      if (stats.isFile()) {
        let mTime = new Date(stats["mtime"]);
        if (mTime.getTime() > this._loaded.getTime()) {
          return true;
        } else {
          this._loaded = t;
          return false;
        }
      } else {
        return false;
      }
    } else {
      return reload;
    }
  }
}
module.exports = ConfigSource;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-utils/src/config/config.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


const ConfigSource = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/config/config-source.js");
const ConfigChain = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/config/config-chain.js");
const Json = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/json.js");
if (typeof window == "undefined") {
  const DupValidator = __webpack_require__("?92d6");
  DupValidator.ensureSingleVersion(module);
  var path = __webpack_require__("?ba0d");
  var fs = __webpack_require__("?b0ca");
  var os = __webpack_require__("?af91");
}

/**
 * Main class for working with configuration (reading, updating, source registration)
 */
class Config {
  /**
   * Allows to provide default configuration of library or application.
   * @param {string|RegExp|Object} source
   */
  static registerImplicitSource(source) {
    Config.implicitSources.push(new ConfigSource(source));
    let profiles = Config.activeProfiles;
    if (profiles && profiles.length > 0) {
      Config.activateProfiles(...profiles);
    }
  }

  /**
   * Allows registration of additional configuration source
   * @param {String} profile
   * @param {string|RegExp|Object} source
   * @param {Number} ttl
   */
  static registerSource(profile, source, ttl) {
    let profileSources = Config.sources[profile];
    if (profileSources) {
      profileSources.push(new ConfigSource(source, ttl));
    } else {
      Config.sources[profile] = [new ConfigSource(source, ttl)];
    }
    let profiles = Config.activeProfiles;
    if (profiles.includes(profile)) {
      Config.activateProfiles(...profiles);
    }
  }
  static atProfileActivation(funktion, ...profiles) {
    Config.callbacks.push([funktion, profiles]);
  }

  /**
   * Activates given set of configuration profiles
   * @param {...profiles} profiles
   */
  static activateProfiles(...profiles) {
    let sources = [];
    if (typeof window == "undefined") {
      // 1) registered sources
      profiles.forEach(function (profile) {
        let profileSources = Config.sources[profile] || [];
        profileSources.reverse();
        sources.push(...profileSources);
        profileSources.reverse();
      });
      // 2) "legacy" source for backward compatibility with C3
      sources.push(new ConfigSource("env://SERVER_CFG"));
      // 3) configuration from environment
      sources.push(new ConfigSource(/.*/));
      // 4) configuration files
      let cfgDir = ({"NAME":"uu_appg01_core","VERSION":"5.20.1","NAMESPACE":"UuApp","OUTPUT_NAME":"uu_appg01_core","NODE_ENV":(typeof process !== "undefined" && process.env && (process.env.NODE_ENV) || "development"),"TARGET_ENVIRONMENT":"browser","MOCK_DATA_BASE_URI":""})["CONFIG_DIR"] || Config._getDefaultConfigDir();
      let sysCfgDir = ({"NAME":"uu_appg01_core","VERSION":"5.20.1","NAMESPACE":"UuApp","OUTPUT_NAME":"uu_appg01_core","NODE_ENV":(typeof process !== "undefined" && process.env && (process.env.NODE_ENV) || "development"),"TARGET_ENVIRONMENT":"browser","MOCK_DATA_BASE_URI":""})["SYS_CONFIG_DIR"] || Config._getDefaultSysConfigDir();
      let testCfgDir = Config._getTestConfigDir();
      profiles.forEach(function (profile) {
        let profileCfgPropertiesFile = path.join(cfgDir, profile.toLowerCase() + ".properties");
        let profileCfgJsonFile = path.join(cfgDir, profile.toLowerCase() + ".json");
        let sysProfileCfgPropertiesFile = path.join(sysCfgDir, profile.toLowerCase() + ".properties");
        let sysProfileCfgJsonFile = path.join(sysCfgDir, profile.toLowerCase() + ".json");
        let testProfileCfgPropertiesFile = path.join(testCfgDir, profile.toLowerCase() + ".properties");
        let testProfileCfgJsonFile = path.join(testCfgDir, profile.toLowerCase() + ".json");
        if (fs.existsSync(testProfileCfgJsonFile)) {
          sources.push(new ConfigSource("file://" + testProfileCfgJsonFile));
        }
        if (fs.existsSync(sysProfileCfgJsonFile)) {
          sources.push(new ConfigSource("file://" + sysProfileCfgJsonFile));
        }
        if (fs.existsSync(profileCfgJsonFile)) {
          sources.push(new ConfigSource("file://" + profileCfgJsonFile));
        }
        if (fs.existsSync(testProfileCfgPropertiesFile)) {
          sources.push(new ConfigSource("file://" + testProfileCfgPropertiesFile));
        }
        if (fs.existsSync(sysProfileCfgPropertiesFile)) {
          sources.push(new ConfigSource("file://" + sysProfileCfgPropertiesFile));
        }
        if (fs.existsSync(profileCfgPropertiesFile)) {
          sources.push(new ConfigSource("file://" + profileCfgPropertiesFile));
        }
      });
      // 5) default configuration
      sources.push(...Config.implicitSources);
    } else {
      let uu5 = window["uu5Environment"] || window["UU5"];
      let env = Config._getUu5Env(uu5) || {};
      sources.push(new ConfigSource(env));
    }
    // create the chain
    let chain = new ConfigChain(sources, profiles);

    // Copy custom configuration added to config from previously
    // activated profiles (so runtime configuration is not lost)
    if (Config.chain) chain._custom = Json.parse(Json.stringify(Config.chain._custom));
    Config.chain = chain;

    // Force load of all configs, fail on errors (Configuration must be
    // complete at least on profile activation which is expected during
    // environment initialization)
    chain.load(true);

    // Invoke profile activation callbacks
    Config.callbacks.forEach(function (entry) {
      let cb = entry[0];
      let cbProfiles = entry[1];
      if (!Config._doArraysIntersect(profiles, cbProfiles)) cb.call();
    });
    Config.activeProfiles = Array.from(new Set([...Config.activeProfiles, ...profiles]));

    // TODO log it (when logging gets standardised)
    // console.log('\nProfile(s) ' + chain.activeProfiles() +  ' activated. Effective configuration:\n', chain.toJSON(),'\n')
  }

  /**
   * Checks if given profile(s) is(are) active.
   * @param {...profiles} profiles
   * @returns {boolean}
   */
  static isProfileActive(...profiles) {
    let activeProfiles = Config.activeProfiles;
    if (!activeProfiles) return false;
    return Config._doArraysIntersect(activeProfiles, profiles);
  }

  /**
   * Returns value of the given configuration parameter
   * @param {string} name
   * @param {Boolean} recursive
   * @returns {*}
   */
  static get(name, recursive = true) {
    return Config._getChain().get(name, recursive);
  }

  /**
   * Returns parameter value transformed to string using .toString().
   * @param {String} name
   * @param {boolean} recursive
   * @returns {String}
   */
  static getString(name, recursive = true) {
    return Config._getChain().getString(name, recursive);
  }

  /**
   * Returns parameter value transformed to number (if possible, else raises error).
   * @param {String} name
   * @param {boolean} recursive
   * @returns {Number}
   */
  static getNumber(name, recursive = true) {
    return Config._getChain().getNumber(name, recursive);
  }

  /**
   * Returns parameter value transformed to boolean (if possible, else raises error).
   * @param {String} name
   * @param {boolean} recursive
   * @returns {Boolean}
   */
  static getBoolean(name, recursive = true) {
    return Config._getChain().getBoolean(name, recursive);
  }

  /**
   * Returns parameter value transformed to a Date object using its constructor or raises error.
   * @param {String} name
   * @param {boolean} recursive
   * @returns {Date}
   */
  static getTime(name, recursive = true) {
    return Config._getChain().getTime(name, recursive);
  }

  /**
   * Returns parameter value transformed to a class if possible, else raises error.
   * Source path needs to be provided, which is the path to the module that exports the requested class.
   * @param {String} name
   * @param {String} sourcePath
   * @param {boolean} recursive
   * @returns {Function}
   */
  static getClass(name, sourcePath, recursive = true) {
    return Config._getChain().getClass(name, sourcePath, recursive);
  }

  /**
   * Returns parameter value transformed to array of given types
   * @param {String} name
   * @param {String} type
   * @param {Boolean} recursive
   * @returns {Array}
   */
  static getArray(name, type = null, recursive = true, sourcePath = null) {
    return Config._getChain().getArray(name, type, recursive, sourcePath);
  }

  /**
   * Sets configuration parameter with highest priority (overrides value of any existing source).
   * @param {String} name
   * @param {*} value
   */
  static set(name, value) {
    Config._getChain().set(name, value);
  }

  /**
   * Deletes explicitly set configuration parameter.
   * @param {String} name
   */
  static delete(name) {
    Config._getChain().delete(name);
  }

  /**
   * Checks if configuration provides parameter of given name.
   * Returns false for undefined values and true for null values.
   * @param {String} name
   * @param {Boolean} recursive
   * @returns {*|Boolean|boolean}
   */
  static hasKey(name, recursive = true) {
    return Config._getChain().hasKey(name, recursive);
  }

  /**
   * Returns Object containing effective configuration.
   * @param {boolean} failOnError
   * @returns {*}
   */
  static toJSON(failOnError = false) {
    return Config._getChain().toJSON(failOnError);
  }

  /**
   * Forces reload of all configuration sources related to activated profiles.
   * @param {boolean} failOnError
   */
  static reload(failOnError = false) {
    Config._getChain().load(failOnError);
  }

  /**
   * Clears all configuration.
   */
  static clear() {
    Config.activeProfiles = [];
    Config.callbacks = [];
    Config.implicitSources = [];
    Config.sources = {};
    Config.chain = null;
  }
  static _getChain() {
    let chain = Config.chain;
    if (!chain) {
      let actProf = Config.activeProfiles;
      if (actProf.length === 0) {
        let envProfiles = ({"NAME":"uu_appg01_core","VERSION":"5.20.1","NAMESPACE":"UuApp","OUTPUT_NAME":"uu_appg01_core","NODE_ENV":(typeof process !== "undefined" && process.env && (process.env.NODE_ENV) || "development"),"TARGET_ENVIRONMENT":"browser","MOCK_DATA_BASE_URI":""})["CONFIG_PROFILE"] || (typeof process !== "undefined" && process.env && (process.env.NODE_ENV) || "development");
        if (envProfiles) {
          let arr = envProfiles.split(",");
          actProf = [];
          arr.forEach(function (profile) {
            actProf.push(profile.trim());
          });
          Config.activateProfiles(...actProf);
        } else {
          actProf = "production";
          Config.activateProfiles(actProf);
        }
      }
      chain = Config.chain;
    }
    return chain;
  }

  // TODO move this function to some more appropriate place?
  static _doArraysIntersect(arr1, arr2) {
    let doTheyIntersect = false;
    arr1.forEach(function (el1) {
      if (arr2.includes(el1)) doTheyIntersect = true;
    });
    return doTheyIntersect;
  }
  static _getDefaultConfigDir() {
    let configPath = path.join(process.cwd(), "env");
    if (!fs.existsSync(configPath)) {
      configPath = path.join(process.cwd(), "config");
    }
    return configPath;
  }
  static _getDefaultSysConfigDir() {
    let configPath = path.join(os.homedir(), ".uu", "env");
    if (!fs.existsSync(configPath)) {
      configPath = path.join(os.homedir(), ".uu", "config");
    }
    return configPath;
  }
  static _getTestConfigDir() {
    return path.join(process.cwd(), "test", "env");
  }
  static _getUu5Env(uu5) {
    if (!uu5) {
      return {};
    }
    if (uu5.Environment) {
      return uu5.Environment;
    } else {
      return uu5;
    }
  }
}
Config.activeProfiles = [];
Config.callbacks = [];
Config.implicitSources = [];
Config.sources = {};
Config.chain = null;
module.exports = Config;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-utils/src/context-store.browser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const GlobalStore = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/global-store.js");
const BaseError = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/base-error.js");

/**
 * ThreadLocal alike context store.
 */
class ContextStore {
  /**
   * Creates new context store
   * @param ctxName Context store name.
   * @param fn Function to which should context store be bound.
   * @returns {*} Return value of invoked function.
   */
  static create(ctxName, fn) {
    let contextStores = GlobalStore.get("uuAppContextStores");
    let contextStore = contextStores.get(ctxName);
    if (contextStore) {
      throw new BaseError(`Context "${ctxName}" is already created.`);
    }
    contextStore = new ContextStore();
    contextStores.set(ctxName, contextStore);
    return fn();
  }

  /**
   * Returns context store bound to current context.
   * @param ctxName Context store name.
   * @returns {ContextStore|null} Instance of context store or null.
   */
  static get(ctxName) {
    let contextStores = GlobalStore.get("uuAppContextStores");
    return contextStores.get(ctxName) || null;
  }

  /**
   * Creates new instance of context store.
   * @private
   */
  constructor() {
    this._attributes = {};
  }

  /**
   * Stores context attribute.
   * @param key Context attribute name.
   * @param value Context attribute value.
   */
  set(key, value) {
    this._attributes[key] = value;
  }

  /**
   * Returns context attribute.
   * @param key Context attribute name.
   * @returns {*} Context attribute value.
   */
  get(key) {
    return this._attributes[key];
  }

  /**
   * Deletes context attribute.
   * @param key Context attribute name.
   */
  delete(key) {
    delete this._attributes[key];
  }

  /**
   * Binds context store to emitter object. This is necessary to ensure context
   * is visible inside methods invoked by emitter events (like "on data" etc.).
   * @param emitter Emitter object (e.g. stream, socket, etc.)
   */
  bind(emitter) {
    // Nothing to do in browser environment.
  }

  /**
   * @deprecated Use {@link bind}.
   */
  bindEmitter(emitter) {
    this.bind(emitter);
  }

  /**
   * Forks context and runs given function.
   * @param fn Function to which should forked context store be bound.
   * @returns {*} Return value of invoked function.
   */
  fork(fn) {
    return fn();
  }
}
module.exports = ContextStore;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-utils/src/digest.browser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const sha1 = __webpack_require__("../../node_modules/js-sha1/src/sha1.js");
class Digest {
  static sha1(value) {
    return sha1(value);
  }
}
module.exports = Digest;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-utils/src/global-store.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const storage = typeof window === "undefined" ? __webpack_require__.g : window;
if (!storage._uuAppGlobalStores) {
  storage._uuAppGlobalStores = {};
}

/**
 * Global storage allowing to share objects accross multiple modules in various versions.
 */
class GlobalStore {
  /**
   * Returns global store with given name.
   * @param storeName Global store name.
   * @returns {GlobalStore} Instance of global store.
   */
  static get(storeName) {
    let store = storage._uuAppGlobalStores[storeName];
    if (!store) {
      store = storage._uuAppGlobalStores[storeName] = new GlobalStore();
    }
    return store;
  }

  /**
   * Creates new instance of global store.
   * @private
   */
  constructor() {
    this._attributes = {};
  }

  /**
   * Stores global attribute.
   * @param key Global attribute name.
   * @param value Global attribute value.
   */
  set(key, value) {
    this._attributes[key] = value;
  }

  /**
   * Returns global attribute.
   * @param key Global attribute name.
   * @returns {*} Global attribute value.
   */
  get(key) {
    return this._attributes[key];
  }

  /**
   * Deletes global attribute.
   * @param key Global attribute name.
   */
  delete(key) {
    delete this._attributes[key];
  }
}
module.exports = GlobalStore;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-utils/src/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = {
  get BaseError() {
    return __webpack_require__("../../node_modules/uu_appg01_core-utils/src/base-error.js");
  },
  get Config() {
    return __webpack_require__("../../node_modules/uu_appg01_core-utils/src/config/config.js");
  },
  get NameConverter() {
    return __webpack_require__("../../node_modules/uu_appg01_core-utils/src/name-converter.js");
  },
  get Loader() {
    return __webpack_require__("?c4af");
  },
  get ValueConverter() {
    return __webpack_require__("../../node_modules/uu_appg01_core-utils/src/value-converter.js");
  },
  get OptsReader() {
    return __webpack_require__("../../node_modules/uu_appg01_core-utils/src/opts-reader.js");
  },
  get ContextStore() {
    return __webpack_require__("../../node_modules/uu_appg01_core-utils/src/context-store.browser.js");
  },
  get GlobalStore() {
    return __webpack_require__("../../node_modules/uu_appg01_core-utils/src/global-store.js");
  },
  get Histogram() {
    return __webpack_require__("?6b0b");
  },
  get DuplicateLibraryValidator() {
    return __webpack_require__("?1930");
  },
  get Finder() {
    return __webpack_require__("?3a50");
  },
  get Digest() {
    return __webpack_require__("../../node_modules/uu_appg01_core-utils/src/digest.browser.js");
  },
  get Mutex() {
    return __webpack_require__("../../node_modules/uu_appg01_core-utils/src/mutex.js");
  },
  get LruCache() {
    return __webpack_require__("../../node_modules/uu_appg01_core-utils/src/lru-cache.js");
  },
  get Base64() {
    return __webpack_require__("../../node_modules/uu_appg01_core-utils/src/base64.js");
  },
  get Json() {
    return __webpack_require__("../../node_modules/uu_appg01_core-utils/src/json.js");
  }
};

/***/ }),

/***/ "../../node_modules/uu_appg01_core-utils/src/json.js":
/***/ ((module) => {

"use strict";


const POLLUTION_CHECK = /"(((_|\\u005f)(_|\\u005f)(p|\\u0070)(r|\\u0072)(o|\\u006f)(t|\\u0074)(o|\\u006f)(_|\\u005f)(_|\\u005f))|((c|\\u0063)(o|\\u006[Ff])(n|\\u006[Ee])(s|\\u0073)(t|\\u0074)(r|\\u0072)(u|\\u0075)(c|\\u0063)(t|\\u0074)(o|\\u006[Ff])(r|\\u0072)))"/;
const PROTO_KEY = "__proto__";
const CONSTRUCTOR_KEY = "constructor";
const BOOLEAN_TYPE = "boolean";
const OBJECT_TYPE = "object";
const PRUNED_VALUE = "-pruned-";
class Json {
  static parse(text, secure = true) {
    if (secure && POLLUTION_CHECK.test(text)) {
      return JSON.parse(text, (key, value) => key !== PROTO_KEY && key !== CONSTRUCTOR_KEY ? value : undefined);
    } else {
      return JSON.parse(text);
    }
  }
  static stringify(value, opts = {}) {
    if (typeof opts === BOOLEAN_TYPE) {
      opts = {
        prettyPrint: opts
      };
    }
    let pruner;
    if (opts && opts.prune) {
      let seen = [];
      pruner = (key, value) => {
        if (!value || typeof value !== OBJECT_TYPE) {
          return value;
        } else if (seen.indexOf(value) !== -1) {
          return PRUNED_VALUE;
        } else {
          seen.push(value);
          return value;
        }
      };
    }
    if (opts && opts.prettyPrint) {
      return JSON.stringify(value, pruner, 2);
    } else {
      return JSON.stringify(value, pruner);
    }
  }
}
module.exports = Json;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-utils/src/lru-cache.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Json = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/json.js");
let localStorageAvailable;
try {
  let check = localStorage;
  localStorageAvailable = !!check;
} catch (e) {
  localStorageAvailable = false;
}

/**
 * Cache item.
 * @private
 */
class Item {
  /**
   * Creates new instance of cache item.
   * @param key Item name
   * @param value Item value
   * @param exp Item expiration
   */
  constructor(key, value, exp) {
    this.key = key;
    this.value = value;
    this.exp = exp;
    this.next = null;
    this.prev = null;
  }

  /**
   * Checks if item is expired.
   * @returns {boolean} True if item is expired
   */
  isExpired() {
    return this.exp > -1 && this.exp <= Date.now();
  }

  /**
   * Returns object representation of cache item.
   * @returns {*[]} Array containing key, value end expiration (in this order)
   */
  toJSON() {
    return [this.key, this.value, this.exp];
  }
}

/**
 * Browser friendly implementation of LRU cache with support of persisting
 * cache to browser local storage.
 */
class LruCache {
  /**
   * Creates new instance of cache.
   * @param {Object|null} opts Cache options
   * @param {number} opts.maxSize Maximal number of items to be stored
   * @param {number} opts.maxAge How long (in milliseconds) should items be stored
   * @param {String} opts.localStorageKey If set, cache will be persisted to browser
   *   local storage. Local storage key should contain product identification to
   *   avoid conflicting names between various components.
   */
  constructor(opts = {}) {
    if (typeof opts.maxSize === 'number') {
      this._maxSize = opts.maxSize;
    } else {
      this._maxSize = -1;
    }
    if (typeof opts.maxAge === 'number') {
      this._maxAge = opts.maxAge;
    } else {
      this._maxAge = -1;
    }
    this._name = opts.localStorageKey;
    this._size = 0;
    this._items = {};
    this._first = null;
    this._last = null;
    this._loadFromStorage();
    this._storeToStorage();
  }

  /**
   * Stores value into cache.
   * @param key Key to access cached value
   * @param value Value to be cached
   * @param maxAge How long (in milliseconds) should this value be stored (overrides global maxAge)
   * @returns {*} Value previously stored under this key (or null if none)
   */
  set(key, value, maxAge = null) {
    this._loadFromStorage();
    let origValue = null;
    maxAge = typeof maxAge === "number" ? maxAge : this._maxAge;
    let exp = maxAge > -1 ? maxAge + Date.now() : -1;
    let newItem = new Item(key, value, exp);
    // If there is same existing item, delete it
    // (and remember original value to return it)
    if (this._items[key]) {
      origValue = this.delete(key);
    }
    // Set new item to front of list
    this._push(newItem);
    // If cache is full we have to prune it
    if (this._maxSize > -1 && this._size > this._maxSize) {
      this._prune(this._size - this._maxSize);
    }
    this._storeToStorage();
    // Return original value (if any)
    return origValue;
  }

  /**
   * Check if a key is in the cache, without updating the recent-ness or deleting it for being stale.
   * @param {Check} key Key of cached value
   * @returns {boolean} True if key is in cache, else false
   */
  has(key) {
    this._loadFromStorage();
    let item = this._items[key];
    return item && !item.isExpired();
  }

  /**
   * Returns value from cache.
   * @param key Key of cached value
   * @returns {*} Cached value (or null)
   */
  get(key) {
    this._loadFromStorage();
    let item = this._items[key];
    let value = null;
    if (item) {
      if (item.isExpired()) {
        // It item is expired, just delete it
        this._remove(item);
      } else {
        value = item.value;
        this._touch(item);
      }
    }
    this._storeToStorage();
    return value;
  }

  /**
   * Deletes value from cache.
   * @param key Key of cached value
   * @returns {*} Cached value (or null)
   */
  delete(key) {
    this._loadFromStorage();
    let value = null;
    if (this._items[key]) {
      let item = this._items[key];
      if (!item.isExpired()) {
        // In case item is not expired, return value of deleted item
        value = item.value;
      }
      this._remove(item);
    }
    this._storeToStorage();
    return value;
  }

  /**
   * Clears cache.
   */
  clear() {
    this._size = 0;
    this._items = {};
    this._first = null;
    this._last = null;
    this._storeToStorage();
  }

  /**
   * Returns actual cache size.
   * @returns {number}
   */
  getSize() {
    return this._size;
  }

  /**
   * Returns object representation of cache item.
   * @returns {Array} List of cached items
   */
  toJSON() {
    let items = [];
    // Serialize from last to ensure correct order on restore
    let item = this._last;
    while (item) {
      items.push(item.toJSON());
      item = item.prev;
    }
    return [this._maxSize, this._maxAge, items];
  }

  /**
   * Initializes cache from serialized value (clears any existing data).
   * @param json Serialized cache
   */
  fromJSON(json) {
    this.clear();
    if (typeof json === "string") {
      json = Json.parse(json);
    }
    let [maxSize, maxAge, items] = json;
    this._maxSize = maxSize;
    this._maxAge = maxAge;
    for (let [key, value, exp] of items) {
      this._push(new Item(key, value, exp));
    }
  }

  /**
   * Return an array of the keys in the cache.
   * @return {Array} List of the keys in the cache.
   */
  keys() {
    this._loadFromStorage();
    let result = [];
    let item = this._first;
    while (item) {
      if (!item.isExpired()) {
        result.push(item.key);
      }
      item = item.next;
    }
    return result;
  }

  /**
   * Return an array of the values in the cache.
   * @return {Array} List of the values in the cache.
   */
  values() {
    this._loadFromStorage();
    let result = [];
    let item = this._first;
    while (item) {
      if (!item.isExpired()) {
        result.push(item.value);
      }
      item = item.next;
    }
    return result;
  }

  /**
   * Iterates through cached items (from newest to oldest)
   * @param callback Function receiving two parameters - item key and value.
   *    Function may return false to stop the loop.
   */
  forEach(callback) {
    if (typeof callback !== 'function') {
      throw new BaseError(`Parameter must be function`);
    }
    this._loadFromStorage();
    let item = this._first;
    while (item) {
      let doNext = null;
      if (!item.isExpired()) {
        doNext = callback(item.key, item.value);
      }
      if (typeof doNext === 'boolean' && !doNext) {
        break;
      } else {
        item = item.next;
      }
    }
  }

  /**
   * Pushes new item to cache.
   * @param item Cached item
   * @private
   */
  _push(item) {
    // Set previous first item after new item
    item.next = this._first;
    item.prev = null;
    if (this._first) {
      this._first.prev = item;
    }
    // Set new item to first place
    this._first = item;
    if (!this._last) {
      // If case was emtpy, first item is also last
      this._last = item;
    }
    // Store the item
    this._items[item.key] = item;
    this._size++;
  }

  /**
   * Moves item to fist position.
   * @param item Touched item
   * @private
   */
  _touch(item) {
    // If item is already first do nothing
    if (item.prev) {
      // Link previous item with next of moved item
      item.prev.next = item.next;
      if (item.next) {
        // Link next item with prev of moded item
        item.next.prev = item.prev;
      } else {
        // In case we are moving last item, update tail
        this._last = item.prev;
      }
      // Set previous first item after moved item
      item.next = this._first;
      item.prev = null;
      if (this._first) {
        this._first.prev = item;
      }
      // Set moved item to first place
      this._first = item;
    }
  }

  /**
   * Removes item from cache.
   * @param item Item to be removed
   * @private
   */
  _remove(item) {
    if (item.prev) {
      // Link previous item with next of deleted item
      item.prev.next = item.next;
    } else {
      // In case we are deleting first item, update head
      this._first = item.next;
    }
    if (item.next) {
      // Link next item with prev of deleted item
      item.next.prev = item.prev;
    } else {
      // In case we are deleting last item, update tail
      this._last = item.prev;
    }
    // Delete the item
    delete this._items[item.key];
    this._size--;
  }

  /**
   * Prune at least specified number of items, first delete
   * expired ones, then delete from last item until given
   * number of items to be deleted is reached.
   * @param atLeast Number of items to be removed
   * @private
   */
  _prune(atLeast = 1) {
    let deleted = 0;
    // Delete all expired items first
    let item = this._last;
    while (item) {
      if (item.isExpired()) {
        this._remove(item);
        deleted++;
      }
      item = item.prev;
    }
    // Delete remaining number of items
    if (deleted < atLeast) {
      let item = this._last;
      for (let i = 0; i < atLeast - deleted; i++) {
        this._remove(item);
        item = item.prev;
        // Break in case all items are gone
        if (!item) {
          break;
        }
      }
    }
  }

  /**
   * If available, deserializes cache content from browser local storage.
   * @private
   */
  _loadFromStorage() {
    if (localStorageAvailable && this._name) {
      let persistedCache = localStorage.getItem(this._name);
      if (persistedCache) {
        this.fromJSON(persistedCache);
      }
    }
  }

  /**
   * If available, serilalizes cache content to browser local storage.
   * @private
   */
  _storeToStorage() {
    if (localStorageAvailable && this._name) {
      localStorage.setItem(this._name, Json.stringify(this));
    }
  }
}
module.exports = LruCache;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-utils/src/mutex.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Digest = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/digest.browser.js");
const Json = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/json.js");

/**
 * Component providing synchronization methods
 * for running asynchronous functions.
 */
class Mutex {
  /**
   * Allows to suspend processing of method for given time. Returns the actual
   * number of milliseconds the processing was suspended, which is typically
   * slightly higher than given time (due to delay of callback invocation).
   * @param ms Number of milliseconds to sleep
   * @returns {Promise<number>} Number of milliseconds actually slept
   */
  static async sleep(ms) {
    let initiated = Date.now();
    return new Promise(resolve => {
      setTimeout(() => resolve(Date.now() - initiated), ms);
    });
  }
  /**
   * Allows to split long running functions to multiple segments in order to prevent
   * blocking of thread by long running operations (e.g. it can be called in each loop).
   * @returns {Promise<number>} Number of milliseconds how long function was interrupted
   */
  static async yield() {
    let initiated = Date.now();
    let interrupt = (async () => {})();
    return interrupt.then(() => {
      return Date.now() - initiated;
    });
  }

  /**
   * Creates new instance of Mutex.
   */
  constructor() {
    this._promises = {};
  }

  /**
   * Ensures given functionality is invoked only once at a time. Method internally
   * computes functionality invocation signature (or used given one) and in case
   * functionality with same signature as already running one is requested, it does
   * not perform new invocation but returns result of previous one.
   * @param sig Invocation signature which should be unique for given function
   *   and/or function argument values. If not given, default signature is
   *   computed as "${fn.name}:${sha1(JSON.stringify(args))}"
   * @param fn Function to be invoked
   * @param args Function arguments
   * @returns {Promise<*>} Result of invoked function
   */
  runOneAtTime(sig = null, fn, ...args) {
    if (typeof sig === "function") {
      args.unshift(fn);
      fn = sig;
      sig = null;
    }
    let signature = sig || this._getSignature(fn, ...args);
    let promise = this._promises[signature];
    if (!promise || promise._finished) {
      promise = this._invokeFn(fn, ...args);
      promise._finished = false;
      this._promises[signature] = promise;
      let finalize = () => {
        promise._finished = true;
        delete this._promises[signature];
      };
      promise.then(finalize, finalize);
    }
    return promise;
  }

  /**
   * Ensures given functionality is invoked after previously given one is finished.
   * @param fn Function to be invoked
   * @param args Function arguments
   * @returns {PromiseLike<*>} Result of invoked function
   */
  runInBand(fn, ...args) {
    let prevPromise = this._promises["runInBand"];
    let nextPromise;
    if (!prevPromise || prevPromise._finished) {
      nextPromise = this._invokeFn(fn, ...args);
    } else {
      let runNext = () => {
        return this._invokeFn(fn, ...args);
      };
      nextPromise = prevPromise.then(runNext, runNext);
    }
    nextPromise._finished = false;
    this._promises["runInBand"] = nextPromise;
    let finalize = () => {
      nextPromise._finished = true;
    };
    nextPromise.then(finalize, finalize);
    return nextPromise;
  }
  _getSignature(fn, ...args) {
    let argsString = Json.stringify(args, {
      pruned: true
    });
    let argsHash = Digest.sha1(argsString);
    return `${fn.name}:${argsHash}`;
  }
  _invokeFn(fn, ...args) {
    if (fn.constructor.name === 'AsyncFunction') {
      return fn(...args);
    } else {
      let asyncWrapper = async () => {
        return fn(...args);
      };
      return asyncWrapper();
    }
  }
}
module.exports = Mutex;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-utils/src/name-converter.js":
/***/ ((module) => {

/**
 * Convert nameSpace to file path
 * @param str
 * @returns {string|string}
 * @constructor
 */
function NameConverter(str) {
  const REGEX = /^([_]*[$@#]?)?(?:[a-zA-Z0-9]+(?:[_]+[a-zA-Z0-9]+)?)*([_]+)?$/;
  function _scan(s, re) {
    if (!re.global) throw "Name Converter Error";
    let m = re.exec(s),
      r = [];
    while (m) {
      m.shift();
      r.push(m);
      m = re.exec(s);
    }
    return r;
  }
  let strings = [];
  let result = "";
  str.match(REGEX);
  let prefix = str.match(/^[_]*/)[0];
  str = str.substring(prefix.length, str.length);
  let postfix = str.match(/[_]*$/)[0];
  str = str.substring(0, str.length - postfix.length);
  let befIndex = 0;
  _scan(str, /[a-z]+|[A-Z]+|[0-9]+/g).forEach(val => {
    let index = val["index"];
    strings.push(str.substring(befIndex, index));
    befIndex = index;
  });
  strings.push(str.substring(befIndex));
  if (strings[0] === "/" || strings[0] === "\\") strings.shift();
  for (let i = 0; i < strings.length; i += 1) {
    let act = strings[i];
    let nxt = strings[i + 1];
    if (act.match(/^[a-z]+|[0-9]+$/)) {
      result += act;
      result += nxt !== undefined ? "-" : "";
    } else if (act.match(/^[A-Z]$/)) {
      result += act.toLowerCase();
    } else if (act.match(/^[A-Z]+$/)) {
      if (nxt === undefined || nxt.match(/^[0-9]+$/)) {
        result += act.toLowerCase();
        result += nxt !== undefined ? "-" : "";
      } else {
        result += act.substring(0, act.length - 1).toLowerCase();
        result += "-";
        result += act[act.length - 1].toLowerCase();
      }
    }
  }
  result = prefix + result + postfix;
  return result;
}
module.exports = NameConverter;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-utils/src/opts-reader.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Config = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/config/config.js");
const ValueConverter = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/value-converter.js");

/**
 * Component for reading option from multiple option
 * sources with support for providing default values
 * and basic type conversions.
 * Example:
 *   reader = new OptsReader(opts1, opts2, Config);
 *   anyType = reader.get("opt_key")
 *   number = reader.getNumber("opt_key", 42)
 */
class OptsReader {
  /**
   * Creates new instance of options reader.
   * @param opts List of option sources to be read
   *   (ordered by priority from highest to lowest).
   */
  constructor(...opts) {
    this._optList = opts;
  }

  /**
   * Returns option with given name or default value
   * if none of option sources provide required option.
   * @param key Option name.
   * @param defaultValue Default options value.
   * @returns {*}
   */
  get(key, defaultValue = null) {
    let value = null;
    for (let opts of this._optList) {
      if (opts === Config) {
        if (opts.hasKey(key, false)) {
          value = opts.get(key, false);
        }
      } else if (opts) {
        if (opts.hasOwnProperty(key) && opts[key] !== undefined) {
          value = opts[key];
        }
      }
      if (value != null) {
        break;
      }
    }
    if (value == null) {
      value = defaultValue;
    }
    return value;
  }

  /**
   * Checks if any of option sources provide
   * option with given name.
   * @param key Option name.
   * @returns {Boolean} True if option exists.
   */
  hasKey(key) {
    for (let opts of this._optList) {
      if (opts === Config) {
        if (opts.hasKey(key)) {
          return true;
        }
      } else if (opts) {
        if (opts.hasOwnProperty(key) && opts[key] !== undefined) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Returns string value created from option with given
   * name or default value if none of options sources provide
   * required option.
   * @param key Option name.
   * @param defaultValue Default options value.
   * @returns {String}
   */
  getString(key, defaultValue = null) {
    let value = this.get(key, defaultValue);
    return ValueConverter.toString(value);
  }

  /**
   * Returns number value created from option with given
   * name or default value if none of options sources provide
   * required option.
   * @param key Option name.
   * @param defaultValue Default options value.
   * @returns {Number}
   */
  getNumber(key, defaultValue = null) {
    let value = this.get(key, defaultValue);
    return ValueConverter.toNumber(value);
  }

  /**
   * Returns boolean value created from option with given
   * name or default value if none of options sources provide
   * required option.
   * @param key Option name.
   * @param defaultValue Default options value.
   * @returns {Boolean}
   */
  getBoolean(key, defaultValue = null) {
    let value = this.get(key, defaultValue);
    return ValueConverter.toBoolean(value);
  }

  /**
   * Returns time value created from option with given
   * name or default value if none of options sources provide
   * required option.
   * @param key Option name.
   * @param defaultValue Default options value.
   * @returns {Date}
   */
  getTime(key, defaultValue = null) {
    let value = this.get(key, defaultValue);
    return ValueConverter.toTime(value);
  }

  /**
   * Returns class value created from option with given
   * name or default value if none of options sources provide
   * required option.
   * @param key Option name.
   * @param sourcePath Path to app/library source folder (app|src) from where to load class.
   * @param defaultValue Default options value.
   * @returns {Function}
   */
  getClass(key, sourcePath, defaultValue = null) {
    let value = this.get(key, defaultValue);
    return ValueConverter.toClass(value, sourcePath);
  }

  /**
   * Returns array value created from option with given
   * name or default value if none of options sources provide
   * required option.
   * @param key Option name.
   * @param type If set, all array items will be converted to
   *   given type (one of "string", "number", "boolean", "time", "class")
   * @param defaultValue Default options value.
   * @param sourcePath Path to app/library source folder (app|src) from where to load class
   *   Required for "class" conversion.
   * @returns {Array}
   */
  getArray(key, type = null, defaultValue = null, sourcePath = null) {
    let value = this.get(key, defaultValue);
    return ValueConverter.toArray(value, type, sourcePath);
  }
}
module.exports = OptsReader;

/***/ }),

/***/ "../../node_modules/uu_appg01_core-utils/src/value-converter.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BaseError = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/base-error.js");
const Loader = __webpack_require__("?c4af");
const INVALID_DATE = new Date("foo");

/**
 * Helper for converting values to different basic types.
 */
class ValueConverter {
  /**
   * Converts value to string.
   * @param value Value to be converted.
   * @returns {String} Converted value.
   */
  static toString(value) {
    if (value === null || value === undefined) {
      return null;
    } else {
      return value.toString();
    }
  }

  /**
   * Converts value to number.
   * @param value Value to be converted.
   * @returns {Number} Converted value.
   */
  static toNumber(value) {
    if (value === null || value === undefined) {
      return null;
    } else if (typeof value === "number") {
      return value;
    } else if (typeof value === "string") {
      if (/^[+-]?[\d]+(\.[\d]+)?([eE][+-]?[\d]+)?$/.test(value)) {
        return Number(value);
      } else {
        throw new BaseError(`No implicit conversion of "${value}" to number`);
      }
    } else {
      throw new BaseError(`No implicit conversion of "${typeof value}" to number`);
    }
  }

  /**
   * Converts value to boolean.
   * @param value Value to be converted.
   * @returns {Boolean} Converted value.
   */
  static toBoolean(value) {
    if (value === null || value === undefined) {
      return null;
    } else if (typeof value === "boolean") {
      return value;
    } else if (typeof value === "number") {
      return value !== 0;
    } else if (typeof value === "string") {
      if (/^(false|0)$/i.test(value)) {
        return false;
      } else if (/^(true|1)$/i.test(value)) {
        return true;
      } else {
        throw new BaseError(`No implicit conversion of "${value}" to boolean`);
      }
    } else {
      throw new BaseError(`No implicit conversion of "${typeof value}" to boolean`);
    }
  }

  /**
   * Converts value to time.
   * @param value Value to be converted.
   * @returns {Date} Converted value.
   */
  static toTime(value) {
    if (value === null || value === undefined) {
      return null;
    } else if (value instanceof Date) {
      return value;
    } else if (typeof value === "number") {
      return new Date(value);
    } else if (typeof value === "string") {
      let date = new Date(value);
      if (date.toString() === INVALID_DATE.toString()) {
        throw new BaseError(`No implicit conversion of "${value}" to time`);
      } else {
        return date;
      }
    } else {
      throw new BaseError(`No implicit conversion of "${typeof value}" to time`);
    }
  }

  /**
   * Converts value to class.
   * @param value Value to be converted.
   * @param sourcePath Path to app/library source folder (app|src) from where to load class.
   * @returns {Function} Converted value.
   */
  static toClass(value, sourcePath) {
    if (value === null || value === undefined) {
      return null;
    } else if (typeof value === "function") {
      // TODO Check that function is constructor
      return value;
    } else if (typeof value === "string") {
      if (sourcePath === null || sourcePath === undefined) {
        throw new BaseError("Parameter sourcePath is required to resolve class from string");
      }
      return Loader.loadRealization(sourcePath, value, false);
    } else {
      return value.constructor;
    }
  }

  /**
   * Converts value to array of given types.
   * @param value Value to be converted.
   * @param type If set, all array items will be converted to
   *   given type (one of "string", "number", "boolean", "time", "class")
   * @param sourcePath Path to app/library source folder (app|src) from where to load class
   *   Required for "class" conversion.
   * @returns {Array} Converted value.
   */
  static toArray(value, type = null, sourcePath = null) {
    let arr = null;
    if (value === null || value === undefined) {
      return null;
    } else if (value instanceof Array) {
      arr = value;
    } else if (typeof value === "string") {
      arr = value.split(/[ ]*,[ ]*/);
    } else {
      arr = [value];
    }
    switch (type) {
      case null:
      case undefined:
        // No conversion
        break;
      case "string":
        arr = arr.map(item => {
          return this.toString(item);
        });
        break;
      case "number":
        arr = arr.map(item => {
          return this.toNumber(item);
        });
        break;
      case "boolean":
        arr = arr.map(item => {
          return this.toBoolean(item);
        });
        break;
      case "time":
        arr = arr.map(item => {
          return this.toTime(item);
        });
        break;
      case "class":
        arr = arr.map(item => {
          return this.toClass(item, sourcePath);
        });
        break;
      default:
        throw new BaseError(`Unknown conversion type "${type}"`);
    }
    return arr;
  }
}
module.exports = ValueConverter;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/app-client/client.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  BaseError
} = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");
const Helpers = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/app-client/helpers.js");
const HttpClient = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/app-client/http-client.browser.js");
const PerflogHandler = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/perflog-handler.js");
const RemoteErrorHandler = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/remote-error-handler.js");
const TransformParametersHandler = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/transform-parameters-handler.browser.js");
const UriHandler = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/uri-handler.js");
const CsrfTokenHandler = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/csrf-token-handler.browser.js");
const RetryHandler = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/retry-handler.browser.js");
const DEFAULT_INTERCEPTORS = [PerflogHandler, UriHandler, CsrfTokenHandler, RemoteErrorHandler, RetryHandler, TransformParametersHandler];

/**
 * Creates an instance of command client which will use specified configuration when invoking commands.
 * Unspecified values are taken from global defaults ({@link UuApp.AppClient.Client.defaults Client.defaults}). Most
 * values can be further overridden when invoking the remote call - see {@link UuApp.AppClient.Client#post Client#post}.
 *
 * **Interceptors**
 *
 * It's possible to provide a list of interceptors which pre-/post-process HTTP requests. An interceptor
 * is a JavaScript function {Promise<Response>} interceptorFn({Object} request, {Object} options, {Function} nextInterceptorFn).
 * Request object contains fields uri, method, body and options object contains any remaining options passed down to
 * interceptors, e.g. transformParameters). Example:
 *
 *     function MyInterceptor(request, options, nextInterceptorFn) {
 *       // pre-process in any way
 *       request.headers["x-extra-header-computed-value"] = Math.random() + "";
 *       console.log("Launching Ajax request. Method:", request.method, "Uri:", request.uri, "Parameters:", request.body, "Other options:", options);
 *       let start = new Date().getTime();
 *       return nextInterceptorFn(request, options).then(function (response) {
 *         // post-process in any way, e.g. add extra field to the response object
 *         response.timeTaken = new Date().getTime() - start;
 *         return response;
 *       }, function error(response) {
 *         // ...
 *         return Promise.reject(response); // keep it rejected (i.e. in error state)
 *       });
 *     }
 *
 *     // usage of the interceptor
 *     let client = new UuApp.AppClient.Client({
 *       interceptors: [MyInterceptor].concat(UuApp.AppClient.Client.defaults.interceptors)
 *     });
 *
 * @class UuApp.AppClient.Client
 * @classdesc
 * The Client allows communication with remote uuOS9 endpoints which conform to uuUri format.
 * Besides communication, the client solves also other points of interest, such as authentication or
 * performance logging.
 *
 * Client uses standardized {@link https://developer.mozilla.org/cs/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise API}
 * to provide access to the result of the call.
 *
 *     UuApp.AppClient.Client.get("/cds-gb/UU-BT/guestbook/123/getAttributes").then(function (response) {
 *       console.log(response.data, response.status, response.headers());
 *     }, function (response) { // error
 *       console.log(response.error, response.status, response.headers());
 *     });
 *
 * When used as above, client uses global defaults (timeout, headers, ...). If the call needs to be parametrized, it can
 * be parametrized directly in {@link UuApp.AppClient.Client#post Client#post} ({@link UuApp.AppClient.Client#get Client#get})
 * call or, alternatively, a client instance can be created with defaults that override the global ones.
 *
 * For pre-/post-processing of HTTP requests use custom interceptors (see constructor).
 *
 * **Configuration**
 *
 * Some options are automatically configured from the environment during
 * {@link UuApp.Util.Config.init Config.init} call. These can be overridden when instantiating
 * the client or in method invocations. Supported environment options:
 *
 *     {
 *       "gatewayUri": "https://uuappg01.plus4u.net", // default gateway for command calls using uuUri that doesn't contain gateway
 *       "vendor-app-subapp-spp.gatewayUri": "https://elsewhere.plus4u.net"
 *     }
 *
 * @param {Object} options Default options for this instance of the command client.
 * @param {number} options.requestTimeout The default HTTP timeout for this instance of the command client, in seconds.
 * @param {Object} options.headers The default HTTP headers for command invocations using this instance of the command client.
 * @param {Object[]} options.interceptors List of interceptors to use. Interceptors can arbitrarily pre-/post-process
 * @param options {object}
 * @param options.retryPolicy {object}
 * @param [options.retryPolicy.maxAttempts=3] {number} - Max attempts
 * @param [options.retryPolicy.maxTimeInterval=30000] {number} - Max time interval in ms
 * @param [options.retryPolicy.baseTimeInterval=100] {number} - Base time interval in ms
 * @param options.retryPolicy.retryCondition {object}
 * @param [options.retryPolicy.retryCondition.httpMethods = ["POST", "GET"]] {array<string>}
 * @param [options.retryPolicy.retryCondition.httpStatusCodes = ["502", "503"]] {array<string>} - Pass "5xx" to work with all 5xx status codes
 * @param [options.retryPolicy.retryCondition.errorCodes = [] ] {array<string>} - Pass "5xx" to work with all 5xx status codes
 *   HTTP requests.
 * @param {*} options.* Any other parameters are passed to the interceptors. These can include environmental options such
 *   as "gatewayUri" which then take precedence over those from global environment.
 *
 * @example
 *    let client = new UuApp.AppClient.Client({
 *      requestTimeout: 20,
 *      headers: {
 *        "x-my-extra-header": "abcd"
 *      },
 *      interceptors: [MyInterceptor].concat(UuApp.AppClient.Client.defaults.interceptors)
 *    });
 *
 *    // ... all calls using "client.get(...)" or "client.post()" will have timeout 20s (unless the timeout
 *    // is overridden in the invoke call directly) and will have an extra HTTP header.
 */
class Client {
  /**
   * Equivalent to {@link UuApp.AppClient.Client#get} using Client with default
   * configuration, i.e.:
   *
   *     new UuApp.AppClient.Client().get(uri, options)
   *
   * @see {@link UuApp.AppClient.Client#get Client#get}
   * @method UuApp.AppClient.Client.get
   */
  static async get(uri, dtoIn = null, options = null) {
    return new Client().get(uri, dtoIn, options);
  }

  /**
   * Equivalent to UuApp.AppClient.Client.cmdGet using Client with default
   * configuration, i.e.:
   *
   *     new UuApp.AppClient.Client().cmdGet(uri, options)
   *
   * @method UuApp.AppClient.Client.cmdGet
   */
  static async cmdGet(uri, dtoIn = null, options = null) {
    return new Client().cmdGet(uri, dtoIn, options);
  }

  /**
   * Equivalent to {@link UuApp.AppClient.Client#post} using Client with default
   * configuration, i.e.:
   *
   *     new UuApp.AppClient.Client().post(uri, dtoIn, options)
   *
   * @see {@link UuApp.AppClient.Client#post Client#post}
   * @method UuApp.AppClient.Client.post
   */
  static async post(uri, dtoIn = null, options = null) {
    return new Client().post(uri, dtoIn, options);
  }

  /**
   * Equivalent to UuApp.AppClient.Client.cmdPost using Client with default
   * configuration, i.e.:
   *
   *     new UuApp.AppClient.Client().cmdPost(uri, dtoIn, options)
   *
   * @method UuApp.AppClient.Client.cmdPost
   */
  static async cmdPost(uri, dtoIn = null, options = null) {
    return new Client().cmdPost(uri, dtoIn, options);
  }
  constructor(options = {}) {
    this._options = {
      // default options
      retryPolicy: {
        maxAttempts: 3,
        maxTimeInterval: 30000,
        baseTimeInterval: 100,
        retryCondition: {
          httpMethods: ["GET", "POST"],
          httpStatusCodes: ["503", "599"]
        }
      }
    };
    Helpers.mergeOptions(this._options, options); // override options with the custom ones

    this._options.headers = Helpers.keysToLowerCase(this._options.headers);
    this._aborted = false;
  }

  /**
   * Invokes remote call using HTTP GET request. See {@link UuApp.AppClient.Client#post Client#post}
   * for detailed options and behaviour.
   *
   * Keep in mind that the "dtoIn" parameter is sent via URL parameter(s)
   * and browsers impose limit to the maximal length of the URL. To be safe, limit the amount of data so that the URL
   * doesn't exceed 2048 bytes.
   *
   * @param {(string|UuApp.Uri.Uri)} uri Uri of the uuOS9 endpoint.
   * @param {*} dtoIn The parameters to send in the request URL.
   * @param {Object} options Optional options for the remote call.
   * @return Promise resolving to a response object (or rejecting to a response object with error field).
   * @method UuApp.AppClient.Client#get
   * @see {@link UuApp.AppClient.Client#post Client#post}
   *
   * @example
   *    // simple call
   *    let baseUri = Uri.parse(location.protocol + "//" + location.host + location.pathname).baseUri; // "http://example.com/vendor-app/tid-awid"
   *    Client.get(baseUri.join("+/getAttributes"), { param1: "v1" }).then(function success(response) {
   *      let data = response.data; // contains parsed response entity
   *      console.log(response.status, response.headers(), response.data);
   *    }, function error(response) {
   *      let error = response.error; // contains parsed response error
   *      console.log(response.status, response.headers(), response.error);
   *    });
   *
   * @example
   *    // parameterizing uuUri and the call
   *    let uri = new UuApp.Uri.UriBuilder("/cds-gb-main/0-0/getAttributes", {
   *      workspace: "15634-34e5684da3435",
   *      useCase: "getConfig",
   *      parameters: { p1: "v1" }
   *    }).toUri();
   *    client.get(uri, null, {
   *      requestTimeout: 5,
   *      headers: {
   *        "x-my-header": "abc"
   *      }
   *    }).then(console.log.bind(console), console.log.bind(console));
   *
   * @example
   *    // accept any response and don't parse it
   *    let workspace = "...";
   *    let guestbookId = "...";
   *    client.get(`/cds-gb/${workspace}/guestbook/${guestbookId}/downloadData`, null, {
   *      transformResponse: false,
   *      headers: {
   *        "accept": "*\/*"
   *      }
   *    }).then(console.log.bind(console), console.log.bind(console));
   */
  async get(uri, dtoIn, options) {
    return this._invoke("get", uri, dtoIn, options);
  }

  /**
   * Analog to async get() public method
   * Main difference - Returns properly filled dtoOut described in CMD design
   * Invokes remote call using HTTP GET request.
   * for detailed options and behaviour.
   *
   * Keep in mind that the "dtoIn" parameter is sent via URL parameter(s)
   * and browsers impose limit to the maximal length of the URL. To be safe, limit the amount of data so that the URL
   * doesn't exceed 2048 bytes.
   *
   * @param {(string|UuApp.Uri.Uri)} uri Uri of the uuOS9 endpoint.
   * @param {*} dtoIn The parameters to send in the request URL.
   * @param {Object} options Optional options for the remote call.
   * @return Promise resolving to a response object (or rejecting to a response object with error field).
   * @method UuApp.AppClient.Client#get
   */

  async cmdGet(uri, dtoIn, options) {
    return this._invoke("get", uri, dtoIn, options, true);
  }

  /**
   * Invokes remote call using HTTP POST request. Default values for settings will
   * be filled in from Client instance configuration and then from global defaults.
   *
   * The client serializes data to and from server using {@link UuApp.AppClient.Client.contentTransformers} according
   * to the specified "content-type" HTTP request/response header.
   * Default value for "content-type" request header for requests with body entity is "application/json; charset=utf-8",
   * except for case when sending {@link https://developer.mozilla.org/en-US/docs/Web/API/FormData FormData} object or
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/File File} (or
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/Blob Blob}) object for which the default value is
   * "multipart/form-data". Default accepted response ("accept" request header) is "application/json".
   * Note that default accepted response can be extended in the future to support formats such as MessagePack and others.
   *
   * **Return value**
   *
   * Return value is a {@link https://developer.mozilla.org/cs/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise}
   * resolving / rejecting to a response object which contains following fields:
   *
   * * {Object} data - response data. Data is parsed with content handler according to "content-type" response header
   *     unless option transformResponse is false (in which case it's left as received from browser).
   * * {Error} error - the error instance (see Error handling below). This field is set if and only if the Promise is rejected.
   * * {number} status - the HTTP status code.
   * * {function(string)} headers - function which returns value of the specified (case-insenstive) response header.
   *   If called with no arguments, an array with all response headers is returned.
   * * {Object} config - final configuration options that were used for launching AJAX request.
   *
   * The returned Promise instance additionally contains method {function()} abort for aborting ongoing remote call.
   *
   * **File upload**
   *
   * Use "content-type" header with "multipart/form-data" value when uploading binary data (File, Blob). Alternatively, it's
   * possible to use standard {@link https://developer.mozilla.org/en-US/docs/Web/API/FormData FormData} object - see examples
   * below. Note that when using FormData object, the order of appending the form fields matters - append simple values first
   * and only in the end append file objects. The reason is that in this order, the server might decide not to allow the upload
   * based on the other already-available fields thus allowing to end the connection without full upload of the file(s).
   * _(Client will fix the order of values in FormData object, however not all browsers support this operation.)_
   *
   * **Error handling**
   *
   * If an error happens during the call invocation (determined by HTTP response status code), the resulting Promise is
   * rejected with response object which will contain "error" field set to an instance of one of these error types
   * (when using default interceptors):
   *
   *   * null - if server sent response with error HTTP status code but it contained no recognizable error data.
   *   * {@link UuApp.Error.RemoteError} - error as sent from remote server. Note that the response can contain
   *     several errors - in such case only first error is extracted into "error" field.
   *   * {@link UuApp.Error.NetworkError} - in case of problems with connecting to remote server.
   *   * {@link UuApp.Error.TimeoutError} - when the request didn't end within specified timeout.
   *   * {@link UuApp.Error.AbortError} - when invocation is aborted by invoking promise.abort() method.
   *
   * The resulting response object contains also HTTP status code and will contain "data"
   * field set to the response entity (usually containing parsed error list).
   *
   * **Timeout**
   *
   * The timeout applies to the remote call duration only. If an interceptor is used which performs lengthy or asynchronous
   * operation prior to executing the remote call, it's not counted towards the timeout.
   *
   * @param {(string|UuApp.Uri.Uri)} uri Uri of the uuOS9 endpoint.
   * @param {(FormData|*)} dtoIn The DTO to send in the request body.
   * @param {Object} options Optional options for the remote call.
   * @param {number} options.requestTimeout The timeout for the command invocation. Default is 0 (no timeout).
   * @param {Object} options.headers The HTTP headers to send. Header names are case-insensitive, but it's advised
   *   to use lowercased names to prevent duplicities within the map. Headers are merged with default headers from
   *   Client / global configuration. If a header is in defaults and it's required to prevent it from being
   *   sent during this invocation, specify the header and use null as its value.
   * @param {boolean} options.transformParameters If false, processing of the command parameters (DTO) will be skipped so they'll be
   *   sent exactly as-is (the browser must support sending the value as-is in XmlHttpRequest). Default value is true.
   * @param {boolean} options.transformResponse If false, processing of the response (such as parsing the response as JSON) will be skipped. Default is true.
   * @param {*} options.* Any other parameters are passed to the interceptors. These can include environmental options such
   *   as "gatewayUri" which then take precedence over those from global environment.
   * @return Promise resolving to a response object (or rejecting to a response object with error field).
   * @method UuApp.AppClient.Client#post
   *
   * @example
   *    // command call sending data
   *    let tenant = "UU-BT";
   *    let guestbookId = "123";
   *    client.post(`/cds-gb/${tenant}/guestbook/${guestbookId}/setAttributes`, {
   *      name: "Modified guestbook",
   *      invitesLimit: 10,
   *      public: true
   *    }).then(console.log.bind(console), console.log.bind(console));
   *
   * @example
   *     // uploading file(s) - variant 1 (explicit Content-Type header)
   *     let file = inputElement.files[0];
   *     let params = {
   *       file: file,
   *       anotherValue: "abc"
   *     }
   *     client.post("/cds-gb/UU-BT/guestbook/123/uploadData", params, {
   *       headers: {
   *         "content-type": "multipart/form-data"
   *       }
   *     });
   *
   *     // uploading file(s) - variant 2 (usage of FormData)
   *     // !!! append files as the last values
   *     let formData = new FormData();
   *     formData.append("anotherValue", "abc");
   *     formData.append("file", file);
   *     let promise = client.post("/cds-gb/UU-BT/guestbook/123/uploadData", formData);
   *     promise.then(...); // process response / error
   *
   *     // aborting ongoing call
   *     elementForUploadCancel.onclick = function (e) {
   *       promise.abort(); // promise will be rejected with UuApp.Error.AbortError instance
   *     };
   *
   * @example
   *    // error distinguishing
   *    client.get("/cds-gb/UU-BT/guestbook/123/getAttributes").then(function success(response) {
   *      console.log(response.status, response.headers(), response.data);
   *    }, function error(response) {
   *      console.log(response.status, response.headers(), response.data);
   *      let error = response.error;
   *      if (error instanceof UuApp.Error.TimeoutError) console.log("Timed out.");
   *      else if (error instanceof UuApp.Error.AbortError) console.log("Aborted.");
   *      else if (error instanceof UuApp.Error.NetworkError) console.log("Communication / network error.");
   *      else if (response.status == 401) console.log("Not authenticated.");
   *      else if (response.status < 500) {
   *        console.log("User or client problem - invalid data / unfulfilled business rules / invalid call / ...", response.data);
   *      } else if (response.status >= 500) console.log("Server-side problem.", response.data);
   *      else console.log("Unrecognized problem.", error);
   *    });
   *
   * @example
   *    // send data in custom format
   *    client.post("/cds-gb/UU-BT/guestbook/123/setSomething", convertToMySuperFormat(dto), {
   *      transformParameters: false,
   *      headers: {
   *        "content-type": "text/x-my-super-format"
   *      }
   *    }).then(console.log.bind(console), console.log.bind(console));
   */
  async post(uri, dtoIn, options) {
    return this._invoke("post", uri, dtoIn, options);
  }

  /**
   * Analog to async post() public method
   * Invokes remote call using HTTP POST request. Default values for settings will
   * be filled in from Client instance configuration and then from global defaults.
   *
   * The client serializes data to and from server using {@link UuApp.AppClient.Client.contentTransformers} according
   * to the specified "content-type" HTTP request/response header.
   * Default value for "content-type" request header for requests with body entity is "application/json; charset=utf-8",
   * except for case when sending {@link https://developer.mozilla.org/en-US/docs/Web/API/FormData FormData} object or
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/File File} (or
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/Blob Blob}) object for which the default value is
   * "multipart/form-data". Default accepted response ("accept" request header) is "application/json".
   * Note that default accepted response can be extended in the future to support formats such as MessagePack and others.
   *
   * Returns properly filled dtoOut described in CMD design
   */
  async cmdPost(uri, dtoIn, options) {
    return this._invoke("post", uri, dtoIn, options, true);
  }
  async _invoke(method, uri, dtoIn, options, shouldUnwrap = false) {
    // prepare request
    let request = {
      method: (method || "post").toLowerCase(),
      uri: uri,
      body: dtoIn,
      headers: {
        ...this._options.headers,
        ...Helpers.keysToLowerCase((options || {}).headers)
      }
    };

    // build invocation chain
    let invocationChain = ((options || {}).interceptors || (this._options || {}).interceptors || this.constructor.getDefaultInterceptors() || []).reduceRight((result, interceptorClass) => {
      return new interceptorClass(result, this._options);
    }, new HttpClient(this._options));

    // invoke request
    let result = await invocationChain.invoke(request, options);
    if (shouldUnwrap) {
      if (typeof window === "object") {
        result = result.data;
      } else if (result.unwrap) {
        result = result.unwrap().body;
      }
    }
    return result;
  }
  static getDefaultInterceptors() {
    return DEFAULT_INTERCEPTORS;
  }
}
module.exports = Client;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/app-client/content-transformers-multipart.browser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  BaseError
} = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");
const {
  LoggerFactory
} = __webpack_require__("../../node_modules/uu_appg01_core-logging/src/index.browser.js");
const dotNotate = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/app-client/dot-notate.js");
let logger;
const MultiPart = {
  serialize: function (value) {
    if (!value) return value;
    if (typeof value !== "object") {
      this._getLogger().warn("Unrecognized value when serializing as multipart/form-data - passing as-is. Value:", {
        value: value
      });
      return value;
    }
    if (value instanceof FormData && typeof value.entries !== "function") return value; // FormData without support for iterating over its entries
    if (value instanceof Blob) value = {
      file: value
    };

    // make a list and reorder values so that the file instances are at the end of the list
    let data = {};
    if (value instanceof FormData) {
      for (const pair of value.entries()) data[pair[0]] = pair[1];
    } else {
      data = value;
    }
    let list = [];
    let hasBinary;
    for (const k in data) {
      let item = data[k];
      if (item instanceof Blob) {
        if (hasBinary) {
          this._getLogger().warn("Too many binary fields. Only single binary field per multipart request is supported.");
        }
        hasBinary = true;
      } else if (typeof item === "object") {
        try {
          list = list.concat(dotNotate(item, k));
          continue;
        } catch (e) {
          throw new BaseError(`Serialization of key: ${k} into FormData failed.` + `Try serializing the nested object beforehand.`, e);
        }
      }
      list.push({
        key: k,
        value: item
      });
    }
    const max = list.length;
    let idx = 0;
    list.sort((a, b) => {
      // stable sort
      const result = (a.value instanceof Blob ? idx + max : idx) - (b.value instanceof Blob ? idx + max : idx);
      idx++;
      return result;
    });

    // fill values into FormData
    let formData = new FormData();
    list.forEach(it => {
      if (it.value instanceof Blob) {
        formData.append(it.key, it.value, it.value.name || `${Date.now()}.bin`);
      } else if (typeof it.value === "boolean") {
        formData.append(it.key, it.value.toString());
      } else {
        formData.append(it.key, it.value);
      }
    });
    return formData;
  },
  deserialize: function (value) {
    throw new BaseError("Deserializing multipart/form-data is not supported. Value: " + value);
  },
  _getLogger: function () {
    if (!logger) {
      logger = LoggerFactory.get("UuApp.AppClient.Client");
    }
    return logger;
  }
};
module.exports = MultiPart;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/app-client/content-transformers.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  Json
} = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");
const {
  LoggerFactory
} = __webpack_require__("../../node_modules/uu_appg01_core-logging/src/index.browser.js");
const MultiPart = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/app-client/content-transformers-multipart.browser.js");
const dotNotate = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/app-client/dot-notate.js");
let logger;
class ContentTransformers {
  /**
   * Transformers which serialize / deserialize content that is sent to / received from
   * server using specific MIME type.
   */
  static get contentTransformers() {
    return Object.freeze({
      "application/json": ContentTransformers.Json,
      // "application/json+extended": Json,
      //"application/x-msgpack": MessagePack,
      //"application/msgpack": MessagePack,
      "application/x-www-form-urlencoded": ContentTransformers.Form,
      "multipart/form-data": ContentTransformers.MultiPart
    });
  }
  static get Json() {
    return {
      serialize: function (value) {
        return Json.stringify(value);
      },
      deserialize: function (value) {
        return value ? Json.parse(value) : null;
      }
    };
  }
  static get Form() {
    return {
      serialize: function (value) {
        if (value == null) return value;
        if (typeof value !== "object") {
          ContentTransformers._getLogger().warn("Unrecognized value when serializing as application/x-www-form-urlencoded - passing as-is. Value:", {
            value: value
          });
          return value;
        }
        let result = dotNotate(value);
        return result.map(({
          key,
          value
        }) => value == null ? "" : `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join("&");
      },
      deserialize: function (value) {
        if (value == null) return value;
        if (typeof value !== "string") {
          ContentTransformers._getLogger.warn("Unrecognized value when deserializing as application/x-www-form-urlencoded - passing as-is. Value:", {
            value: value
          });
          return value;
        }
        let pairs = value.replace(/\+/g, " ").split("&");
        let result = {};
        for (let i = 0; i < pairs.length; ++i) {
          let pair = pairs[i];
          pair.replace(/^([^=]*)=?(.*)$/, (m, g1, g2) => {
            let dg1 = decodeURIComponent(g1);
            let dg2 = decodeURIComponent(g2);
            if (result.hasOwnProperty(dg1)) {
              if (!Array.isArray(result[dg1])) {
                result[dg1] = [result[dg1]];
              }
              result[dg1].push(dg2);
            } else {
              result[dg1] = dg2;
            }
          });
        }
        return result;
      }
    };
  }
  static get MultiPart() {
    return MultiPart;
  }
  static _getLogger() {
    if (!logger) {
      logger = LoggerFactory.get("UuApp.AppClient.Client");
    }
    return logger;
  }
  static _stringify(key, value, result, topLevel) {
    if (Array.isArray(value)) {
      value.forEach((item, i) => ContentTransformers._stringify(`${key}[${i}]`, item, result, false));
    } else if (value && typeof value === "object") {
      for (const k in value) ContentTransformers._stringify(`${key}${topLevel ? "" : "."}${k}`, value[k], result, false);
    } else {
      result.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
    }
  }
}
module.exports = ContentTransformers;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/app-client/dot-notate.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  BaseError
} = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");
module.exports = function dotNotate(object, parent = "") {
  let result = [];
  recurse(parent, object, result, parent ? 1 : 0);
  return result;
};
function recurse(key, value, result, level) {
  if (level > 5) throw new BaseError("Nesting level too deep. Possible circular reference.");
  if (Array.isArray(value)) {
    value.forEach((item, i) => recurse(`${key}[${i}]`, item, result, level + 1));
  } else if (value instanceof Date) {
    result.push({
      key,
      value: value.toISOString()
    });
  } else if (value && typeof value === "object") {
    for (const k in value) {
      recurse(`${key}${level ? "." : ""}${k}`, value[k], result, level + 1);
    }
  } else {
    result.push({
      key,
      value
    });
  }
}

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/app-client/helpers-make-response.browser.js":
/***/ ((module) => {

function makeResponse(responseInfo, error) {
  const response = responseInfo ? responseInfo.response : null;
  const res = {
    status: response ? response.status : 0,
    headers: function (aHeader) {
      if (!aHeader) {
        if (!response) return "";
        let result = [];
        for (let [k, v] of response.headers) result.push(k + ": " + v);
        return result.join("\r\n");
      }
      return response ? response.headers.get(aHeader) : null;
    },
    data: responseInfo && responseInfo.body != null ? responseInfo.body : responseInfo
  };
  if (responseInfo) {
    if (responseInfo.filename !== undefined) {
      res.filename = responseInfo.filename;
      if (res.data) res.data.filename = res.filename;
    }
    if (responseInfo.contentType !== undefined) {
      res.contentType = responseInfo.contentType;
      if (res.data) res.data.contentType = res.contentType;
    }
    if (responseInfo.encoding !== undefined) {
      res.encoding = responseInfo.encoding;
      if (res.data) res.data.encoding = res.encoding;
    }
  }
  return error ? {
    ...res,
    ...error
  } : res;
}
module.exports = makeResponse;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/app-client/helpers.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const makeResponse = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/app-client/helpers-make-response.browser.js");
class Helpers {
  static keysToLowerCase(map) {
    if (!map || typeof map !== "object") return null;
    let result = {};
    for (let k in map) {
      result[k.toLowerCase()] = map[k];
    }
    return result;
  }
  static interceptorMakeResponse(response, request, extraArgs) {
    let rawResponse = makeResponse(response, request, extraArgs);
    if (typeof window == "undefined") {
      // Allow "flat" access to attributes of dtoOut. See test "response-wrapper.test.js" for details.
      // Downside is that it is not possible to flatly access dtoOut attributes in case they are named
      // "status" or "headers".
      // TODO This is only temporary solution for backward compatibility. In can be dropped once proxy
      // is supported by all browsers (so that new API can be used on backend and frontend for some
      // time before old response object is removed).
      return new Proxy(rawResponse, {
        get(target, prop) {
          let result;
          if (prop === "unwrap") {
            result = () => ({
              status: target.status,
              headers: target.headers,
              body: target.data
            });
          } else if (prop === "status" || prop === "headers") {
            // TODO Do not print deprecation warning until same API is available on frontend
            // console.warn(`Using deprecated property ${prop} on AppClient result. Use unwrap() to access raw response data.`);
            result = target[prop];
          } else if (prop === "data") {
            let body = target.data;
            if (typeof body == "undefined" || body === null) {
              result = body;
            } else if (body.hasOwnProperty("data")) {
              result = new Proxy(body, {
                get(target, prop) {
                  let bodyData = target.data;
                  if (prop == "toJSON") {
                    return () => target;
                  } else if (typeof bodyData == "undefined" || bodyData === null) {
                    return target[prop];
                  } else {
                    let result = bodyData[prop];
                    if (typeof result === "undefined") {
                      return target[prop];
                    }
                    if (typeof result === "function") {
                      result = result.bind(bodyData);
                    }
                    return result;
                  }
                }
              });
            } else {
              // TODO Do not print deprecation warning until same API is available on frontend
              // console.warn(`Using deprecated property ${prop} on AppClient result. Use unwrap() to access raw response data.`);
              result = body;
            }
          } else if (prop == "toJSON") {
            result = () => target.data;
          } else {
            let body = target.data;
            if (typeof body != "undefined" && body != null && typeof body[prop] != "undefined") {
              result = body[prop];
              if (typeof result === "function") {
                result = result.bind(body);
              }
            } else {
              result = target[prop];
            }
          }
          return result;
        },
        ownKeys(target) {
          let body = target.data;
          if (typeof body == "undefined" || body === null) {
            return null;
          } else {
            return Object.keys(body);
          }
        },
        getOwnPropertyDescriptor(target, prop) {
          let body = target.data;
          if (typeof body == "undefined" || body === null) {
            return null;
          } else {
            let descriptor = Object.getOwnPropertyDescriptor(body, prop);
            if (descriptor) {
              descriptor.configurable = true;
            }
            return descriptor;
          }
        },
        has(target, key) {
          let body = target.data;
          if (typeof body == "undefined" || body === null) {
            return false;
          } else {
            return key in body;
          }
        }
      });
    } else {
      // TODO Proxy is not supported by IE
      return rawResponse;
    }
  }
  static isObject(item) {
    return item && typeof item === 'object' && !Array.isArray(item);
  }
  static mergeOptions(options, overridingOptions) {
    if (!Helpers.isObject(overridingOptions)) {
      return options;
    }
    Object.keys(overridingOptions).forEach(key => {
      if (Helpers.isObject(overridingOptions[key])) {
        if (!(key in options)) {
          options[key] = overridingOptions[key];
        } else {
          options[key] = Helpers.mergeOptions(options[key], overridingOptions[key]);
        }
      } else {
        options[key] = overridingOptions[key];
      }
    });
    return options;
  }
}
module.exports = Helpers;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/app-client/http-client.browser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  LoggerFactory
} = __webpack_require__("../../node_modules/uu_appg01_core-logging/src/index.browser.js");
const {
  Config,
  OptsReader,
  BaseError,
  Json
} = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");
const {
  TokenSanitizer
} = __webpack_require__("../../node_modules/uu_appg01_core-authentication/src/index.js");
const Helpers = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/app-client/helpers.js");
const ACCESS_TOKEN_PARAM = "access_token";
class HttpClient {
  constructor(options = null) {
    this._options = options;
    this._logger = LoggerFactory.get("UuApp.AppClient.Client");
  }

  // function InvokeClient (cmdClient, httpClientOpts, finalRequest, finalOpts) {
  async invoke(request, options = null) {
    let opts = new OptsReader(options, this._options, Config);

    // TODO Implement abortion support
    // if (cmdClient.aborted) return Promise.reject(Helpers.interceptorMakeResponse(null, finalRequest, { error: new AbortError("The Client call has been aborted.") }));

    let canHaveBody = request.method.match(/^(put|post)$/i);
    let url = request.uri.toString();
    let body;
    if (!canHaveBody) {
      if (request.body) url += (url.indexOf("?") === -1 ? "?" : "&") + request.body;
    } else {
      body = request.body;
    }
    let headers = request.headers;
    let timeout = opts.getNumber("requestTimeout", 0);
    if (this._logger.isDebugLoggable()) {
      this._logger.debug("Invoking request: " + Json.stringify({
        method: request.method,
        url: this._sanitizeQueryParameters(url),
        headers: this._sanitizeHeaders({
          ...headers
        }),
        body: this._sanitizeBody(body),
        requestTimeout: timeout
      }));
    }
    let usedHeaders = {};
    for (let k in headers) {
      let v = headers[k];
      if (k && v != null) {
        // omit "Content-Type" header if it's multipart/form-data, otherwise the browser doesn't update
        // it with proper boundary and server won't be able to parse the body
        if (k === "content-type" && body instanceof FormData && v === "multipart/form-data") continue;
        usedHeaders[k.replace(/(^|-)./g, m => m.toUpperCase())] = v + "";
      }
    }
    let result;
    let responseInfo;
    try {
      let doFetch = async () => {
        let requestData = {
          method: request.method,
          headers: usedHeaders,
          body
        };
        let credentialsPolicy = opts.getString("credentialsPolicy");
        if (credentialsPolicy) {
          requestData.credentials = credentialsPolicy;
        }
        return await fetch(url, requestData);
      };
      if (timeout > 0) doFetch = this._addAsyncFnTimeout(doFetch, timeout * 1000);
      let response = await doFetch();
      responseInfo = {
        response
      };
      const transformResponse = opts.getBoolean("transformResponse", true) === true;
      if (!transformResponse) responseInfo.responseType = "arraybuffer";else Object.assign(responseInfo, this._autodetectBinaryData(response));
      if (opts.getBoolean("enableStreamApi", false) === true && responseInfo.responseType === "arraybuffer") {
        responseInfo.responseType = "stream";
      }

      // status 200 - 5xx
      if (responseInfo.responseType === "stream") {
        responseInfo.body = this._getResponseStream(response);
      } else if (responseInfo.responseType === "arraybuffer") {
        responseInfo.body = new Uint8Array(await response.arrayBuffer());
      } else {
        responseInfo.body = await response.text();
      }
      if (this._logger.isDebugLoggable()) {
        this._logger.debug("Received response: " + Json.stringify({
          url: url,
          status: response.status,
          data: responseInfo.body
        }));
      }
      result = Helpers.interceptorMakeResponse(responseInfo);
    } catch (e) {
      if (e.name === "AbortError") {
        // user / developer abort; AbortError
        this._logger.warn("Request has been aborted: " + Json.stringify({
          url: url
        }), e);
        result = Promise.reject(Helpers.interceptorMakeResponse(responseInfo, {
          error: new BaseError("Request has been aborted - " + url, e)
        }));
      } else if (e.name === "TimeoutError") {
        // TimeoutError
        this._logger.error("Request timed out: " + Json.stringify({
          url: url
        }), e);
        result = Promise.reject(Helpers.interceptorMakeResponse(responseInfo, {
          error: new BaseError("Request timed out - " + url, e)
        }));
      } else {
        // network / other error
        this._logger.error("Request ended with error: " + Json.stringify({
          url: url
        }), e);
        result = Promise.reject(Helpers.interceptorMakeResponse(responseInfo, {
          error: new BaseError("Error - " + url, e),
          data: responseInfo ? responseInfo.body : null
        }));
      }
    }
    return result;
  }
  _addAsyncFnTimeout(runnableFn, timeout) {
    return async () => {
      let timeoutId;
      let timeoutPromise = new Promise((resolve, reject) => timeoutId = setTimeout(() => {
        let error = new Error("Timed out.");
        error.name = "TimeoutError";
        reject(error);
      }, timeout));
      let runnablePromise = runnableFn();
      return Promise.race([runnablePromise, timeoutPromise]).finally(() => clearTimeout(timeoutId));
    };
  }
  _autodetectBinaryData(fetchResponse) {
    function _findMatch(cDisp) {
      let regex = /filename[^;=\n]*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g;
      let match;
      let results = [];
      while ((match = regex.exec(cDisp)) != null) {
        results = results.concat(match.slice(1).filter(m => m));
      }
      let last = results[results.length - 1];
      return last ? decodeURIComponent(last) : null;
    }
    let cDisp;
    try {
      cDisp = fetchResponse.headers.get("Content-Disposition");
    } catch (e) {
      // do nothing
    }
    if (!cDisp) return;
    let responseInfo = {};
    responseInfo.responseType = "arraybuffer";
    responseInfo.filename = _findMatch(cDisp);
    let cType = fetchResponse.headers.get("Content-Type");
    if (cType) {
      let cTypeItems = cType.trim().match(/^([^;\s]+)(?:\s*;\s*charset\s*=\s*([^;]+))?/i) || [];
      responseInfo.contentType = cTypeItems[1] || null;
      responseInfo.encoding = cTypeItems[2] || null;
    }
    return responseInfo;
  }
  _getResponseStream(response) {
    let listeners = {};
    let emitEvent = (event, ...args) => {
      let list = listeners[event];
      if (list) {
        let listCopy = [...list];
        listCopy.forEach(listenerFn => {
          try {
            listenerFn(...args);
          } catch (e) {
            this._logger.error(e);
            // continue with next listener
          }
        });
      }
    };

    let stream = response.body || {}; // we'll return object with on() fn even for browsers not supporting Streams API
    stream.on = (event, callback) => {
      if (!listeners[event]) listeners[event] = [];
      listeners[event].push(callback);
      if (event === "data" || event === "end" || event === "error") startConsumingStream();
    };
    if (!stream[Symbol.asyncIterator]) {
      stream[Symbol.asyncIterator] = async function* () {
        // if stream isn't really stream then return just single chunk with all data
        if (typeof ReadableStream === "undefined" || !(stream instanceof ReadableStream)) {
          let allData = new Uint8Array(await response.arrayBuffer());
          yield allData;
          return;
        }
        let reader = stream.getReader();
        try {
          // eslint-disable-next-line no-constant-condition
          while (true) {
            let {
              done,
              value
            } = await reader.read();
            if (done) break;
            yield value;
          }
        } finally {
          reader.releaseLock();
        }
      };
    }
    let startedConsumingStream = false;
    let startConsumingStream = async () => {
      if (startedConsumingStream) return;
      startedConsumingStream = true;
      try {
        for await (let chunk of stream) {
          emitEvent("data", chunk);
        }
        emitEvent("end");
      } catch (e) {
        if (!listeners["error"]) this._logger.error(e);
        emitEvent("error", e);
      }
    };
    return stream;
  }
  _sanitizeHeaders(headers) {
    if (headers.authorization) {
      headers.authorization = TokenSanitizer.processHeader(headers.authorization);
    }
    return headers;
  }
  _sanitizeQueryParameters(url) {
    return TokenSanitizer.processUri(url);
  }
  _sanitizeBody(body) {
    if (typeof body === "string" && body.includes(ACCESS_TOKEN_PARAM)) {
      let parsedBody;
      try {
        parsedBody = Json.parse(body);
      } catch (e) {
        return body;
      }
      if (parsedBody[ACCESS_TOKEN_PARAM]) {
        parsedBody[ACCESS_TOKEN_PARAM] = TokenSanitizer.processToken(parsedBody[ACCESS_TOKEN_PARAM]);
      }
      body = Json.stringify(parsedBody);
    }
    return body;
  }
}
module.exports = HttpClient;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/error/application-error.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const RemoteError = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/error/remote-error.js");
class ApplicationError extends RemoteError {
  constructor(message = null, response = null) {
    super(message, response);
    if (!this.status) {
      this.status = 400;
    }
  }
}
module.exports = ApplicationError;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/error/invalid-options-error.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  BaseError
} = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");
class InvalidOptions extends BaseError {
  constructor(message, cause) {
    super(message || "Invalid parameters", cause);
    this.code = `uu-app-core-appclient/InvalidParameters`;
  }
}
module.exports = InvalidOptions;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/error/remote-error.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  BaseError,
  Json
} = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");
class RemoteError extends BaseError {
  constructor(message = null, response = null) {
    let errorInitialized = false;
    if (typeof message === "string") {
      super(message);
      this.paramMap = {};
      this.dtoOut = {};
      errorInitialized = true;
    } else if (message.uuAppErrorMap) {
      let keys = Object.keys(message.uuAppErrorMap);
      if (keys.length > 0) {
        for (let key of keys) {
          let error = message.uuAppErrorMap[key];
          if (error.type === "error") {
            super(error.message);
            this.code = key;
            if (error.id) {
              this.id = error.id;
            }
            this.paramMap = error.paramMap;
            this.dtoOut = message;
            if (error.cause && error.cause.uuAppErrorMap) {
              this.cause = new RemoteError(error.cause);
            }
            errorInitialized = true;
            break;
          }
        }
      }
    }
    if (!errorInitialized) {
      super(Json.stringify(message));
      this.paramMap = {};
      this.dtoOut = {};
    }
    if (response) {
      this.response = response;
      this.status = response.status;
    }
  }
}
module.exports = RemoteError;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/error/system-error.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const RemoteError = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/error/remote-error.js");
class SystemError extends RemoteError {
  constructor(message = null, response = null) {
    super(message, response);
    if (!this.status) {
      this.status = 500;
    }
  }
}
module.exports = SystemError;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = {
  get AppClient() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/app-client/client.js");
  },
  get RemoteError() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/error/remote-error.js");
  },
  get ApplicationError() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/error/application-error.js");
  },
  get SystemError() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/error/system-error.js");
  },
  get InvalidOptionsError() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/error/invalid-options-error.js");
  },
  get PerflogHandler() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/perflog-handler.js");
  },
  get RemoteErrorHandler() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/remote-error-handler.js");
  },
  get SessionHandler() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/session-handler.js");
  },
  get TransformParametersHandler() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/transform-parameters-handler.browser.js");
  },
  get UriHandler() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/uri-handler.js");
  },
  get CsrfTokenHandler() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/csrf-token-handler.browser.js");
  },
  get RetryHandler() {
    return __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/retry-handler.browser.js");
  }
};

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/intcp/csrf-token-handler.browser.js":
/***/ ((module) => {

"use strict";


const WINDOW = location.href.startsWith("about:") && window.frameElement ? parent : window;
const BASE_ELEMENT = WINDOW.document.querySelector("base");
const APP_BASE_URI = WINDOW.location.protocol + "//" + WINDOW.location.host + (BASE_ELEMENT && BASE_ELEMENT.getAttribute("data-uu-app-base") || "" || "/");
const CANONICAL_APP_BASE_URI = (new RegExp("uu.app.cbu=([^;]+)").exec(WINDOW.document.cookie) || [])[1];
const CSRF_COOKIE = new RegExp("uu.app.csrf=([^;]+)");
const CSRF_HEADER = "x-csrf-token";

/**
 * Interceptor to inject csrf token to request headers.
 */
class CsrfTokenHandler {
  constructor(next, options = null) {
    this._next = next;
    this._options = options || {};
    this._appBaseUri = APP_BASE_URI.replace(/\/$/, "");
    this._canonicalAppBaseUri = CANONICAL_APP_BASE_URI && CANONICAL_APP_BASE_URI.replace(/\/$/, "");
  }
  async invoke(request, options = null) {
    let csrfToken = (CSRF_COOKIE.exec(WINDOW.document.cookie) || [])[1];
    if (csrfToken && (request.uri.startsWith(this._appBaseUri) || request.uri.startsWith(this._canonicalAppBaseUri))) {
      request.headers[CSRF_HEADER] = csrfToken;
    }
    return this._next.invoke(request, options);
  }
}
module.exports = CsrfTokenHandler;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/intcp/perflog-handler.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  Perflog
} = __webpack_require__("../../node_modules/uu_appg01_core-perflog/src/index.browser.js");
const {
  TokenSanitizer
} = __webpack_require__("../../node_modules/uu_appg01_core-authentication/src/index.js");

/**
 * Interceptor for performance logging.
 */
class PerfLogHandler {
  constructor(next, options = null) {
    this._next = next;
  }
  async invoke(request, options = null) {
    return new Promise((resolve, reject) => {
      Perflog.measureSection("UU_APP_CLIENT_REQUEST", async section => {
        request.headers["x-request-id"] = section.getId().toString();
        let uri = TokenSanitizer.processUri(request.uri.toString());
        section.setAttribute("uri", uri);
        try {
          resolve(await this._next.invoke(request, options));
        } catch (e) {
          reject(e);
        }
      });
    });
  }
}
module.exports = PerfLogHandler;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/intcp/remote-error-handler.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ApplicationError = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/error/application-error.js");
const SystemError = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/error/system-error.js");
const {
  LoggerFactory
} = __webpack_require__("../../node_modules/uu_appg01_core-logging/src/index.browser.js");

/**
 * Interceptor for extracting error information from response.
 */
class RemoteErrorHandler {
  constructor(next, options = null) {
    this._next = next;
    this._logger = LoggerFactory.get("UuApp.AppClient.Interceptor.RemoteErrorHandler");
  }
  async invoke(request, options = null) {
    // NOTE We assume that the "content-type" transformation has been already performed on response data.
    let response = await this._next.invoke(request, options);
    if (response.status < 400) {
      this._logger.info(`Request ${request.uri} ended with status code: ${response.status}`);
    }
    if (response.status >= 400) {
      let errorData = response.data || {};
      if (response.status < 500) {
        this._logger.warn(`Request ${request.uri} ended with status code: ${response.status}${this._addUuAppErrorMap(response)}`);
        throw new ApplicationError(errorData, response);
      } else {
        this._logger.error(`Request ${request.uri} failed with status code: ${response.status}${this._addUuAppErrorMap(response)}`);
        throw new SystemError(errorData, response);
      }
    }
    return response;
  }
  _addUuAppErrorMap(response) {
    if (!response.data.uuAppErrorMap) {
      return "";
    }
    let errorCode = Object.keys(response.data.uuAppErrorMap)[0];
    let foundError = response.data.uuAppErrorMap[errorCode];
    let optionalMessage = `, uuAppErrorMap code: ${errorCode}, message: ${foundError.message}`;
    if (foundError.paramMap) {
      optionalMessage += `, paramMap: ${JSON.stringify(foundError.paramMap)}`;
    }
    return optionalMessage;
  }
}
module.exports = RemoteErrorHandler;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/intcp/retry-handler-core.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Helpers = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/app-client/helpers.js");
const InvalidParameters = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/error/invalid-options-error.js");
const {
  LoggerFactory
} = __webpack_require__("../../node_modules/uu_appg01_core-logging/src/index.browser.js");
const {
  Json
} = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");

/**
 * Core Interceptor for retry policy  working. Should be extended by retry and retry browser interceptor to avoid code duplication
 */
class RetryHandlerCore {
  constructor(next, options = null) {
    this._next = next;
    this._validateOptions(options);
    this._options = options.retryPolicy;
    this._attempt = 0;
    this._originalRequestId = null;
    this._logger = LoggerFactory.get("UuApp.AppClient.Interceptor.RetryHandler");
  }
  async invoke(request, options = null) {
    let response;
    try {
      response = await this._next.invoke(request, options);
    } catch (e) {
      if (e.cause && e.cause.code === "ENOTFOUND") {
        return await this._processRetryPolicyForClientErrors(request, options, e);
      }
      throw e;
    }
    if (options != null) {
      this._options = Helpers.mergeOptions(this._options, options.retryPolicy);
    }
    this._originalRequestId = request.headers["x-request-id"];
    if (!this._shouldRetry(request, response, this._options)) {
      return response;
    }

    // Check if body contain streams
    if (request.headers["content-type"] && (request.headers["content-type"].startsWith("multipart/form-data") || request.headers["content-type"].startsWith("application/octet-stream")) && this._containStream(request.body)) {
      this._logger.debug(`Request failed and wont be repeated as it contains binary stream. requestId=${this._originalRequestId}`);
      return response;
    }
    response = await this._processRetryPolicy(request, response, options);
    return response;
  }
  async _processRetryPolicy(request, response, options) {
    let retryAfter = false;
    this._attempt++;
    if (!this._shouldRetry(request, response, this._options)) {
      return response;
    }
    if (response.status === 503) {
      let retryAfterHeader = this._parseHeaders(response.headers())["retry-after"];
      if (retryAfterHeader) {
        retryAfter = this._getRetryAfterFromHeader(retryAfterHeader);
      }
    }
    if (retryAfter && retryAfter > this._options.maxTimeInterval) {
      this._logger.debug(`Request wont be repeated. Response retry-after header is after max time interval. requestId=${this._originalRequestId}, retryAfter=${retryAfter}, maxTimeInterval=${this._options.maxTimeInterval}`);
      return response;
    }
    let sleepTime;
    request.headers["x-request-id"] = `${this._originalRequestId}-${this._attempt.toString().padStart(3, "0")}`;
    if (!retryAfter) {
      sleepTime = this._getRandomIntInclusive(0, Math.min(this._options.maxTimeInterval, this._options.baseTimeInterval * Math.pow(2, this._attempt)));
    }
    this._logger.error(`Request failed. Retry conditions valid, retrying the request in ${sleepTime}ms. originalRequestId=${this._originalRequestId}, originalResponseStatus=${response.status}, requestUri=${request.uri.toString()}, originalResponseData=${Json.stringify(response.data)}, attempt=${this._attempt}, retryPolicy=${Json.stringify(this._options)}`);
    await this._timeout(sleepTime);
    response = await this._next.invoke(request, options);
    return await this._processRetryPolicy(request, response, options);
  }
  async _processRetryPolicyForClientErrors(request, options, exception) {
    this._attempt++;
    if (options == null || options.maxAttempts < 1 || this._attempt > this._options.maxAttempts) {
      throw exception;
    }
    let sleepTime = this._getRandomIntInclusive(0, Math.min(this._options.maxTimeInterval, this._options.baseTimeInterval * Math.pow(2, this._attempt)));
    this._logger.error(`Request failed. Retry conditions valid, retrying the request in ${sleepTime}ms. originalRequestId=${this._originalRequestId}, attempt=${this._attempt}, retryPolicy=${Json.stringify(this._options)}`);
    await this._timeout(sleepTime);
    let response;
    try {
      response = await this._next.invoke(request, options);
      return response;
    } catch (e) {
      return await this._processRetryPolicyForClientErrors(request, options, e);
    }
  }
  async _timeout(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  _parseHeaders(rawHeaders) {
    let parsedHeaders = {};
    rawHeaders.split("\n").forEach(header => {
      const [key, value] = header.split(/\s*:\s/);
      parsedHeaders[key] = value;
    });
    return parsedHeaders;
  }
  _getRetryAfterFromHeader(retryAfter) {
    if (!retryAfter) {
      return false;
    }
    if (!isNaN(retryAfter)) {
      return parseInt(retryAfter) * 1000;
    }
    const retryDateTimestamp = Date.parse(retryAfter);
    if (isNaN(retryDateTimestamp)) {
      return false;
    }
    const diff = retryDateTimestamp - Date.now();
    if (diff <= 0) {
      return false;
    }
    return diff;
  }
  _getRandomIntInclusive(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  _shouldRetry(request, response, options) {
    // Check maxAttempts
    if (options.maxAttempts < 1) {
      return false;
    }
    if (this._attempt > this._options.maxAttempts) {
      this._logger.debug(`Request wont be repeated. Max attempts exceeded. requestId=${this._originalRequestId}, requestAttempt=${this._attempt}, maxAttempts=${this._options.maxAttempts}`);
      return false;
    }

    // Check http methods
    if (!this._checkHttpMethod(this._options.retryCondition.httpMethods, request.method)) {
      this._logger.debug(`Request wont be repeated. Http method condition invalid. requestId=${this._originalRequestId}, requestHttpMethod=${request.method}, retryHttpMethods=${this._options.retryCondition.httpMethods}`);
      return false;
    }

    // Check httpStatuses
    if (!this._options.retryCondition.httpStatusCodes || !this._checkStatusCode(this._options.retryCondition.httpStatusCodes, response.status.toString())) {
      this._logger.debug(`Request wont be repeated. Http status condition invalid. requestId=${this._originalRequestId}, responseHttpStatus=${response.status.toString()}, retryHttpStatus=${this._options.retryCondition.httpStatusCodes}`);
      return false;
    }
    return true;
  }
  _checkHttpMethod(requiredHttpMethods = [], method) {
    if (requiredHttpMethods.length < 1) {
      return false;
    }
    const normalizedMethod = method.toUpperCase();
    if (requiredHttpMethods.includes(normalizedMethod)) {
      return true;
    }
    return false;
  }
  _checkStatusCode(requiredStatuses = [], status) {
    const checkStatusRegex = new RegExp("[0-9]([0-9]|x){2}");
    const replacerRegex = new RegExp("x", "g");
    if (requiredStatuses.length < 1) {
      return false;
    }
    if (!status) {
      return false;
    }
    if (typeof status !== "string" || !status.match(checkStatusRegex)) {
      return false;
    }
    for (let requiredStatus of requiredStatuses) {
      const compareRegex = new RegExp(requiredStatus.replace(replacerRegex, "[0-9]"));
      if (status.match(compareRegex)) {
        return true;
      }
    }
    return false;
  }

  /* According to requirements body should be checked to avoid retry with streams inside body.
  * There are use-cases when body is stream by itself so we cannot retry it:
   * 1) Sending stream data with application/octet-stream header
  * 2) Sending FormData (or another data that will be converted to FormData by content transformers)
  *
  * In the second case if body is FormData we should check if it contains data that have streams, but in current
  * implementation it is not possible as after failure request data is not accessible. Also FormData have not entries method
  * to access data and the only way to do this is to use "_streams" private parameter that is not safety;
  *
  * As FormData is stream itself all requests with FormData body will not retry.
  * TODO The check might be improved in further implementation by rebuilding FormData one more time if it does not contain stream inside.
  */
  _containStream(body = {}) {
    if (this._isStream(body)) {
      return true;
    }
    return false;
  }
  _isStream(value) {
    // overridden by subclasses
    return false;
  }
  _validateOptions(options) {
    if (!options) {
      throw new InvalidParameters("Options are required in RetryHandler");
    }
    if (typeof options !== "object") {
      throw new InvalidParameters("Options must be object");
    }
    if (!options.retryPolicy) {
      throw new InvalidParameters("Options.retryPolicy is required");
    }
    if (typeof options.retryPolicy !== "object") {
      throw new InvalidParameters("Options.retryPolicy must be object");
    }
    if (!options.retryPolicy.maxTimeInterval) {
      throw new InvalidParameters("Options.retryPolicy.maxTimeInterval is required");
    }
    if (typeof options.retryPolicy.maxTimeInterval !== "number" || options.retryPolicy.maxTimeInterval < 0) {
      throw new InvalidParameters("Options.retryPolicy.maxTimeInterval must be positive integer");
    }
    if (!options.retryPolicy.baseTimeInterval) {
      throw new InvalidParameters("Options.retryPolicy.baseTimeInterval is required");
    }
    if (typeof options.retryPolicy.baseTimeInterval !== "number" || options.retryPolicy.baseTimeInterval < 0) {
      throw new InvalidParameters("Options.retryPolicy.baseTimeInterval must be positive integer");
    }
    if (options.retryPolicy.maxAttempts == null) {
      throw new InvalidParameters("Options.retryPolicy.maxAttempts is required");
    }
    if (typeof options.retryPolicy.maxAttempts !== "number" || options.retryPolicy.maxAttempts < 0) {
      throw new InvalidParameters("Options.retryPolicy.maxAttempts must be positive integer");
    }
    if (!options.retryPolicy.retryCondition) {
      throw new InvalidParameters("Options.retryPolicy.retryCondition is required");
    }
    if (typeof options.retryPolicy.retryCondition !== "object") {
      throw new InvalidParameters("Options.retryPolicy.retryCondition must be object");
    }
    if (!options.retryPolicy.retryCondition.httpMethods) {
      throw new InvalidParameters("Options.retryPolicy.retryCondition.httpMethods is required");
    }
    if (!Array.isArray(options.retryPolicy.retryCondition.httpMethods)) {
      throw new InvalidParameters("Options.retryPolicy.retryCondition.httpMethods must be array");
    }
    options.retryPolicy.retryCondition.httpMethods.forEach(method => {
      const availableMethods = ["GET", "POST", "HEAD", "PUT", "DELETE", "CONNECT", "OPTIONS", "TRACE", "PATCH"];
      if (!availableMethods.includes(method)) {
        throw new InvalidParameters(`Incorect httpMethod - ${method} in retryCondition.httpMethods list. Should be one of ${Json.stringify(availableMethods)}`);
      }
    });
    if (!options.retryPolicy.retryCondition.httpStatusCodes) {
      throw new InvalidParameters("Options.retryPolicy.retryCondition.httpStatusCodes is required");
    }
    if (!Array.isArray(options.retryPolicy.retryCondition.httpStatusCodes)) {
      throw new InvalidParameters("Options.retryPolicy.retryCondition.httpStatusCodes must be array");
    }
    options.retryPolicy.retryCondition.httpStatusCodes.forEach(method => {
      const pattern = "[0-9]([0-9]|x){2}";
      const checkStatusRegex = new RegExp(pattern);
      if (typeof method !== "string") {
        throw new InvalidParameters("HttpStatusCode in retryCondition.httpStatusCodes list must be string");
      }
      if (!method.match(checkStatusRegex)) {
        throw new InvalidParameters(`HttpStatusCode in retryCondition.httpStatusCodes must meet regex pattern ${pattern}`);
      }
    });
    return true;
  }
}
module.exports = RetryHandlerCore;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/intcp/retry-handler.browser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const RetryHandlerCore = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/intcp/retry-handler-core.js");

/**
 * Interceptor for retry policy working.
 */
class RetryHandler extends RetryHandlerCore {
  constructor(next, options = null) {
    super(next, options);
  }
  _containStream(body = {}) {
    if (body instanceof FormData) {
      return this._isStreamInFormData(body);
    }
    return !!this._isStream(body);
  }
  _isStreamInFormData(formData) {
    if (formData == null || !(formData instanceof FormData)) {
      return false;
    }
    let entries = formData.entries();
    if (typeof entries[Symbol.iterator] !== "function") {
      return false;
    }
    for (let data of entries) {
      const [, value] = data;
      if (value instanceof Blob) {
        return true;
      }
    }
    return false;
  }
  _isStream(value) {
    return value instanceof Blob;
  }
}
module.exports = RetryHandler;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/intcp/session-handler.js":
/***/ ((module) => {

"use strict";


/**
 * Interceptor for Client which authenticates command calls by using token from session object.
 *
 * Interceptor is skipped if there's request header "authorization" set for the command call, even
 * if the header value is null.
 */
class SessionHandler {
  constructor(next, options = null) {
    this._next = next;
    this._options = options || {};
  }
  async invoke(request, options = null) {
    let hasCustomAuthn = ("authorization" in request.headers);
    if (hasCustomAuthn) {
      return this._next.invoke(request, options);
    }
    let opts = Object.assign(this._options, options);
    let session = opts.session;
    if (session) {
      let scope = null;
      if (typeof session.getCallTokenScope === "function") {
        scope = await session.getCallTokenScope(request.uri, opts);
      } else {
        scope = request.uri.toString().split("?")[0];
      }
      let callToken = await session.getCallToken(scope, opts);
      if (callToken) {
        request.headers["authorization"] = callToken;
      }
    }
    return this._next.invoke(request, options);
  }
}
module.exports = SessionHandler;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/intcp/transform-parameters-handler.browser.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ContentTransformers = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/app-client/content-transformers.js");
const {
  Config,
  OptsReader,
  BaseError,
  Json
} = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");

/**
 * Interceptor for transforming request parameters / response entity according to the Content Type.
 * Recognized options:
 *
 * - transformParameters {boolean} - whether to transform (serialize by Content-Type) request body
 * - transformResponse {boolean} - whether to transform (deserialize by Content-Type) response body
 * - wrapQuery {boolean} - whether to wrap request body with { dto: ... }
 */
class TransformParametersHandler {
  constructor(next, options = null) {
    this._next = next;
    this._options = options;
  }
  async invoke(request, options = null) {
    let opts = new OptsReader(options, this._options, Config);

    // add default Content-Type & Accept headers
    let paramsInBody = request.method.match(/^(put|post)$/i);
    let contentTransformers = ContentTransformers.contentTransformers || {};
    let contentType = paramsInBody ? request.headers["content-type"] : null;
    if (!("content-type" in request.headers)) {
      if (paramsInBody) {
        let isMultipartPreferred = request.body != null && (request.body instanceof FormData || request.body instanceof Blob || typeof request.body == "object" && Object.keys(request.body).some(it => request.body[it] instanceof Blob));
        contentType = isMultipartPreferred ? "multipart/form-data" : "application/json; charset=utf-8";
        request.headers["content-type"] = contentType;
      } else {
        contentType = "application/x-www-form-urlencoded";
      }
    }
    if (!("accept" in request.headers)) request.headers["accept"] = "application/json";

    // wrap request data into "dto" parameter if requested to do so
    if (opts.getBoolean("transformParameters") !== false && !paramsInBody && request.body != null && opts.getBoolean("wrapQuery") && contentType === "application/x-www-form-urlencoded") {
      request.body = {
        dto: Json.stringify(request.body)
      };
    }

    // transform request data
    if (opts.getBoolean("transformParameters") !== false && request.body != null) {
      let contentHandler = contentTransformers[this._getMimeMainType(contentType)];
      try {
        if (contentHandler) request.body = contentHandler.serialize(request.body);
      } catch (e) {
        throw new BaseError("Error while serializing data.", e);
      }
    }
    let response = await this._next.invoke(request, options);
    let respContentDisposition = response.headers("content-disposition");
    if (opts.getBoolean("transformResponse") !== false && !respContentDisposition) {
      let respContentType = response.headers("content-type");
      let contentHandler = contentTransformers[this._getMimeMainType(respContentType)];
      try {
        if (response.status === 204) response.data = null;else if (contentHandler) response.data = contentHandler.deserialize(response.data);
      } catch (e) {
        throw new BaseError("Error while deserializing response data.", e);
      }
    }
    return response;
  }
  _getMimeMainType(mimeType) {
    return (mimeType || "").replace(/[+;].*/, "").trim();
  }
}
module.exports = TransformParametersHandler;

/***/ }),

/***/ "../node_modules/uu_appg01_core-appclient/src/intcp/uri-handler.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  Config,
  OptsReader
} = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");

/**
 * Interceptor for finalizing uuUri URL in case it's incomplete (missing gateway).
 */
class UriHandler {
  constructor(next, options = null) {
    this._next = next;
    this._options = options;
  }
  async invoke(request, options = null) {
    let uri = "";
    let ucUri = (request.uri || "").toString();
    if (!ucUri.match(/^https?:/i)) {
      let opts = new OptsReader(options, this._options);
      let baseUri = opts.getString("baseUri");
      if (!baseUri || !baseUri.match(/^https?:/i)) {
        opts = new OptsReader(options, this._options, Config);
        let gatewayUri = opts.getString("gatewayUri", "https://uuappg01.plus4u.net");
        uri += `${gatewayUri.replace(/\/$/, "")}/`;
      }
      if (baseUri) {
        uri += `${baseUri.replace(/^\/|\/$/g, "")}/`;
      }
      uri += ucUri.replace(/^\//, "");
    } else {
      uri += ucUri;
    }
    request.uri = uri;
    return this._next.invoke(request, options);
  }
}
module.exports = UriHandler;

/***/ }),

/***/ "./index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let clientClass;
module.exports = {
  get AppClient() {
    let AppClient = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/index.js");
    // support legacy API
    AppClient.Client = AppClient.AppClient;
    return AppClient;
  },
  get Client() {
    // Because of fix of https://uuapp.plus4u.net/uu-sls-maing01/93748ca422c44cf5b2184a0e8981bb72/issueDetail?id=6502f1f83d055c003c9eb9c2
    // we have to add also export of "Client", because else "const { Client } = require("uu_appg01_core");" will not work and will break
    // backward compatibility.
    if (!clientClass) {
      let {
        AppClient
      } = __webpack_require__("../node_modules/uu_appg01_core-appclient/src/index.js");
      clientClass = AppClient;
    }
    return clientClass;
  },
  set Client(clientOverride) {
    // This is for backward compatibility for components still using uuApp 4.x and mixing it with uuAppCore 5.x. In that case we need to allow
    // overriding of exported client which effectively nullifies the fix mentioned above in getter, but allows application to work like before.
    clientClass = clientOverride;
  },
  get Uri() {
    return __webpack_require__("../../node_modules/uu_appg01_core-uri/src/index.js");
  },
  get Logging() {
    return __webpack_require__("../../node_modules/uu_appg01_core-logging/src/index.browser.js");
  },
  get Util() {
    return __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");
  },
  get Utils() {
    return __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");
  },
  get Perflog() {
    return __webpack_require__("../../node_modules/uu_appg01_core-perflog/src/index.browser.js");
  },
  get Authentication() {
    return __webpack_require__("../../node_modules/uu_appg01_core-authentication/src/index.js");
  },
  get Error() {
    let Utils = __webpack_require__("../../node_modules/uu_appg01_core-utils/src/index.js");
    return {
      Error: Utils.BaseError
    };
  }
};

/***/ }),

/***/ "../target/webpack-tmp/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mod = __webpack_require__("module");
var isDoc = typeof document !== "undefined";
var uri = ((mod ? mod.uri : isDoc && (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName("script"), -1)[0] || {}).src) || "").toString();
uri = uri.split(/\//).slice(0, -1).join("/") + "/"; // runtime publicPath configuration required for proper linking of styles, background images, ...
var floatingVersion = "/5.0.0/";
if (uri.substr(-floatingVersion.length) === floatingVersion) uri = uri.substr(0, uri.length - floatingVersion.length) + "/5.20.1/";
__webpack_require__.p = (typeof process !== "undefined" && process.env && (process.env.NODE_ENV) || "development") === "test" && uri === "/" ? "file://" + eval("__filename").replace(/[^/\\]*$/, "") : uri;
module.exports = __webpack_require__("./index.js");
var ex = module.exports;
if (ex && typeof ex === "object") {
  if (!("version" in ex)) Object.defineProperty(ex, "version", {
    configurable: true,
    value: "5.20.1"
  });
  if (!("name" in ex)) Object.defineProperty(ex, "name", {
    configurable: true,
    value: "uu_appg01_core".split(/[\/\\]/).pop()
  });
  if (!("namespace" in ex)) Object.defineProperty(ex, "namespace", {
    configurable: true,
    value: "UuApp"
  });
}

/***/ }),

/***/ "module":
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_module__;

/***/ }),

/***/ "?92d6":
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?b0ca":
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?af91":
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?ba0d":
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?1930":
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?3a50":
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?6b0b":
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?c4af":
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "";
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("../target/webpack-tmp/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});