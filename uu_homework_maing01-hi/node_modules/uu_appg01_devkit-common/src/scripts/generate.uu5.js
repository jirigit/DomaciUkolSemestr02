const fs = require("fs-extra");
const path = require("path");

const Package = require("../tools/package.js");
const StringUtil = require("../tools/string-util.js");

const srcDir = "src"; // TODO paths
const testDir = "test";

const PURE_EXPORTS_COMMENT = "devkit-pure-exports";
const PURE_EXPORTS_COMMENT_RE = new RegExp(
  String.raw`(^|\n)\s*(//[ \t]*${PURE_EXPORTS_COMMENT}\b|/\*[ \t]*${PURE_EXPORTS_COMMENT}\b)`
);

const DECORATION_COMPONENTS = [
  {
    regexp: /divider/i,
    decorationComponentName: "HorizontalDivider",
    decorationComponentProps: { src: { xs: "", m: "" }, bgSrc: "", bottomBgColor: "" },
  },
  { regexp: /stripe/i, decorationComponentName: "HorizontalStripe", decorationComponentProps: { src: "", height: 50 } },
  { regexp: /image/i, decorationComponentName: "Image", decorationComponentProps: { src: "" } },
];
const LIB_DESCRIPTOR_KEYS_ORDER = [
  "code",
  "name",
  "tagList",
  "docCode",
  "desc",
  "icon",
  "imageUri",
  "uuEccReady",
  "template",
];

module.exports = class Generate {
  constructor(config) {
    this.config = config;
  }

  async process() {
    // let pack = Package.getSingletonSync("package.json");
    // let { type } = pack.templateInfo;
    let config = this.config.getAll();
    let { entityType, demo, test, register } = config;

    let name = this.config.commandLineConfig._[0];
    let pkgName = this.config.commandLineConfig._[1];
    if (entityType === "package") await Generate.generatePackage(name);
    else if (entityType === "component" || entityType === "visualComponent" || entityType === "decorationComponent") {
      await Generate.generateComponent(
        name,
        pkgName,
        demo,
        test,
        register,
        config,
        entityType,
        this.config.getWorkspaceLibraryList()
      );
    } else {
      console.log(`Examples:
  npm run generate component Loader
  npm run generate component Loader -- --no-demo --no-register --no-test
  npm run generate visualComponent Calculator
  npm run generate visualComponent Routes.Calculator
  npm run generate decorationComponent Sheep
  npm run generate package routes
  npm run generate package Routes   # same as "routes"`);
    }
  }

  static async generatePackage(fullPackageName, pack = Package.getSingletonSync("package.json")) {
    let templateType = pack.templateInfo.type;
    let templateDir = path.resolve(__dirname + "/../templates-generator/__uu5/package");

    // generate package / nested packages directories
    let filePromises = [];
    let packageInfo = await [srcDir, ...fullPackageName.split(/[/.]/)]
      .filter(Boolean)
      .reduce(async (packInfoPromise, packageName, i, arr) => {
        let packageNameCamelCase = i ? StringUtil.camelCase(packageName) : packageName;
        let packageNameDashCase = i ? StringUtil.dashCase(packageNameCamelCase) : packageName;
        let {
          packageDir: parentPackageDir,
          packageConfigDirPrefix: parentPackageConfigDirPrefix,
          packageNamespace: parentPackageNamespace,
        } = (await packInfoPromise) || {};
        let packageNamespace = i ? parentPackageNamespace + "." + packageNameCamelCase : pack.get().namespace;
        let packageDir = i ? parentPackageDir + "/" + packageNameDashCase : packageNameDashCase;
        await fs.mkdirp(packageDir);

        // generate config/* files inside current (sub)package
        let packageConfigDirName = /*i ? "" :*/ "config";
        let packageConfigDirPrefix = /*i ? "" :*/ packageConfigDirName + "/";
        let packConfigDir = /*i ? packageDir :*/ packageDir + "/" + packageConfigDirName;
        if (packageDir !== packConfigDir) await fs.mkdirp(packConfigDir);
        let context = {
          name: pack.name,
          namespace: pack.get().namespace,
          parentPackageConfigRelPath:
            "../" + (packageConfigDirName ? "../" : "") + (parentPackageConfigDirPrefix || ""),
          packageNameCamelCase,
          packageNameDashCase,
          packageNamespace,
        };
        filePromises.push(
          generateFile(templateDir + (i ? "/config.sub.js" : "/config.js"), packConfigDir + "/config.js", context)
        );

        // generate main file with exports of the package
        let packageFile;
        if (templateType === "uu5-lib") {
          if (i === 0) {
            filePromises.push(generateFile(templateDir + "/index.js", packageDir + "/index.js", context));
          }

          let mainFileName = i ? packageNameDashCase + ".js" : "exports.js";
          let mainTplFileName = i ? "exports.sub.js" : "exports.js";
          packageFile = packageDir + "/" + mainFileName;
          filePromises.push(
            await generateFile(
              templateDir + "/" + mainTplFileName,
              packageFile,
              (content) => {
                // add exports of the nested package
                if (i < arr.length - 1) {
                  let subPackageNameCamelCase = StringUtil.camelCase(arr[i + 1]);
                  let subPackageNameDashCase = StringUtil.dashCase(subPackageNameCamelCase);
                  let exportStr = `export * as ${subPackageNameCamelCase} from "./${subPackageNameDashCase}/${subPackageNameDashCase}.js";`;
                  if (!content.includes(exportStr)) {
                    content = [content.trimEnd(), exportStr, ""].join("\n");
                  }
                }
                return content;
              },
              context
            )
          );
        }
        return {
          packageDir,
          packageConfigDirPrefix,
          packageFile,
          packageNamespace,
        };
      }, null);
    await Promise.all(filePromises);

    // add startup file(s) to index.js (if using pure exports)
    if (templateType === "uu5-lib" && !fs.existsSync(path.join(srcDir, "startup.js"))) {
      let exportsContent = fs.readFileSync(path.join(srcDir, "exports.js"), "utf-8");
      if (PURE_EXPORTS_COMMENT_RE.test(exportsContent)) {
        await generateFile("", path.join(srcDir, "index.js").replace(/\\/g, "/"), (indexContent) => {
          let hasStartupImport = /import "\.\/config\/config(\.js)?"/.test(indexContent);
          if (!hasStartupImport) {
            let toInsert = `import "./config/config.js"; // startup (<style> element initialization)`;
            let uu5ImportMatch = indexContent.match(/^import .*"uu5g0[45]";\r?\n/);
            let newIndexContent;
            if (uu5ImportMatch) {
              newIndexContent =
                indexContent.slice(0, uu5ImportMatch.index + uu5ImportMatch[0].length) +
                toInsert +
                "\n" +
                indexContent.slice(uu5ImportMatch.index + uu5ImportMatch[0].length);
            } else {
              newIndexContent = indexContent.trimEnd() + toInsert + "\n";
            }
            return newIndexContent;
          }
        });
      }
    }

    return packageInfo;
  }

  static async generateComponent(
    name,
    packageName,
    demo = true,
    test = true,
    register = true,
    config,
    componentType,
    workspaceLibList,
    pack = Package.getSingletonSync("package.json")
  ) {
    if (!name) throw new Error("Component name must be given.");
    let NAME_REGEXP = /^[a-zA-Z0-9\-_/.]*$/;
    if (!name.match(NAME_REGEXP)) throw new Error("Component name must match: " + NAME_REGEXP.source);
    let pkgParts = name.split(/[./]/);
    let usedName = pkgParts.pop();
    let usedPkgName = [packageName, ...pkgParts].filter(Boolean).join(".");
    if (componentType === "decorationComponent") return this.generateDecorationComponent(usedName, usedPkgName, pack);

    let isVisual = componentType === "visualComponent";
    let { packageDir, packageConfigDirPrefix, packageFile, packageNamespace } = await this.generatePackage(usedPkgName);

    let componentNameCamelCase = StringUtil.camelCase(usedName);
    let componentNameDashCase = StringUtil.dashCase(componentNameCamelCase);

    // generate component & demo & test file
    let templateType = pack.templateInfo.type;
    let templateDir = path.resolve(__dirname + "/../templates-generator/__uu5");
    let namespace = pack.get().namespace;
    let libIsSubmodule = namespace.includes(".");
    let libRootNamespace = libIsSubmodule ? namespace.split(".")[0] : null;
    let libRootNamespaceLibName;
    if (libRootNamespace) {
      let externals = config.externals || (pack.get().uuBuildSettings || {}).externals || {};
      libRootNamespaceLibName = Object.keys(externals).find(
        (libName) => externals[libName] === libRootNamespace || externals[libName].globalVariable === libRootNamespace
      );
    }
    let context = {
      name: pack.name,
      tagName: packageNamespace + "." + componentNameCamelCase,
      componentNameCamelCase,
      componentNameDashCase,
      packageConfigDirPrefix: packageConfigDirPrefix,
      libRootNamespace,
      libRootNamespaceLibName,
    };
    await generateFile(
      templateDir + (isVisual ? "/visual-component.js" : "/component.js"),
      packageDir + "/" + componentNameDashCase + ".js",
      context
    );
    if ((templateType === "uu5-lib" || templateType === "lib") && demo) {
      let relevantPackagePath = (
        packageDir.replace(/\/*$/, "/").startsWith(srcDir + "/") ? packageDir.slice(srcDir.length + 1) : packageDir
      ).replace(/\/*$/, "/");
      let hasExampleConfig =
        fs.existsSync(path.join("..", "example-config.js")) ||
        fs.existsSync(path.join(srcDir, "assets/example-config.js")) ||
        fs.existsSync(path.join("target/dist/assets/example-config.js"));
      if (!hasExampleConfig && workspaceLibList.length > 1) {
        // in multi-library project generate example-config.js only to "main" project because
        // assets are merged together among all of them
        let workspaceLibItem = workspaceLibList.find((it) => it.pkg.name === pack.name);
        if (workspaceLibItem) {
          hasExampleConfig = workspaceLibList.some(
            (it) =>
              it !== workspaceLibItem &&
              (fs.existsSync(path.join(it.path, srcDir, "assets/example-config.js")) ||
                fs.existsSync(path.join(it.path, "target/dist/assets/example-config.js")))
          );
        }
      }
      Object.assign(context, {
        cdnBaseUri: config.sourceUri
          ? config.sourceUri.replace(/%s/g, () => config.version.replace(/\..*/, ".0.0")).replace(/^(.*\/).*/, "$1")
          : "/",
        hasExampleConfig,
      });
      if (config.externalsUu5g05) {
        context.uu5g05ExampleConfigUri = config.externalsApp["uu5g05"].cdnBaseUri.replace(
          /\/[^/]*$/,
          "/assets/example-config.js"
        );
      }
      if (!hasExampleConfig) {
        let cdnBaseUriNoVersion = context.cdnBaseUri.replace(/\/\d+\.\d+\.\d+.*/, "/");
        let urlMap = {};
        for (let k in config.externalsApp) {
          if (config.externalsUu5g05 && k in config.externalsUu5g05) continue; // demo links uu5g05's example-config.js with uu5g05's own deps already set
          let item = config.externalsApp[k];
          if (!item.cdnBaseUri) continue;
          urlMap[k] =
            (item.cdnBaseUri.startsWith(cdnBaseUriNoVersion)
              ? cdnBaseUriNoVersion + config.version.replace(/\..*/, ".0.0") + "/"
              : item.cdnBaseUri) + (item.mainMinified || item.main);
        }
        context.loaderUrlMap = Package.sort(urlMap, ["react", "react-dom", "create-react-class", "prop-types"]);
        delete context.loaderUrlMap[pack.name];
        context.loaderUrlMap[pack.name] = context.cdnBaseUri + pack.name + ".min.js";
      }
      await generateFile(
        templateDir + "/component-demo.html",
        "demo/" + (relevantPackagePath !== "/" ? relevantPackagePath : "") + componentNameDashCase + ".html",
        context
      );
    }

    if (test) {
      let compTestDir = testDir + packageDir.replace(/^[^/\\]*/, "");
      await generateFile(
        templateDir + (isVisual ? "/visual-component-test.js" : "/component-test.js"),
        compTestDir + "/" + componentNameDashCase + ".test.js",
        context
      );
    }

    // insert export of component into <package>.js (exists only in uu5-lib)
    if (packageFile) {
      await generateFile(null, packageFile, (content) => {
        if (content == null) content = "";
        let exportStr = `export * from "./${componentNameDashCase}.js";`;
        if (!content.includes(exportStr)) {
          content = [content.trimEnd(), exportStr, ""].join("\n");
        }
        return content;
      });
    }

    // add component to uuapp.json (for libraries)
    if (templateType === "uu5-lib" && register) {
      registerComponentToLibRegistry({
        code: context.tagName,
        name: componentNameCamelCase,
      });
    }
  }

  static generateDecorationComponent(name, packageName, pack) {
    // add component to uuapp.json
    let usedName = StringUtil.camelCase(name);
    let usedPackageName = [pack.get().namespace, StringUtil.camelCase(packageName)].filter(Boolean).join(".");
    let fullName = usedPackageName + "." + usedName;
    let { regexp, ...descriptorFields } =
      DECORATION_COMPONENTS.find((it) => it.regexp.test(usedName)) ||
      DECORATION_COMPONENTS.find((it) => it.regexp.test(fullName)) ||
      DECORATION_COMPONENTS[0];
    registerComponentToLibRegistry({
      code: fullName,
      uuEccReady: true,
      ...descriptorFields,
    });
  }
};

/**
 * Reads "destFile" if it exists (if it doesn't, reads "srcFile" & evaluates expressions against "context") and
 * performs string transformation using transformFn function and writes result back to destFile. Examples:
 *
 * @example generateFile("file.tpl", "dest/file.js", { param: "abc" });
 * @example generateFile("file.tpl", "dest/file.js", content => content.toUpperCase(), { param: "abc" });    // "content" contains data from dest/file.js (if it existed) or evaluated file.tpl (if it didn't)
 * @example generateFile(null, "dest/file.js", content => content.toUpperCase());
 */
async function generateFile(srcFile, destFile /*transformFn?, srcFileExprContext, overwrite=false*/) {
  let args = Array.prototype.slice.call(arguments, 2);
  let transformFn = typeof args[0] === "function" ? args.shift() : null;
  let srcFileExprContext = args.shift();
  let overwrite = args.shift();

  let exists = await fs.pathExists(destFile);
  let content, oldContent;
  if ((!exists && srcFile) || (exists && overwrite)) {
    let srcContent = await fs.readFile(srcFile, "utf-8");
    content = StringUtil.evalExpressions(srcContent, srcFileExprContext, srcFile);
  } else if (exists && transformFn) {
    content = await fs.readFile(destFile, "utf-8");
    oldContent = content;
  }
  if (transformFn) content = transformFn(content, srcFile, destFile);
  if (content != null && content !== oldContent) {
    if (destFile.match(/\.js$/)) content = await prettify(content, destFile);
    console.log(
      `  ${destFile}... ` + (exists && overwrite ? ` overwriting` : !exists && srcFile ? `creating` : `updating`)
    );
    await fs.mkdirp(path.dirname(destFile));
    await fs.writeFile(destFile, content, "utf-8");
  }
}

function registerComponentToLibRegistry(componentDesc) {
  let uuappJsonStr = fs.readFileSync("../uuapp.json", "utf-8");
  let uuappJson = JSON.parse(uuappJsonStr);
  let folderName = path.basename(path.resolve("."));
  let specificConfig = uuappJson[folderName] || {};
  if (!specificConfig.componentList) specificConfig.componentList = [];
  if (!specificConfig.componentList.some((it) => it.code === componentDesc.code)) {
    console.log(`  ../uuapp.json... updating`);
    let item = {
      name: StringUtil.camelCase(componentDesc.code),
      tagList: componentDesc.code.split("."),
      docCode: componentDesc.code.replace(/\./g, ""),
      desc: "",
      icon: "",
      imageUri: "",
      uuEccReady: false,
      template: `<${componentDesc.code} />`,
      ...componentDesc,
    };
    item = Package.sort(item, LIB_DESCRIPTOR_KEYS_ORDER);
    specificConfig.componentList.push(item);
    fs.writeFileSync("../uuapp.json", JSON.stringify(uuappJson, null, 2) + "\n", "utf-8");
  }
}

async function prettify(content, destFile) {
  try {
    let devkitDir = path.dirname(require.resolve("uu_appg01_devkit/package.json", { paths: ["."] }));
    let prettierOptions = await prettier.resolveConfig(destFile);
    let prettier = require(require.resolve("prettier", { paths: [devkitDir] }));
    return prettier.format(content, prettierOptions);
  } catch (e) {
    // best-effort basis only
    return content;
  }
}
