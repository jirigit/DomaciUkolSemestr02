const child_process = require("child_process");
const fs = require("fs");

class AbstractPackageManager {
  constructor(config) {
    this.config = config || {}; // { executable, genericArgs, forced }
    if (!this.config.executable) {
      throw new Error("PackageManager has no 'executable'! Should be e.g. 'npm', 'pnpm', ...");
    }
  }
  async install(options) {
    return this._execute(options.command || "install", options);
  }
  async update(options) {
    return this._execute(options.command || "update", options);
  }
  async uninstall(options) {
    return this._execute(options.command || "uninstall", options);
  }
  async _execute(command, { packages, save, saveDev, saveExact, args, logLevel, cwd, exitOnFailure }) {
    let { executable, genericArgs = [] } = this.config;

    let usedArgs = genericArgs.concat([command]).concat(Array.isArray(args) ? args : []);
    if (typeof save === "boolean") usedArgs.push(save ? "--save" : "--no-save");
    if (typeof saveDev === "boolean") usedArgs.push(saveDev ? "--save-dev" : "--no-save-dev");
    if (typeof saveExact === "boolean") usedArgs.push(saveExact ? "--save-exact" : "--no-save-exact");
    if (logLevel) usedArgs.push("--loglevel=" + logLevel);
    if (Array.isArray(packages)) usedArgs.push(...packages);

    let result = child_process.spawnSync(executable, usedArgs, {
      shell: true,
      cwd: cwd,
      stdio: "inherit",
    });
    if (result.status && exitOnFailure) process.exit(1);
    return result;
  }
  isForced() {
    return this.config.forced;
  }
}

class Npm extends AbstractPackageManager {
  constructor(config) {
    super({ executable: "npm", ...config });
  }
  async update({ inWholeWorkspace, ...options }) {
    if (inWholeWorkspace) {
      options.args || (options.args = []);
      options.args = options.args.concat(["--workspaces", "--include-workspace-root"]);
    }
    if (options.packages && options.packages.length > 0) {
      // npm actually needs to use `npm install` not `npm update` (`npm update pkg` cannot include pkg@version specifier)
      await this._execute("install", options);
      // have to still do the update afterwards (e.g. if we installed new uu_appg01_devkit then npm didn't update transitive
      // uu_appg01_devkit-common) => update all packages transitively according to their version specifiers in package.json
      return await this._execute("update", {
        save: false,
        args: inWholeWorkspace ? ["--workspaces", "--include-workspace-root"] : undefined,
      });
    } else {
      return await this._execute("update", options);
    }
  }
}

class Pnpm extends AbstractPackageManager {
  constructor(config) {
    super({ executable: "pnpm", ...config });
  }
  install(opts) {
    let command = Array.isArray((opts || {}).packages) && opts.packages.length > 0 ? "add" : "install";
    let usedOpts;
    if (command === "install") {
      let { packages, save, saveDev, saveExact, ...restOpts } = opts;
      usedOpts = restOpts;
    } else {
      usedOpts = { ...opts, args: ["--ignore-workspace-root-check"] };
    }
    usedOpts.command = command;
    return super.install(usedOpts);
  }
  update({ inWholeWorkspace, ...opts }) {
    if (inWholeWorkspace) {
      opts.args || (opts.args = []);
      opts.args = opts.args.concat("--recursive");
    }
    opts.command = "update";
    return super.update(opts);
  }
  uninstall(opts) {
    let usedOpts = { ...opts, command: "remove" };
    return super.uninstall(usedOpts);
  }
}

function initInstance() {
  let name;

  // figure out package manager from node_modules/ if it exists
  let isRoot = fs.existsSync("uuapp.json");
  if (fs.existsSync("node_modules/.pnpm") || (!isRoot && fs.existsSync("../node_modules/.pnpm"))) {
    name = "pnpm";
  } else if (fs.existsSync("node_modules") || (!isRoot && fs.existsSync("../node_modules"))) {
    name = "npm";
  }

  // use package manager as preferred by env variable
  let forced;
  if (!name) {
    let fallbackName = process.env.UU_APPG01_DEVKIT_PM;
    name = fallbackName;
    forced = true;
  }

  // try to use pnpm
  if (!name) {
    try {
      let pnpmResult = child_process.spawnSync("pnpm -v", { shell: true, cwd: process.cwd(), stdio: "pipe" });
      if (pnpmResult.status === 0 && pnpmResult.stdout.toString().trim() > "0") name = "pnpm";
    } catch (e) {
      // ignore and fallback to using npm
    }
  }
  let allowedValues = new Set(["npm", "pnpm"]);
  let packageManager = allowedValues.has(name) ? name : allowedValues.values().next().value || "npm";

  let result;
  switch (packageManager) {
    case "pnpm":
      result = new Pnpm({ forced });
      break;
    case "npm":
      result = new Npm({ forced });
      break;
    default:
      throw new Error(`Using package manager '${packageManager}' is not supported.`);
  }
  return result;
}

let instance;
class PackageManager {
  static getInstance() {
    if (!instance) instance = initInstance();
    return instance;
  }
  static async install({
    packages,
    save,
    saveDev,
    saveExact,
    logLevel = "error",
    cwd = process.cwd(),
    exitOnFailure = true,
  } = {}) {
    return PackageManager.getInstance().install({ packages, save, saveDev, saveExact, logLevel, cwd, exitOnFailure });
  }
  static async update({
    packages,
    logLevel = "error",
    cwd = process.cwd(),
    exitOnFailure = true,
    inWholeWorkspace = false,
  } = {}) {
    return PackageManager.getInstance().update({ packages, logLevel, cwd, exitOnFailure, inWholeWorkspace });
  }
  static async uninstall({ packages, logLevel = "error", cwd = process.cwd(), exitOnFailure = true } = {}) {
    return PackageManager.getInstance().uninstall({ packages, logLevel, cwd, exitOnFailure });
  }
}
PackageManager.Npm = Npm;
PackageManager.Pnpm = Pnpm;

module.exports = PackageManager;
