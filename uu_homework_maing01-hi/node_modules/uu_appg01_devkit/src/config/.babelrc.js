const fs = require("fs");
let Package;

function getOptions(mode = process.env.NODE_ENV || "development", processEnvToReplace = null) {
  if (!Package) Package = require("uu_appg01_devkit-common/src/tools/package.js");
  let pkg = Package.getSingletonSync("package.json").get();
  let pkgBabel = pkg["babel"];

  let presets = pkgBabel && pkgBabel.presets;
  if (!presets) {
    presets = [
      [
        require.resolve("@babel/preset-env"),
        {
          modules: mode === "test" ? "commonjs" : false, // NOTE Boolean true is not an allowed value...
          targets: {
            browsers: pkg["browserslist"] || fs.readFileSync(__dirname + "/.browserslistrc", "utf-8"),
          },
          bugfixes: true,
          // debug: true // shows which browser versions are targetted and which plugins are used (due to which browsers)
        },
      ],
    ];
    let isUu5g04 = pkg.name === "uu5g04";
    let useUu5JsxApi = !!((pkg.dependencies && pkg.dependencies.uu5g04) || isUu5g04);
    if (useUu5JsxApi) {
      // version of uu5g04 must be >= 1.19.0 to be able to use UU5 JSX API
      let uu5g04PkgPath = isUu5g04 ? null : require.resolve("uu5g04/package.json", { paths: ["."] });
      let uu5g04Version = isUu5g04 ? pkg.version : Package.getSingletonSync(uu5g04PkgPath).get().version || "1.19.0";
      let [major, minor] = uu5g04Version.split(".");
      major = Number(major);
      minor = Number(minor);
      useUu5JsxApi = major > 1 || (major === 1 && minor >= 19);
      if (!useUu5JsxApi && mode === "development") {
        console.warn(
          require("chalk").yellow("WARNING") +
            " You're using uu5g04 < 1.19.0 in your current node_modules/. It's recommended to upgrade to >= 1.19.0 to be able to simplify imports in your source code. Upgrade is also needed if you start getting 'React is not defined' errors which can happen if your team member already performed the imports simplification (and you have old uu5g04 installed locally). To upgrade: npm install uu5g04"
        );
      }
    }
    let isUu5g05 = pkg.name === "uu5g05";
    let useUu5g05JsxApi = !!((pkg.dependencies && pkg.dependencies.uu5g05) || isUu5g05);
    presets.push([
      require.resolve("@babel/preset-react"),
      useUu5g05JsxApi
        ? {
            pragma: "Uu5g05.Utils.Element.create", // default is "React.createElement"
            pragmaFrag: "Uu5g05.Fragment", // default is "React.Fragment"
          }
        : useUu5JsxApi
        ? {
            pragma: "UU5.Common.Element.create", // default is "React.createElement"
            pragmaFrag: "UU5.Common.Fragment", // default is "React.Fragment"
          }
        : {},
    ]);
  }

  let plugins = pkgBabel && pkgBabel.plugins;
  if (!plugins) {
    plugins = [
      [
        // this plugin redirects necessary transform helper fns to use @babel/runtime/helpers/xyz imports,
        // i.e. instead of e.g. inlining `function _iterableToArray(){...}` for each source file, it'll
        // add import e.g. `_iterableToArray = require("@babel/runtime/helpers/iterableToArray")` so that
        // the function body is bundled only once
        require.resolve("@babel/plugin-transform-runtime"),
        { version: "^7.20.7", regenerator: false }, // we have @babel/runtime >= 7.20.7
      ],
    ];
    if (mode === "test") {
      plugins.push(require.resolve("babel-plugin-transform-import-meta"));
    }
    if (processEnvToReplace && Object.keys(processEnvToReplace || {}).length > 0) {
      // NOTE :-( We have to actually set the values to the process.env in order for them
      // to be replaced by Babel.
      for (let k in processEnvToReplace) process.env[k] = processEnvToReplace[k];
      plugins.push([
        require.resolve("babel-plugin-transform-inline-environment-variables"),
        {
          include: Object.keys(processEnvToReplace),
        },
      ]);
    }
  }

  let result = {
    // required for @babel/plugin-transform-runtime so that when it injects new imports,
    // it'll use `import ... from` only if there already are some such imports
    // (otherwise falls back to commonjs require() calls)
    // NOTE Without this, if babel injected `import ... from` into a file which contained `module.exports = ...`
    // then the assignment would either throw error or simply not count as an export (and devkit creates & uses
    // such files).
    sourceType: "unambiguous",

    ...pkgBabel,

    presets,
    plugins,
  };
  if (pkgBabel) result = resolveBabelModules(result);
  return result;
}

function resolveBabelModules(babelConfig) {
  if (babelConfig.plugins) babelConfig.plugins = babelConfig.plugins.map((plugin) => resolveBabelPlugin(plugin));
  if (babelConfig.presets) babelConfig.presets = babelConfig.presets.map((preset) => resolveBabelPreset(preset));
  if (babelConfig.env)
    Object.keys(babelConfig.env).forEach((envName) => {
      babelConfig.env[envName] = resolveBabelModules(babelConfig.env[envName]);
    });
  return babelConfig;
}
function resolveBabelPreset(preset) {
  try {
    if (Array.isArray(preset))
      return [require.resolve(preset[0].replace(/^@babel\/(preset-)?/, "@babel/preset-"))].concat(preset.slice(1));
    return require.resolve(preset.replace(/^@babel\/(preset-)?/, "@babel/preset-"));
  } catch (e) {
    if (e.code === "MODULE_NOT_FOUND") return preset; // might be resolvable from project folder itself
    throw e;
  }
}
function resolveBabelPlugin(plugin) {
  try {
    if (Array.isArray(plugin))
      return [require.resolve(plugin[0].replace(/^@babel\/(plugin-)?/, "@babel/plugin-"))].concat(plugin.slice(1));
    return require.resolve(plugin.replace(/^@babel\/(plugin-)?/, "@babel/plugin-"));
  } catch (e) {
    if (e.code === "MODULE_NOT_FOUND") return plugin; // might be resolvable from project folder itself
    throw e;
  }
}

// NOTE This fn is used only by IDEs due to .eslintrc.js (uses @babel/eslint-parser). Devkit itself uses getOptions() above.
module.exports = function (api) {
  // https://babeljs.io/docs/en/config-files#apicache
  api.cache(true);
  return getOptions();
};
module.exports.getOptions = getOptions;
