const path = require("path");
const babelJest = require("babel-jest").default;

let transformerMapByCwd = {};
function getTransformer(libraryPath) {
  if (!libraryPath) libraryPath = "";
  let transformer = transformerMapByCwd[libraryPath];
  if (!transformer) {
    let pkg = libraryPath ? require(path.resolve(libraryPath, "package.json")) : undefined;
    let processEnv = require("./process-env.js")(pkg);
    let babelOptions = require("./.babelrc.js").getOptions(undefined, processEnv);
    transformer = babelJest.createTransformer(babelOptions);
  }
  return transformer;
}

let pathBase;
function forwardMethod(methodName) {
  return function (sourceText, sourcePath, options) {
    let { transformerConfig } = options || {};
    let { workspaceLibraries } = transformerConfig || {};
    let usedTransformer;
    if (workspaceLibraries) {
      if (!pathBase) pathBase = path.resolve("..");
      for (let libraryName of workspaceLibraries) {
        if (sourcePath.startsWith(pathBase + path.sep + libraryName + path.sep)) {
          usedTransformer = getTransformer(pathBase + path.sep + libraryName);
          break;
        }
      }
    }
    if (!usedTransformer) usedTransformer = currentProjectTransformer;
    return usedTransformer[methodName].apply(usedTransformer, arguments);
  };
}

const currentProjectTransformer = getTransformer();

// if workspace contains several libraries, we need separate transformer for them so that
// they have correct process.env.NAME, ... settings during transform
// NOTE We'll assume that workspace libraries use the same version of devkit.
// NOTE Jest 27.4.7+ has a bug where we cannot define multiple regexps in config "transform" keys with same transformer such as:
//   "[/\\\\]uu5g05-elements[/\\\\].+\\.(js|jsx|mjs)$": ["jest-babel-transform.js", { library: "uu5g05-elements" }],
//   "^.+\\.(js|jsx|mjs)$":                             ["jest-babel-transform.js", {}],
// because internally Jest uses transformerCache with key being the transformer path so afterwards all "transform" entries
// will use the last instantiated transformer (for that transformer path).
//   => use single transformer and decide whether to call the other-library-transformer during "process" method
let multiLibraryTransformer = {};
for (let [k, v] of Object.entries(currentProjectTransformer)) {
  multiLibraryTransformer[k] = typeof v === "function" ? v.bind(currentProjectTransformer) : v;
}
if (multiLibraryTransformer["process"]) multiLibraryTransformer["process"] = forwardMethod("process");
if (multiLibraryTransformer["processAsync"]) multiLibraryTransformer["processAsync"] = forwardMethod("processAsync");

module.exports = {
  createTransformer() {
    return multiLibraryTransformer;
  },
};
