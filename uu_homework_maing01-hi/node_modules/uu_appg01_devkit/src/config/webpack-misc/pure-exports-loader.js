const path = require("path");

let babel;
let Es6ExportsReader;

const MAGIC_COMMENT = "devkit-pure-exports";
const MAGIC_COMMENT_RE = new RegExp(String.raw`(^|\n)\s*(//[ \t]*${MAGIC_COMMENT}\b|/\*[ \t]*${MAGIC_COMMENT}\b)`);

module.exports = function (...args) {
  let callback = this.async();
  (async function () {
    let result;
    try {
      result = await normalFlow.apply(this, args);
      if (!result) result = [args[0], args[1]];
    } catch (e) {
      callback(e);
      return;
    }
    callback(null, ...result);
  }).call(this);
};

const exportsByFile = {};

async function normalFlow(content) {
  if (this.target !== "web" || typeof content !== "string") return;
  if (!content.match(MAGIC_COMMENT_RE)) return;

  // get exports from the file
  let { resource, query } = this; // `resource` is absolute path
  let { babelConfig, isDistributionBuild } = query;
  let exportsResult = exportsByFile[resource];
  if (!exportsResult) {
    // check that the file contains only export statements (and only those that are supported)
    if (!babel) babel = require("@babel/core");
    let ast = babel.parseSync(content, babelConfig);
    let rootStatements = (ast.program || {}).body || [];
    for (let node of rootStatements) {
      let isRecognized =
        node.type === "ExportAllDeclaration" ||
        (node.type === "ExportNamedDeclaration" &&
          !node.declaration &&
          (((node.specifiers || {})[0] || {}).exported || {}).name !== "default");
      if (!isRecognized) {
        this.emitWarning(
          new Error(
            `${require("chalk").yellow("WARN")} Skipping exports optimization (${MAGIC_COMMENT}) in ${
              this.resourcePath
            }` +
              ' - only `export ... from ...;` statements are allowed for the optimization, default exports are not allowed either. Separate more complex logic to e.g. extra-exports.js file and add `export * from "./extra-exports.js";` here.'
          )
        );
        return;
      }
    }

    if (!Es6ExportsReader) Es6ExportsReader = require("../../scripts/intellisense/es6-exports-reader.js");
    let exportsReader = new Es6ExportsReader(babelConfig, true);
    exportsResult = exportsReader.getExportsFromJs(content, this.context, {
      includeMeta: true,
    });

    // optimization for distribution build - consider files to be immutable, i.e. cache the result
    // so that it gets picked when building minified version / cjs versions of the same file
    if (isDistributionBuild) exportsByFile[resource] = exportsResult;
  }

  // rewrite exports
  let { exports, complete, missingSources, unrecognizedExportStatements } = exportsResult;
  let resultParts = [];
  let dependenciesP = [];
  resultParts.push(`module.exports = {`);
  for (let name in exports) {
    let { sourceName, sources } = exports[name];
    let source = sources[0];
    resultParts.push(`  get ${JSON.stringify(name)}() {
    return require(${JSON.stringify(source)})${sourceName ? `[${JSON.stringify(sourceName)}]` : ``};
  },`);
    // add watching of relevant files
    dependenciesP.push(
      (async () => {
        let dir = this.context;
        for (let source of sources) {
          let filePath = await resolveImportPath.call(this, dir, source);
          if (filePath) this.addDependency(filePath);
          else this.addContextDependency(path.dirname(path.resolve(dir, source)));
          dir = filePath.replace(/^(.*)[/\\].*/, "$1");
        }
      })().catch((e) => null)
    );
  }
  resultParts.push(`};\n`);
  let modContent = resultParts.join("\n");

  for (let dep of missingSources) this.addContextDependency(path.dirname(dep.source));
  await Promise.all(dependenciesP);

  // NOTE This must be done after "this.add*Dependency(...)" calls so that fixing code in a dependency file
  // would trigger our recompilation too.
  if (missingSources.length > 0) {
    throw new Error(
      `${missingSources[0].from || this.resourcePath}: import / export \`${
        missingSources[0].sourceName
      }\` does not exist.`
    );
  }
  if (!complete) {
    if (unrecognizedExportStatements?.length > 0) {
      this.emitWarning(
        new Error(
          `${require("chalk").yellow("WARN")} Skipping exports optimization (${MAGIC_COMMENT}) in ${
            this.resourcePath
          }` +
            " - some exports could not be discovered due to too advanced syntax. Try simplifying the export statements, e.g. by first declaring the variable and then simply exporting it using standalone `export { Variable };`, in:\n  " +
            unrecognizedExportStatements.map((it) => it.file + ":" + it.line + ":" + it.column).join("\n  ")
        )
      );
    } else {
      this.emitWarning(
        new Error(
          `${require("chalk").yellow("WARN")} Skipping exports optimization (${MAGIC_COMMENT}) in ${
            this.resourcePath
          }` + ' - some exports could not be discovered (are you using `export * from "3rd-party-library";`?).'
        )
      );
    }
    return;
  }

  // if (modContent) console.log(`PureExportsLoader - ${this.resourcePath} rewrote to:\n`, modContent);
  return [modContent];
}

function resolveImportPath(dir, importString) {
  return new Promise((resolve, reject) =>
    this.resolve(dir, importString, (err, filePath) => {
      if (err) resolve();
      else resolve(filePath);
    })
  );
}
