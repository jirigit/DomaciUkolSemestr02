const path = require("path");
const fs = require("fs-extra");
// const eslintFormatter = require("eslint/lib/formatters/stylish");

let CopyWebpackPlugin; // conditional load
let TerserWebpackPlugin; // conditional load
let CssMinimizerWebpackPlugin; // conditional load
let HtmlWebpackPlugin; // conditional load
let MiniCssExtractPlugin; // conditional load
let MessagePlugin; // conditional load
let StringUtil; // conditional load
let HtmlPostProcessorV1;
let HtmlPostProcessorV2;

const Package = require("uu_appg01_devkit-common/src/tools/package.js");
const SystemjsEs6DetectionFixPlugin = require("./webpack-misc/systemjs-es6-detection-fix-plugin.js");
const buildHelpers = require("../tools/helpers.js");
const paths = require("./paths.js");
const templateType = buildHelpers.getTemplateInfo().type;
let usedBundleNames = new Set();

module.exports = function () {
  let config = fs.existsSync("config/config.js") ? require(path.resolve("config/config.js")).getConfig() : {};
  return getFromConfig(config);
};
module.exports.getFromConfig = getFromConfig;
module.exports.writeAliases = writeAliases;

function getFromConfig(config, aEnv = null) {
  let env = Object.assign({}, aEnv);
  env = fillEnvDefaults(env);

  let packs = config.packs || [];
  packs = packs.filter(Boolean).map((pack) => {
    let packConfig = Object.assign({}, config, pack);
    delete packConfig.packs;
    return packConfig;
  });

  // auto-open webpack chunks analysis for 1st JS pack
  if (config.analyzeChunks && config.analyzeChunksAutoOpen == null && !env.isDevServer) {
    let jsPacks = packs.filter((pack) => !pack.outputFile || pack.outputFile.match(/\.js/));
    if (jsPacks.length > 0) jsPacks[0].analyzeChunksAutoOpen = true;
  }

  // for libraries, for each non-minified pack add another minified version when building distribution
  if (env.isDistributionBuild && templateType.endsWith("lib")) {
    let extraPacks = packs
      .filter((pack) => (pack.outputFile || "").match(/\.(js|css)$/) && pack.minify == null)
      .filter((pack) => !pack.outputFile.match(/\.min\.[^.]*$/))
      .map((pack) => {
        let outputFileMin = pack.outputFile.replace(/\.([^.]+)$/, ".min.$1");
        let packConfig = Object.assign({}, pack, { minify: true, outputFile: outputFileMin });
        if (config.analyzeChunks && config.analyzeChunksAutoOpen == null) {
          pack.analyzeChunksAutoOpen = false; // prefer opening of analysis of minified file
        }
        return packConfig;
      });
    packs = packs.concat(extraPacks);
  }

  // each "pack" in "config" must be built separately
  let webpackConfig = packs.reduce((result, pack) => {
    if (result.length === 0) pack.copyFiles = true; // use copy plugin only for 1st invocation so that it isn't invoked for each built JS file
    let packWebpackConfig = getWebpackConfig(pack, env);
    return result.concat(packWebpackConfig);
  }, []);

  // add on-demand loadable "project packages" to the build
  let projectPackages = config.projectPackages;
  if (projectPackages) {
    webpackConfig = projectPackages.reduce(
      (result, pack) =>
        result.concat(
          getWebpackConfig(
            Object.assign({}, config, {
              outputFile: pack.name + "/" + pack.name + (env.isDistributionBuild ? ".min" : "") + ".js",
              entryPoints: [pack.entryPoint],
            }),
            env
          )
        ),
      webpackConfig
    );
  }

  return webpackConfig;
}

function fillDefaults(opts, env) {
  if (opts.minify == null) opts.minify = opts.outputFile && opts.outputFile.match(/\.min\./);
  if (opts.useSourceMaps == null) opts.useSourceMaps = !env.isDistributionBuild;
  if (opts.separateCss == null) opts.separateCss = opts.outputFile && opts.outputFile.match(/\.css$/);
  if (opts.sourcePath == null) opts.sourcePath = paths.srcDir;
  if (opts.outputPath == null) opts.outputPath = path.join(paths.buildDir, "dist");
  if (opts.entryPoints == null) opts.entryPoints = [];
  if (opts.https == null) opts.https = false;
  if (opts.copyFiles == null) opts.copyFiles = false;
  if (opts.includeDemoPages == null) opts.includeDemoPages = !env.isDistributionBuild;
  if (opts.appAssetsRelativeUrlPath == null) opts.appAssetsRelativeUrlPath = "";
  if (opts.appBaseUrlPath == null) opts.appBaseUrlPath = "";
  if (opts.externals == null) opts.externals = {};
  if (opts.transpileDependencies == null) opts.transpileDependencies = false;
  if (opts.targetEnvironment == null) {
    // "web" (default), "webworker"; https://webpack.js.org/configuration/target/
    opts.targetEnvironment =
      opts.entryPoints.length === 1 && opts.entryPoints[0].match(/-worker\.js$/) ? "webworker" : "web";
  }
  return opts;
}
function fillEnvDefaults(env = {}) {
  if (env.isDistributionBuild == null) env.isDistributionBuild = true;
  if (env.isDevServer == null) env.isDevServer = false;
  if (env.sameProductFrontendLibs == null) env.sameProductFrontendLibs = [];
  return env;
}

function getWebpackConfig(options, env) {
  let opts = Object.assign({}, options);
  opts = fillDefaults(opts, env);
  let pkg = Package.getSingletonSync("package.json").get();

  if (opts.entryPoints === "<from-mappings-json>") {
    opts.entryPoints = getHtmlFilesToProcess(opts.mappings, opts.sourcePath)
      .map((html) => html.replace(/\.html?$/i, ".js"))
      .filter((jsFile) => fs.existsSync(path.join(opts.sourcePath, jsFile)));
  }
  if (opts.entryPoints.length == 0) {
    throw new Error("At least 1 entry point must be specified in the configuration (config/config.js).");
  }
  fs.mkdirsSync(opts.outputPath);
  let outputAbsPath = path.resolve(opts.outputPath);

  let { targetEnvironment } = opts;
  let { mode, hot, reactHot, srcAbsPath } = getBasicSettings(opts, env, pkg);
  let src = path.relative(path.resolve("."), srcAbsPath).replace(/\\/g, "/");
  let optimization = {};

  let configName = (opts.outputFile || opts.entryPoints[0]).replace(/[^\w._-]/g, "_");
  let i = 0;
  while (usedBundleNames.has(configName)) configName = "bundle" + i++;
  usedBundleNames.add(configName);

  let processEnv = require("./process-env.js")(
    pkg,
    opts.minify ? "production" : "development",
    "browser",
    opts.outputFile,
    opts.libraryGlobalVariable
  );

  // CONFIG webpack rules
  const webpack = require("webpack");
  // let eslintLoader = {
  //   loader: require.resolve("eslint-loader"),
  //   options: {
  //     formatter: function() {
  //       // omit summary "<number> problems" displayed after each file
  //       return eslintFormatter
  //         .apply(this, arguments)
  //         .split(/\n\n/)
  //         .slice(0, -1)
  //         .join("\n\n")
  //         .trim();
  //     },
  //     eslintPath: require.resolve("eslint")
  //   }
  // };
  let babelConfig = require("./.babelrc.js").getOptions(mode, null);
  let babelLoaderOptions = Object.assign({}, babelConfig, {
    babelrc: false,
    cacheDirectory: true,
  });
  if (reactHot) {
    if (!babelLoaderOptions.plugins) babelLoaderOptions.plugins = [];
    babelLoaderOptions.plugins.push(require.resolve("react-hot-loader/babel"));
  }
  let babelLoader = {
    loader: require.resolve("babel-loader"),
    options: babelLoaderOptions,
  };
  let cssRule, lessRule;
  let cssDataOwner =
    pkg.name + "/" + ((opts.outputFile || "").replace(/(\.min)?\.(js|css)$/, "") || pkg.name) + "@" + pkg.version; // NOTE Should be in sync with how we generate config.js in uu5-app.
  let cssEmotionKey = (opts.libraryGlobalVariable || pkg.namespace || pkg.name)
    .replace(/\./g, "-")
    .toLowerCase()
    .replace(/[^a-z-]/g, "");
  let styleLoader = {
    loader: require.resolve("style-loader"),
    options: {
      insert: getStyleLoaderInsertInto(cssDataOwner, cssEmotionKey, srcAbsPath, configName),
      // singleton: !!opts.minify, // !!! DON'T USE (1400ms singleton vs. 60ms separate in uu5g04-bricks@1.21.0).
    },
  };
  let pureExportsLoader = {
    loader: require.resolve("./webpack-misc/pure-exports-loader.js"),
    options: { babelConfig, isDistributionBuild: env.isDistributionBuild },
  };
  let decorationComponentLoader = { loader: require.resolve("./webpack-misc/decoration-component-loader.js") };
  let cssLoader = {
    loader: require.resolve("css-loader"),
    options: {
      url: {
        filter: (url, resourcePath) => {
          // keep url(data:...) expressions as-is (otherwise there is a bug where where css-loader emits the URI as an asset
          // and therefore webpack tries to emit file with such name to FS and fails)
          if (url && url.match(/^(data:|https?:)/)) return false;
          return true;
        },
      },
    },
  };
  let postCssPlugins = [require("autoprefixer")()];
  if (opts.minify) postCssPlugins.push(require("cssnano")({ preset: "default" }));
  let postCssLoader = {
    loader: require.resolve("postcss-loader"),
    options: { postcssOptions: { plugins: postCssPlugins } },
  };
  let lessLoader = {
    loader: require.resolve("less-loader"),
    options: {
      lessOptions: {
        globalVars: Object.keys(processEnv).reduce((r, k) => ((r[k] = JSON.stringify(processEnv[k])), r), {}),
      },
    },
  };
  let rules = [
    {
      oneOf: [
        // use only first matched
        {
          test: /\.(jsx?|mjs)$/,
          exclude: opts.transpileDependencies ? undefined : /node_modules/,
          use: [babelLoader, pureExportsLoader /*, eslintLoader*/].concat(
            opts.copyFiles ? [decorationComponentLoader] : []
          ),
          parser: { import: true, system: false },
        },
        (cssRule = { test: /\.css$/, use: [styleLoader, cssLoader, postCssLoader] }),
        (lessRule = { test: /\.less$/, use: [styleLoader, cssLoader, postCssLoader, lessLoader] }),
        // if import-ing anything else just copy it and return its URL
        // - "html" and ^$ is excluded too so that HtmlWebpackPlugin works correctly
        { exclude: /\.(jsx?|mjs|json|html)$|^$/, type: "asset/resource" },
      ],
    },
  ];
  if (opts.separateCss && !MiniCssExtractPlugin) MiniCssExtractPlugin = require("mini-css-extract-plugin");
  let cssOutputFile;
  let extractCss = opts.separateCss
    ? new MiniCssExtractPlugin({
        filename: (cssOutputFile = ((opts.outputFile || "").replace(/\.(js|css)$/, "") || "[name]") + ".css"),
      })
    : null;
  let cssMinimizer = null;
  if (extractCss) {
    let miniCssExtractPluginLoader = {
      loader: MiniCssExtractPlugin.loader,
      options: {
        publicPath: (resourcePath, context) => {
          // public path of the library from the point of view of cssOutputFile (e.g. <cdnLibRoot>/assets/font.min.css -> <cdnLibRoot>/, so here it would be "../")
          let builtRelPath = path
            .relative(path.dirname(path.resolve(outputAbsPath, cssOutputFile)), outputAbsPath)
            .replace(/\\/g, "/");
          return builtRelPath ? builtRelPath + "/" : "";
        },
      },
    };
    cssRule.use.splice(0, 1, miniCssExtractPluginLoader);
    lessRule.use.splice(0, 1, miniCssExtractPluginLoader);
    // https://github.com/webpack-contrib/mini-css-extract-plugin#extracting-all-css-in-a-single-file
    Object.assign(optimization, {
      splitChunks: {
        cacheGroups: {
          styles: {
            name: "styles",
            type: "css/mini-extract",
            chunks: "all",
            enforce: true,
          },
        },
      },
    });
    if (opts.minify) {
      if (!CssMinimizerWebpackPlugin) CssMinimizerWebpackPlugin = require("css-minimizer-webpack-plugin");
      cssMinimizer = new CssMinimizerWebpackPlugin({});
    }
  }

  // CONFIG webpack plugins
  let processEnvStrMap = {};
  for (let k in processEnv) {
    if (!opts.minify && k === "NODE_ENV") {
      processEnvStrMap[
        k
      ] = `(typeof process !== "undefined" && process.env && (process.env.NODE_ENV) || "development")`;
      optimization.nodeEnv = false;
    } else {
      processEnvStrMap[k] = JSON.stringify(processEnv[k]);
    }
  }
  let plugins = [
    new webpack.DefinePlugin({
      "process.env": processEnvStrMap,
      "import.meta.url":
        // NOTE Using "__webpack_require__('module')?.uri" doesn't work when minified because 'module' should
        // be replaced by moduleId (number) but it doesn't get replaced...
        "(__webpack_require__.p + " + JSON.stringify(opts.outputFile || "") + ")",
    }),
  ];

  // uu5-app
  // process HTML files via EmbeddedJS templating system (updates <base> tag depending on whether we're using Ruby server)
  if (opts.copyFiles) {
    let htmlPostProcessedFiles = getHtmlFilesToProcess(opts.mappings, opts.sourcePath).filter((name) =>
      fs.existsSync(path.join(src, name))
    );
    let processorV1;
    let processorV2;
    htmlPostProcessedFiles.forEach(function (htmlFile) {
      if (!HtmlWebpackPlugin) HtmlWebpackPlugin = require("html-webpack-plugin");
      if (!processorV1) {
        if (!HtmlPostProcessorV1) HtmlPostProcessorV1 = require("./webpack-misc/html-post-processor-v1");
        if (!HtmlPostProcessorV2) HtmlPostProcessorV2 = require("./webpack-misc/html-post-processor-v2");

        let { appBaseUrlPath, appAssetsRelativeUrlPath } = opts;
        let preserveSegmentsMatch = (appBaseUrlPath || "").match(/^<preserve-(\d+)-path-segments?>$/);
        processorV1 = new HtmlPostProcessorV1({
          appBaseUrlPath,
          appAssetsRelativeUrlPath,
          externals: opts.externals || {},
          preserveSegments: preserveSegmentsMatch ? Number(preserveSegmentsMatch[1]) : undefined,
          isCdnDisabled: env.isCdnDisabled,
          isCdnExactVersions: env.isCdnExactVersions,
        });
        processorV2 = new HtmlPostProcessorV2({
          appAssetsRelativeUrlPath,
          externals: opts.externals || {},
          isCdnDisabled: env.isCdnDisabled,
          isCdnExactVersions: env.isCdnExactVersions,
        });
      }
      let pluginOpts = {
        template: "!!" + require.resolve("ejs-loader") + "?esModule=false!" + src + "/" + htmlFile,
        renderTemplate: (fileName, context) => renderTemplate(src + "/" + htmlFile, fileName, context),
        inject: false,
        minify: {
          removeComments: true,
          minifyJS: function (text) {
            // when performing Uu5Loader.import("./file.js") in HTML files, the path is relative to HTML file within src/ folder,
            // but we must replace such path to be relative to our href in <base href="...">, i.e. add the subfolder chain within src/,
            // upto the file (src/abc/cde/index.html, using "./index.js" => change into "./abc/cde/index.js")
            return text.replace(/((?:System(?:JS)?|Uu5Loader)\.import\s*\(\s*['"])([^'"]*)/g, function (m, g1, url) {
              if (url.charAt(0) === ".")
                url = ["."].concat(htmlFile.split(/[\\/]/).slice(0, -1)).join("/") + "/" + url.replace(/^\.\//, "");
              return g1 + url;
            });
          },
        },
      };
      let data1 = {}; // :-(
      plugins.push(
        new HtmlWebpackPlugin({
          ...pluginOpts,
          templateParameters: getHtmlTemplateParametersFn(data1),
          filename: htmlFile,
          ejsFixUrls: (htmlSnippet) =>
            // TODO Generate depCache also when developing, i.e. add watching of index.js (htmlFile.js) for changes.
            processorV1.processHead(htmlSnippet, {
              file: htmlFile,
              assets: data1.compilation.assets,
              depCache: !env.isDevServer,
            }),
        })
      );
      let data2 = {}; // :-(
      plugins.push(
        new HtmlWebpackPlugin({
          ...pluginOpts,
          templateParameters: getHtmlTemplateParametersFn(data2),
          filename: htmlFile.replace(/(\.html?)$/, "_v2$1"),
          ejsFixUrls: (htmlSnippet) =>
            // TODO Generate depCache also when developing, i.e. add watching of index.js (htmlFile.js) for changes.
            processorV2.processHead(htmlSnippet, {
              file: htmlFile,
              assets: data2.compilation.assets,
              depCache: !env.isDevServer,
            }),
        })
      );
    });

    // copy unrecognized files as-is ("from" path is relative to webpack's context, i.e. srcAbsPath)
    // TODO Next major - maybe don't auto-copy anything (except assets/).
    if (!CopyWebpackPlugin) CopyWebpackPlugin = require("copy-webpack-plugin");
    let copyOpts = {
      noErrorOnMissing: true,
      info: { minimized: true }, // otherwise Terser would try to minify contained *.js files
    };
    let cwpSettings = [
      {
        from: "**/*",
        globOptions: {
          ignore: [
            "**/*.js",
            "**/*.jsx",
            "**/*.json",
            "**/*.css",
            "**/*.less",
            "**/demo/**",
            "assets/**",
            "**/test/**",
            "**/__snapshots__/**",
          ].concat(htmlPostProcessedFiles.map((it) => path.resolve(srcAbsPath, it).replace(/\\/g, "/"))),
        },
        ...copyOpts,
      },
      {
        // allow minimizing of *.json files
        from: "**/*.json",
        globOptions: { ignore: ["**/demo/**", "assets/**", "**/test/**", "**/__snapshots__/**"] },
        noErrorOnMissing: true,
        transform: opts.minify
          ? (contents, filePath) => {
              try {
                return JSON.stringify(JSON.parse(contents));
              } catch (e) {
                return contents;
              }
            }
          : undefined,
      },
      { from: "assets/**", ...copyOpts }, // copy assets/ folder as-is (including any .less, ..., files)
    ];
    if (opts.includeDemoPages) {
      cwpSettings.push({ from: "**/demo/**", ...copyOpts });
      cwpSettings.push({ context: path.resolve("."), from: "demo/**", ...copyOpts });
    }
    if (templateType === "uu5-app" || (opts.includeDemoPages && templateType === "uu5-lib")) {
      // copy OIDC callbacks but don't overwrite if they already exist (e.g. build of uu5-app modifies
      // them in some cases)
      if (!fs.existsSync(path.join(outputAbsPath, "callbacks"))) {
        let uuAppOidcDir = getUuAppOidcPath(pkg);
        if (uuAppOidcDir) {
          cwpSettings.push({
            context: path.join(uuAppOidcDir, "src", "controllers"),
            from: "callback.html",
            to: "callbacks/oidc-callback.html",
            ...copyOpts,
          });
        }
      }
    }
    if (!env.isDistributionBuild) {
      cwpSettings.push({ context: path.resolve("."), from: "mock/**", ...copyOpts });
    }
    plugins.push(new CopyWebpackPlugin({ patterns: cwpSettings }));
  }

  // add copyright
  let licenseText;
  let bannerFn;
  plugins.push(
    new webpack.BannerPlugin({
      banner: (info) => {
        // { filename, hash, chunk }
        if (licenseText === undefined) {
          if (fs.existsSync("LICENSE")) licenseText = fs.readFileSync("LICENSE", "utf-8").trim();
          else if (fs.existsSync("../LICENSE")) licenseText = fs.readFileSync("../LICENSE", "utf-8").trim();
          else licenseText = "";
          if (!licenseText.includes("\n")) licenseText = `/*! ${licenseText.replace(/\*\//g, "* /")} */`;
          else licenseText = `/*!\n * ${licenseText.replace(/\*\//g, "* /").split("\n").join("\n * ")}\n */`;
        }
        if (opts.banner) {
          if (bannerFn === undefined) {
            try {
              bannerFn = fs.existsSync(opts.banner) ? require(path.resolve(opts.banner)) : null;
            } catch (e) {
              console.error("Failed to load banner file - it must be a JavaScript file exporting function.", e);
            }
            if (typeof bannerFn !== "function") bannerFn = null;
          }
        }
        return bannerFn ? bannerFn(info, licenseText) : licenseText;
      },
      raw: true,
      test: /\.js$/,
    })
  );

  // extract CSS & minify
  if (extractCss) plugins.push(extractCss);
  if (opts.minify) {
    if (!TerserWebpackPlugin) TerserWebpackPlugin = require("terser-webpack-plugin");
    optimization.minimizer = [
      new TerserWebpackPlugin({
        parallel: true,
        extractComments: false, // don't extract license comments into file.js.LICENSE.txt
        terserOptions: {
          output: {
            max_line_len: 200,
          },
        },
      }),
    ];
    if (cssMinimizer) optimization.minimizer.push(cssMinimizer);
  }

  // add detection of circular dependencies
  const CircularDependencyPlugin = require("circular-dependency-plugin");
  plugins.push(
    new CircularDependencyPlugin({
      exclude: /node_modules/,
      failOnError: false,
    })
  );

  // fix emitted JS files so that SystemJS loader doesn't mis-detect their format as ES6
  // (for libraries that get loaded using old SystemJS@0.19.47)
  plugins.push(new SystemjsEs6DetectionFixPlugin());

  // enable hot module replacement
  // NOTE react-hot-loader@4.x doesn't work with createReactClass (and won't be fixed)
  // https://github.com/gaearon/react-hot-loader/issues/831 => we're using latest @3.x.
  if (hot) {
    plugins.push(new webpack.HotModuleReplacementPlugin());
  }

  // set various optimization flags
  if (env.isDevServer && !env.isDistributionBuild) optimization.moduleIds = "named";
  optimization.concatenateModules = mode === "production";
  optimization.emitOnErrors = !env.isDistributionBuild;
  optimization.minimize = mode === "production";

  // configure splitting into chunks via import() function
  // https://webpack.js.org/plugins/split-chunks-plugin/
  if (opts.codeSplitting !== false && (!opts.outputFile || !opts.outputFile.match(/\.css$/))) {
    if (!optimization.splitChunks) optimization.splitChunks = {};
    optimization.splitChunks = {
      ...optimization.splitChunks,

      // chunk will be created whenever:
      //   a) it's due to import() call - note that these chunks are not going to be merged together
      //      (i.e. if we have import() for 3 different files, there will be *at least* 3 chunks)
      //   b) sum of sizes in an async chunk crosses maxAsyncSize => split such big async chunk into smaller ones
      //   c) under no other circumstances => use minChunks=bigNumber
      // NOTE A module can end up being duplicated in several chunks, but only 1 of these copies gets ever executed.
      // NOTE Not in a cache group, because it behaved differently for unknown reason.
      // TODO Having each import() split off to separate chunks seems wasteful - maybe create plugin like we had with
      // webpack 4 (to merge these until maxAsyncSize is met).
      hidePathInfo: true,
      chunks: "async",
      maxAsyncSize: 150000, // source size, unminified
      enforceSizeThreshold: 150000,
      minSize: 150000, // minSize+minRemainingSize needed to override defaults so that they don't collide with maxAsyncSize
      minRemainingSize: 0,
      maxAsyncRequests: 1,
      minChunks: 10000,
      usedExports: false,

      cacheGroups: {
        ...optimization.splitChunks.cacheGroups,
        defaultVendors: false, // don't create extra cache group for modules from node_modules/ (reason in webpack's doc about caching doesn't apply for us - our libs / app cache themselves by having version in URL)
      },
    };
    if (opts.analyzeChunks) {
      // https://github.com/webpack-contrib/webpack-bundle-analyzer
      const { BundleAnalyzerPlugin } = require("webpack-bundle-analyzer");
      if (!MessagePlugin) MessagePlugin = require("./webpack-misc/message-plugin.js");
      let reportFileName = path.resolve(
        paths.buildDir,
        "webpack-chunks-" + configName.replace(/[^a-zA-Z0-9\-_]/g, "_") + ".html"
      );
      plugins.push(
        new BundleAnalyzerPlugin({
          analyzerMode: "static",
          reportFilename: reportFileName,
          openAnalyzer: opts.analyzeChunksAutoOpen == null ? false : opts.analyzeChunksAutoOpen,
          statsOptions: {
            excludeModules: /[\\/](react-hot-loader|css-loader|style-loader|webpack-tmp|uu_appg01_devkit)[\\/]/,
          },
          generateStatsFile: true,
          statsFilename: path.resolve(
            paths.buildDir,
            "webpack-stats-" + configName.replace(/[^a-zA-Z0-9\-_]/g, "_") + ".json"
          ),
          logLevel: "warn",
        }),
        new MessagePlugin({
          message: "Webpack chunks report has been written to: " + reportFileName,
        })
      );
    }
  }

  // configuration of dependencies
  let externalsConfig = opts.externals || {};
  externalsConfig["module"] = { baseUri: true, format: "global", exports: "undefined" }; // force external (shimmed to be undefined if loading directly via <script> tag)
  externalsConfig["react/jsx-runtime"] = false;
  let hotLoaderReactCommonFile = "hot-loader-react-common.js";
  let hotLoaderReactDomFile = "hot-loader-react-dom.js";
  let hotLoaderReactHotLoaderFile = "hot-loader-react-hot-loader.js";
  if (reactHot) {
    // NOTE How React hot loading works in react-hot-loader@4.x:
    // 1. react-dom must be patched - this is done by using react-hot-loader/webpack loader on a react-dom package
    // 2. Hence react-dom must be redirected to our patched version when in browser.
    // 3. Lazy components seem to work only if react-hot-loader is in page in single chunk / single something,
    //    therefore we build it together when patching react-dom:
    //     - hot-loader-react-common.js - exports patched ReactDOM & react-hot-loader
    //     - hot-loader-react-dom.js - imports hot-loader-react-common, re-exports patched ReactDOM
    //     - hot-loader-react-hot-loader.js - imports hot-loader-react-common, re-exports react-hot-loader (app uses this file when Uu5Loader loads "react-hot-loader")
    //     + app (Uu5Loader) is configured to load "react-dom" from hot-loader-react-dom.js, getting patched ReactDOM (any external libraries of app will get already patched version of ReactDOM too)
    //     + app uses react-hot-loader (in index.js) as an external dependency and loads it from hot-loader-react-hot-loader.js, and therefore it's singleton even if there are more chunks in page
    // 4. Lazy components seem to work only with older API, i.e. using AppContainer directly.
    externalsConfig["hot-loader-react-common"] = { baseUri: "./", main: hotLoaderReactCommonFile };
    externalsConfig["react-dom"] = { baseUri: "./", main: hotLoaderReactDomFile };
    externalsConfig["react-hot-loader"] = { baseUri: "./", main: hotLoaderReactHotLoaderFile };
  }

  let submodules = {};
  if (templateType === "uu5-lib") {
    ((pkg.uuBuildSettings || {}).packs || []).forEach((pack) => {
      if (!(pack.outputFile || "").match(/\.js$/)) return;
      let name = pack.outputFile
        .split(/[/\\]/)
        .pop()
        .replace(/(\.min)?\.js$/, "");
      if (name.startsWith(pkg.name + "-")) submodules[name] = true;
    });
  }

  // aliases for resolving modules
  let aliasesResult = computeAliases(opts, env, pkg);
  let aliases = aliasesResult.aliases;
  plugins.push(...aliasesResult.plugins);

  // routing support - prepare proper <base> element snippet
  if (opts.appBaseUrlPath && !opts.appBaseUrlPath.match(/^</)) {
    // it's not a special value
    opts.appBaseUrlPath = opts.appBaseUrlPath.replace(/\/*$/, "/"); // make sure it ends with "/"
  }
  if (opts.appAssetsRelativeUrlPath) {
    if (opts.appAssetsRelativeUrlPath.match(/^\//))
      throw new Error(
        "Configuration option appAssetsRelativeUrlPath must be relative URL path (must not start with slash)."
      );
    opts.appAssetsRelativeUrlPath = opts.appAssetsRelativeUrlPath.replace(/\/*$/, "/").replace(/^\.\//, ""); // make sure it ends with "/" and doesn't start with "./"
  }

  // add automatic version checks when bootstrapping library in browser which depends on another library from the same multilib Git
  // (e.g. if building uu5g05-elements which imports uu5g05 then it is expected that both will be from the same version in browser)
  // realization:
  // 1. imports for relevant libraries, e.g. "uu5g05" are remapped to locally created uu5g05-version-check.js files
  //    (this is done by using webpacks externals config to consider it as non-external and then using NormalModuleReplacementPlugin).
  // 2. The remapped file contains version check and exports the same stuff as the original library
  //    (this is done by importing "<name>--version-check" which is in webpacks externals mapped back to original name
  //    but now as external).
  let versionCheckModuleMap = {};
  let sameProductFrontendLibsInDeps = env.sameProductFrontendLibs.filter(
    (libName) => libName in (pkg.dependencies || {}) || libName in (pkg.devDependencies || {})
  );
  let sameVersionLibs = sameProductFrontendLibsInDeps.concat(Object.keys(submodules));
  let externalSameVersionLibs = sameVersionLibs.filter((it) => externalsConfig[it] !== false);
  if (targetEnvironment === "web" && externalSameVersionLibs.length > 0) {
    externalSameVersionLibs = [...new Set(externalSameVersionLibs)];
    let versionCheckContent = fs.readFileSync(require.resolve("./webpack-misc/version-check-template.ejs"), "utf-8");
    versionCheckContent = versionCheckContent.replace(/<%=\s*WORKSPACE_LIBS\s*%>/g, () =>
      JSON.stringify(externalSameVersionLibs)
    );
    let versionCheckPath = createTemporaryModuleFile(versionCheckContent, "_version-check-template.js");
    let versionCheckRelPath = "./" + path.relative(paths.buildWebpackTempDir, versionCheckPath).replace(/\\/g, "/");
    let productLibWithCheckPathMap = {};
    for (let name of externalSameVersionLibs) {
      versionCheckModuleMap[name] = true;
      versionCheckModuleMap[name + "--version-check"] = name;

      // condition `ex?.name === ...` is required for handling uu5g05-elements-gds which can be
      // redirected via UU5.Environment.gdsUri to entirely different library (e.g. uu_gdsg01-unicorn)
      let content = `var ex = require(${JSON.stringify(name + "--version-check")});
var versionCheck = require(${JSON.stringify(versionCheckRelPath)});
if (ex && ex.name === ${JSON.stringify(name)}) versionCheck(ex.name, ex.version);
module.exports = ex;
`;
      productLibWithCheckPathMap[name] = createTemporaryModuleFile(content, name + "-with-version-check.js");
    }
    if (!StringUtil) StringUtil = require("uu_appg01_devkit-common/src/tools/string-util.js");
    let watchedImportsRegExp = new RegExp(
      `^(${externalSameVersionLibs.map((it) => StringUtil.regexpQuote(it)).join("|")})$`
    );
    let getProductLibWithCheckPath = (name, curDir) => {
      let redirPath = productLibWithCheckPathMap[name];
      return "./" + path.relative(curDir, redirPath).replace(/\\/g, "/");
    };
    plugins.push(
      new webpack.NormalModuleReplacementPlugin(watchedImportsRegExp, (resource) => {
        let issuer = (resource.contextInfo || {}).issuer;
        if (typeof issuer === "string" && !issuer.endsWith("-with-version-check.js")) {
          let newRequest = getProductLibWithCheckPath(resource.request, resource.context).replace(/^\.\/\.\.\//, "../");
          let origRequest = resource.request;
          resource.request = newRequest;
          (resource.dependencies || []).forEach((depInfo) => {
            if (depInfo && depInfo.request === origRequest) depInfo.request = newRequest;
          });
        }
      })
    );
  }

  // configure output verbosity - https://webpack.js.org/configuration/stats/
  let stats = {
    modules: false,
    moduleTrace: false,
    colors: true,
    hash: false,
    version: false,
  };

  // prepare webpack configuration
  let webpackConfig = [];

  // convert entry files from entryPoints to webpack configuration (we'll need to generate different entry file
  // for each of these as a workaround because we need to set publicPath during runtime, not during compile time
  // which is not as straightforward with webpack - https://github.com/webpack/webpack/issues/2776)
  let entryList = opts.outputFile ? [{ files: opts.entryPoints }] : opts.entryPoints.map((it) => ({ files: [it] })); // if outputFile is given, assume all entries are to be bundled there; otherwise make separate output for each entry
  let entryMap = entryList.reduce((result, entry, idx) => {
    let initialFile = "./" + path.relative(srcAbsPath, path.resolve(srcAbsPath, entry.files[0])).replace(/\\/g, "/"); // "./entry/index.js"
    let name = initialFile.substr(2).replace(/\.(js|css|less)$/, ""); // "entry/index"
    let isCssOnly = !entry.files.some((filePath) => !filePath.match(/\.(css|less|sass)$/));

    // make sure that the target name was not used yet
    if (result[name]) {
      let i = 0;
      while (result[name + "-" + i]) ++i;
      name += "-" + i;
    }

    let files;
    let dynamicPublicPath = true;
    if (!isCssOnly) {
      files = entry.files.map((filePath) =>
        createEntryPointFile(
          "./" + path.relative(srcAbsPath, path.resolve(srcAbsPath, filePath)).replace(/\\/g, "/"),
          opts,
          pkg.version
        )
      );
    } else {
      dynamicPublicPath = false;
      files = [
        createTemporaryModuleFile(
          entry.files
            .map(
              (filePath) =>
                `require(${JSON.stringify(
                  "./" +
                    path
                      .relative(path.resolve(paths.buildWebpackTempDir), path.resolve(srcAbsPath, filePath))
                      .replace(/\\/g, "/")
                )});`
            )
            .join("\n")
        ),
      ];
    }
    if (hot && !isCssOnly) {
      let isFirstHot = opts.copyFiles && idx === 0; // :-/ copyFiles flag also indicates that this is 1st (main) config
      files.unshift(
        require.resolve("webpack-hot-middleware/client") +
          getHotClientOptions(configName, opts, dynamicPublicPath, !isFirstHot)
      );
    }
    if (templateType === "uu5-app" && !isCssOnly && mode === "development") {
      if (externalsConfig["uu5g05"] && externalsConfig["uu_appg01_core"]) {
        files.unshift(require.resolve("./webpack-misc/uu-app-client-override.js"));
      }
    }
    result[name] = files;
    return result;
  }, {});

  let resolveLoaderModules = ["node_modules"];
  if (fs.existsSync("node_modules/uu_appg01_devkit")) {
    let devkitModulesPath = path.resolve(fs.realpathSync("node_modules/uu_appg01_devkit"), "node_modules");
    if (fs.existsSync(devkitModulesPath)) resolveLoaderModules.push(devkitModulesPath);
    let projectModulesPath = path.resolve("node_modules");
    let devkitPnpmModulesPath = path.resolve(fs.realpathSync("node_modules/uu_appg01_devkit"), "..");
    if (devkitPnpmModulesPath !== projectModulesPath && devkitPnpmModulesPath !== devkitModulesPath) {
      resolveLoaderModules.push(devkitPnpmModulesPath);
    }
  }
  let webpackOutputFileName =
    opts.outputFile && opts.outputFile.match(/\.(css|less)$/)
      ? path.join(
          path.relative(outputAbsPath, paths.buildWebpackTempDir),
          "__ignored",
          Math.random().toString(36).slice(2)
        )
      : opts.outputFile || "[name].js"; // for CSS we cannot emit directly into outputFile because it'll be emitted by mini-css-extract-plugin
  let libraryNameAmd = webpackOutputFileName.replace(/(\.min)?\.js/, "");
  let libraryNameCjs = libraryNameAmd;
  webpackConfig.push({
    context: srcAbsPath,
    mode,
    name: configName,
    entry: entryMap,
    target: targetEnvironment === "web" ? "browserslist" : targetEnvironment,
    output: {
      filename: webpackOutputFileName,
      chunkFilename: `chunks/${configName.replace(/(\.min)?\.js$/, "")}/[id]-[contenthash]${
        opts.minify ? ".min" : ""
      }.js`,
      hotUpdateChunkFilename: `__webpack-hot-update/${configName.replace(
        /(\.min)?\.js$/,
        ""
      )}/[id].[fullhash].hot-update.js`,
      hotUpdateMainFilename: `__webpack-hot-update/${configName.replace(
        /(\.min)?\.js$/,
        ""
      )}/[runtime].[fullhash].hot-update.json`,
      assetModuleFilename: "[file]",
      path: outputAbsPath,
      publicPath: "", // publicPath is configured during runtime (in browser) via __webpack_public_path__
      pathinfo: !opts.minify && !env.isDistributionBuild,
      chunkLoadingGlobal: (
        "__webpack_jsonp_" +
        pkg.name +
        "_" +
        pkg.version +
        "_" +
        configName.replace(/(\.min)?\.js$/, "")
      ).replace(/[^a-zA-Z0-9_]/g, "_"), // to prevent collisions between libraries if they load chunks themselves
      crossOriginLoading: "anonymous",
      ...(targetEnvironment === "web"
        ? {
            libraryTarget: "umd",
            library: {
              type: "umd",
              name: {
                root: opts.libraryGlobalVariable ? opts.libraryGlobalVariable.split(".") : "[name]",
                amd: libraryNameAmd,
                commonjs: libraryNameCjs,
              },
            },
            globalObject: "this",
            umdNamedDefine: true,
          }
        : null),
      devtoolModuleFilenameTemplate: opts.useSourceMaps
        ? !env.isDistributionBuild
          ? // when debugging in IDE (RubyMine, VS Code) IDEs map sourceMap addresses into workspace folders;
            // VS Code uses "sourceMapPathOverrides" for that and we want the value not to change between
            // different projects/app so we'll not include package name & version while developing
            "webpack:///" + src.replace(/\\/g, "/") + "/[resource-path]"
          : // include package name & version in source map names so that they don't collide
            // in an application which uses more libraries built by these tools
            "webpack:///" + pkg.name + "@" + pkg.version + "/" + src.replace(/\\/g, "/") + "/[resource-path]"
        : undefined,
    },
    resolve: {
      alias: aliases,
    },
    resolveLoader: {
      // make loaders available to the project (without having to have them in package.json)
      modules: resolveLoaderModules,
    },
    module: {
      rules: rules,
      parser: { javascript: { importMeta: false } },
      noParse: /node_modules[/\\]systemjs[/\\]dist[/\\]/, // for uu5loaderg01
      unknownContextCritical: pkg.name !== "uu5loaderg01", // for uu5loaderg01 (disables warning about using require(dynamicValue) which is used in uu5loaderg01 only)
      exprContextCritical: false, // do not warn when doing stuff like: import(`./${lang}.json`)
    },
    plugins: plugins,
    optimization,
    externals: function ({ context, request }, callback) {
      if (request.match(/\.less$/)) return callback(); // .less files are always considered non-external

      let versionCheckRedirect = versionCheckModuleMap[request];
      if (versionCheckRedirect === true) return callback();
      if (versionCheckRedirect) request = versionCheckRedirect;

      // distinguish externals by using static "externalsConfig" configuration
      let conf;
      let rootModule = request.replace(/\/.*/, ""); // "module/that/is/nested" => "module"
      if (externalsConfig[request] === false) conf = false;
      else if (externalsConfig[request] != null) conf = externalsConfig[request];
      else conf = externalsConfig[rootModule];

      let loadAsExternal;
      if (!loadAsExternal && (!conf || conf.baseUri === false)) return callback(); // configured as not external
      if (!loadAsExternal) {
        let amdRequest =
          // allow importing submodules via "/", i.e. redirect `import "uu5g04/bricks"` to `import "uu5g04-bricks"`
          rootModule === pkg.name && request.replace(/\//, "-").replace(/\/.*/, "") in submodules
            ? request.replace(/\//, "-")
            : request;
        loadAsExternal = {
          amd: amdRequest,
          commonjs: rootModule in submodules ? pkg.name + "/" + request.substr(pkg.name.length + 1) : request,
          commonjs2: rootModule in submodules ? pkg.name + "/" + request.substr(pkg.name.length + 1) : request,
          root:
            typeof conf == "string"
              ? conf.split(".")
              : conf.globalVariable
              ? conf.globalVariable.split(".")
              : /*conf.format == "global" ?*/ conf.exports /*:*/ || amdRequest,
        };
      }

      return callback(null, loadAsExternal);
    },
    devtool: opts.useSourceMaps ? (opts.minify ? "source-map" : "eval-cheap-module-source-map") : false,
    bail: env.isDistributionBuild,
    performance: {
      hints: false,
    },
    stats,
  });

  // add generating of modified react-dom so that React's hot reload works
  if (reactHot && opts.copyFiles) {
    let hotLoaderReactCommonEntry = createTemporaryModuleFile(
      `module.exports = { ReactDOM: require("react-dom"), ReactHotLoader: require("react-hot-loader/dist/react-hot-loader.development.js") };\n`,
      hotLoaderReactCommonFile
    );
    let hotLoaderReactDomEntry = createTemporaryModuleFile(
      `module.exports = require("hot-loader-react-common").ReactDOM;\n`,
      hotLoaderReactDomFile
    );
    let hotLoaderReactHotLoaderEntry = createTemporaryModuleFile(
      `module.exports = require("hot-loader-react-common").ReactHotLoader;\n`,
      hotLoaderReactHotLoaderFile
    );
    // prefer using react-dom from uu5g05/uu5g04 (e.g. when uuApp uses 3rd-party lib which causes react-dom to be installed
    // into node_modules/react-dom/ in different version than uu5g05 wants)
    let reactDomPath;
    let uu5g05Path = getModulePathFromProject("uu5g05");
    if (uu5g05Path) reactDomPath = getModulePathFromDirectory("react-dom", uu5g05Path);
    if (!reactDomPath) {
      let uu5g04Path = getModulePathFromProject("uu5g04");
      if (uu5g04Path) reactDomPath = getModulePathFromDirectory("react-dom", uu5g04Path);
      if (!reactDomPath) {
        reactDomPath = getModulePathFromProject("react-dom");
      }
    }
    webpackConfig.push({
      context: srcAbsPath,
      mode: "development",
      name: "hot-loader-react-common",
      entry: { [hotLoaderReactCommonFile.replace(/\.js$/, "")]: hotLoaderReactCommonEntry },
      output: {
        filename: "[name].js",
        path: outputAbsPath,
        pathinfo: false,
        libraryTarget: "umd",
        library: {
          type: "umd",
          name: {
            root: "HotLoaderReactCommon",
            amd: "hot-loader-react-common",
            commonjs: "hot-loader-react-common",
          },
        },
      },
      externals: {
        react: { commonjs: "react", commonjs2: "react", amd: "react", _: "React" },
        "prop-types": { commonjs: "prop-types", commonjs2: "prop-types", amd: "prop-types", _: "PropTypes" },
      },
      plugins: [new webpack.DefinePlugin({ "process.env": { NODE_ENV: JSON.stringify("development") } })],
      resolve: {
        modules: [
          reactDomPath && path.join(reactDomPath, ".."),
          "node_modules",
          path.dirname(path.dirname(require.resolve("react-hot-loader/package.json"))),
        ].filter(Boolean),
      },
      module: {
        rules: [
          {
            test: /\.jsx?$/,
            include: /node_modules/,
            use: [require.resolve("react-hot-loader/webpack")],
          },
        ],
      },
      stats: false,
      devtool: false,
    });
    webpackConfig.push({
      context: srcAbsPath,
      mode: "development",
      name: "hot-loader-react-dom",
      entry: { [hotLoaderReactDomFile.replace(/\.js$/, "")]: hotLoaderReactDomEntry },
      output: {
        filename: "[name].js",
        path: outputAbsPath,
        pathinfo: false,
        libraryTarget: "umd",
        library: { type: "umd", name: { root: "ReactDOM", amd: "react-dom", commonjs: "react-dom" } },
      },
      externals: {
        "hot-loader-react-common": {
          commonjs: "hot-loader-react-common",
          commonjs2: "hot-loader-react-common",
          amd: "hot-loader-react-common",
          _: "HotLoaderReactCommon",
        },
      },
      stats: false,
      devtool: false,
    });
    webpackConfig.push({
      context: srcAbsPath,
      mode: "development",
      name: "hot-loader-react-hotLoader",
      entry: { [hotLoaderReactHotLoaderFile.replace(/\.js$/, "")]: hotLoaderReactHotLoaderEntry },
      output: {
        filename: "[name].js",
        path: outputAbsPath,
        pathinfo: false,
        libraryTarget: "umd",
        library: {
          type: "umd",
          name: { root: "ReactHotLoader", amd: "react-hot-loader", commonjs: "react-hot-loader" },
        },
      },
      externals: {
        "hot-loader-react-common": {
          commonjs: "hot-loader-react-common",
          commonjs2: "hot-loader-react-common",
          amd: "hot-loader-react-common",
          _: "HotLoaderReactCommon",
        },
      },
      stats: false,
      devtool: false,
    });
  }

  // add generating of uu5-environment.js file
  if (templateType === "uu5-app" && opts.copyFiles && process.env.NODE_ENV !== "test") {
    let uu5EnvPlugins = [];
    // NOTE hot-reload for uu5-environment.js is now disabled as it is being inlined into uu5-app's html page
    // and the HMR code makes it really big (developer can still change the settings and do F5 in browser)
    // we'll additionally make it as small as possible, i.e. turn on production mode
    let mode = "production";
    let uu5EnvConfigName = "uu5-environment";
    if (usedBundleNames.has(uu5EnvConfigName))
      throw new Error(
        'Unable to bundle uu5-environment. It is probably defined in config/config.js "packs" field - remove it from there.'
      );

    // set various optimization flags
    let uu5EnvOptimization = {};
    if (env.isDevServer && !env.isDistributionBuild) uu5EnvOptimization.moduleIds = "named";
    uu5EnvOptimization.concatenateModules = mode === "production";
    uu5EnvOptimization.emitOnErrors = !env.isDistributionBuild;
    uu5EnvOptimization.minimize = mode === "production";
    let uu5EnvFileContents;
    // prepare default value for uu5loaderg01_initUuAppDisabled flag
    // TODO Next major - change `: true` into `: false` so that uuApps use dependency/load by default when they're starting in browser.
    let uu5EnvFallbackData = {
      uu5loaderg01_initUuAppDisabled: env.isCdnDisabled || env.isCdnExactVersions ? true : true,
    };
    let uu5EnvData;
    if (env.isDistributionBuild) {
      uu5EnvData = {
        ...uu5EnvFallbackData,
        ...(opts.uu5Environment || require(path.resolve("env/production.json")).uu5Environment),
      };
      uu5EnvFileContents = `window.UU5={Environment: ${JSON.stringify(uu5EnvData)}};`;
    } else {
      uu5EnvData =
        process.env.NODE_ENV === "development" || !opts.uu5Environment
          ? Object.assign(
              {},
              uu5EnvFallbackData,
              require(path.resolve("env/production.json")).uu5Environment,
              opts.uu5Environment || require(path.resolve("env/development.json")).uu5Environment
            )
          : { ...uu5EnvFallbackData, ...opts.uu5Environment };
      uu5EnvFileContents = `
var fallbackConfig = ${JSON.stringify(uu5EnvFallbackData || {})};
var devConfig = require(${JSON.stringify(path.resolve("env/development.json"))}).uu5Environment;
var config = require(${JSON.stringify(path.resolve("env/production.json"))}).uu5Environment || {};
if (devConfig) for (var k in devConfig) config[k] = devConfig[k];
if (fallbackConfig) for (var k in fallbackConfig) if (!(k in config)) config[k] = fallbackConfig[k];
window.UU5 = { Environment: config };
`;
    }
    // TODO Make uu5-environment.json file auto-update on file change too.
    let uu5EnvJsonFile = createTemporaryModuleFile(JSON.stringify(uu5EnvData, null, 2), "uu5-environment.json");
    uu5EnvPlugins.push(
      new CopyWebpackPlugin({
        patterns: [{ context: path.dirname(uu5EnvJsonFile), from: "uu5-environment.json", noErrorOnMissing: true }],
      })
    );
    let entryValue = [createTemporaryModuleFile(uu5EnvFileContents, "uu5-environment.js")];

    webpackConfig.push({
      context: srcAbsPath,
      mode,
      name: uu5EnvConfigName,
      entry: { "uu5-environment": entryValue },
      output: {
        filename: "[name].js",
        path: outputAbsPath,
        pathinfo: false,
        hotUpdateChunkFilename: "__webpack-hot-update/[id].[fullhash].hot-update.js",
        hotUpdateMainFilename: "__webpack-hot-update/[runtime].[fullhash].hot-update.json",
      },
      plugins: uu5EnvPlugins,
      optimization: uu5EnvOptimization,
      bail: env.isDistributionBuild,
      performance: {
        hints: false,
      },
      stats,
      devtool: false,
    });
  }

  return webpackConfig;
}

function createEntryPointFile(name, opts, version) {
  fs.mkdirsSync(paths.buildWebpackTempDir + "/" + name.replace(/^(.*\/).*/, "$1").replace(/^\.\//, ""));
  let noRelativeName = name.replace(/^\.\//, "");
  let noRelativeOutputName = opts.outputFile
    ? opts.outputFile.replace(/^\.\//, "").replace(/\\/g, "/")
    : noRelativeName;
  let depthFromAppAssetsBase = noRelativeOutputName.split(/\//).length;
  let majorVersion = version.replace(/\..*/, "");
  let entryFileContents = `module.exports = require("__project__/${noRelativeName}");
var ex = module.exports;
if (ex && typeof ex === "object") {
  if (!("version" in ex)) Object.defineProperty(ex, "version", { configurable: true, value: process.env.VERSION });
  if (!("name" in ex)) Object.defineProperty(ex, "name", { configurable: true, value: process.env.OUTPUT_NAME.split(/[\\/\\\\]/).pop() });
  if (!("namespace" in ex)) Object.defineProperty(ex, "namespace", { configurable: true, value: process.env.NAMESPACE });
}
`;
  entryFileContents = `var mod=require("module");
var isDoc = typeof document !== "undefined";
var uri = ${
    opts.targetEnvironment === "webworker"
      ? "location.href"
      : '((mod ? mod.uri : isDoc && (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName("script"), -1)[0] || {}).src) || "").toString();'
  }
uri = uri.split(/\\//).slice(0, -${depthFromAppAssetsBase}).join("/") + "/"; // runtime publicPath configuration required for proper linking of styles, background images, ...
var floatingVersion = "/${majorVersion}.0.0/";
if (uri.substr(-floatingVersion.length) === floatingVersion) uri = uri.substr(0, uri.length - floatingVersion.length) + "/${version}/";
__webpack_public_path__ = process.env.NODE_ENV === "test" && uri === "/" ? "file://" + eval("__filename").replace(/[^/\\\\]*$/, "") : uri;
${entryFileContents}`;

  // NOTE Use file name so that following scenario works:
  // 1. npm start
  // 2. npm test (while npm start is up) => without file name, the names would be "temp-0.js" and
  //    this would overwrite the files used in step 1 by CJS variants, leading to "Compilation failed"
  //    all the time, i.e. developer would have to restart npm start.
  return createTemporaryModuleFile(entryFileContents, noRelativeName);
}

let tempCounter = 0;
function createTemporaryModuleFile(fileContents, optionalFileName) {
  let tmpFilePath =
    paths.buildWebpackTempDir + "/" + (optionalFileName ? optionalFileName : "temp-" + tempCounter++ + ".js");
  fs.removeSync(tmpFilePath);
  fs.ensureDirSync(path.dirname(tmpFilePath));
  fs.writeFileSync(tmpFilePath, fileContents, "utf-8");

  // prevent re-compilation loop during first few seconds after "npm start"
  // https://github.com/webpack/watchpack/issues/25
  let timeInPast = Date.now() / 1000 - 10;
  fs.utimesSync(tmpFilePath, timeInPast, timeInPast);
  return path.resolve(tmpFilePath);
}

function getHtmlFilesToProcess(mappingsJson, srcPath) {
  let resultSet = new Set();
  if (mappingsJson) {
    for (let k in mappingsJson) {
      // iterate over UCs in the mappings.json and pick those which are VUC and end with .html (or .htm)
      let ucMap = (mappingsJson[k] || {})["useCaseMap"] || {};
      Object.keys(ucMap)
        .filter(
          (uc) =>
            (ucMap[uc].type === "VUC" || ucMap[uc].type === "UVE") && (ucMap[uc].realization || "").match(/\.html?$/i)
        )
        .map((uc) => ucMap[uc].realization.replace(/^\/+/, ""))
        .forEach((htmlFile) => resultSet.add(htmlFile));
    }
  }
  let filesInSrc = fs.readdirSync(srcPath, { withFileTypes: true });
  filesInSrc.filter((item) => item.name.match(/\.html?$/) && item.isFile()).forEach((item) => resultSet.add(item.name));
  return [...resultSet];
}

function getHotClientOptions(name, devServerConfig, dynamicPublicPath = true, noInfo = false) {
  let result = `?name=${encodeURIComponent(name)}&reload=true`;
  if (dynamicPublicPath) result += `&dynamicPublicPath=true`; // NOTE Must not be present in result if it's supposed to be false.
  if (noInfo) result += "&noInfo=true"; // NOTE Must not be present in result if it's supposed to be false.
  let { https, host, port } = devServerConfig;
  let hmrUrl =
    (https ? "https" : "http") + "://" + (host === "0.0.0.0" ? "localhost" : host) + ":" + port + "/__webpack_hmr";
  result += "&path=" + encodeURIComponent(hmrUrl);
  return result;
}

function getStyleLoaderInsertInto(dataOwner, emotionKey, srcAbsPath, configName) {
  let content = fs.readFileSync(require.resolve("./webpack-misc/style-loader-insert-into.ejs"), "utf-8");
  content = content.replace(/<%=\s*EMOTION_KEY\s*%>/g, () => emotionKey);
  content = content.replace(/<%=\s*DATA_OWNER\s*%>/g, () => dataOwner);

  let filePath = createTemporaryModuleFile(content, `__styles/${configName}-insert-into.js`);
  return filePath;
}

function renderTemplate(sourceFile, filePath, context) {
  let resolvedPath;
  if (filePath.match(/^\.\.?[/\\]/)) resolvedPath = path.resolve(path.dirname(sourceFile), filePath);
  else {
    resolvedPath = path.resolve(
      path.dirname(require.resolve("uu_appg01_devkit-common/package.json")),
      "src/templates-generator/__uu5",
      filePath
    );
  }
  let result = "";
  if (fs.existsSync(resolvedPath)) {
    result = fs.readFileSync(resolvedPath, "utf-8");
    if (context) {
      if (!StringUtil) StringUtil = require("uu_appg01_devkit-common/src/tools/string-util.js");
      result = StringUtil.evalExpressions(result, context, resolvedPath);
    }
  }
  return result;
}

function writeAliases(config, outputFile) {
  // export aliases from webpack configuration so that jest-resolver.js
  // have them available (this mustn't be done directly in jest-resolver.js
  // because Jest already runs in N processes at that time and preparing webpack
  // configuration creates some temporary modules which would need some sort of
  // synchronization so that fs operations don't fail)
  let packs = config.packs || [];
  if (!packs.length) return;
  let env = fillEnvDefaults();
  let opts = fillDefaults(Object.assign({}, config, packs[0]), env);
  let { aliases } = computeAliases(opts, env);
  if (!fs.existsSync(path.dirname(outputFile))) fs.mkdirSync(path.dirname(outputFile), { recursive: true });
  fs.writeFileSync(outputFile, JSON.stringify(aliases, null, 2), "utf-8");
}

function computeAliases(opts, env, pkg) {
  let useMockData = opts.useMockData && !env.isDistributionBuild && fs.existsSync("mock/calls.js");
  let { hot, reactHot, srcAbsPath } = getBasicSettings(opts, env, pkg);
  let aliases = { ...opts.aliases };
  let plugins = [];
  for (let k in aliases) {
    if (typeof aliases[k] === "string" && aliases[k].match(/^\.\.?[/\\]/)) aliases[k] = path.resolve(aliases[k]);
  }
  Object.assign(aliases, {
    __project__: srcAbsPath, // alias for root of src folder (used by all on-the-fly created modules / chunks)
    calls: useMockData ? path.resolve("mock/calls.js") : path.resolve(srcAbsPath, "calls.js"),
  });
  if (!aliases["@babel/runtime"]) {
    // take @babel/runtime/helpers/... automatically from devkit (do not require project to have dependency on it)
    aliases["@babel/runtime"] = path.dirname(require.resolve("@babel/runtime/package.json"));
  }
  if (!reactHot) {
    // using reactHot is handled by using external "react-hot-loader"; this is here for cases
    // when it's turned off (npm start -- --no-hot) and uu5-app source code contains import to it
    aliases["react-hot-loader"] = path.dirname(require.resolve("react-hot-loader"));
  }
  if (hot) {
    // webpack-hot-middleware ignores errors during accept phase of hot reloading
    // => patch it to trigger page reload in such case
    let processUpdateStr = fs.readFileSync(require.resolve("webpack-hot-middleware/process-update.js"), "utf-8");
    processUpdateStr +=
      "\n" + "applyOptions.ignoreUnaccepted = applyOptions.ignoreDeclined = applyOptions.ignoreErrored = false;\n";
    aliases["__webpack-hot-middleware-process-update-fix"] = createTemporaryModuleFile(
      processUpdateStr,
      "__webpack-hot-middleware-process-update-fix.js"
    );
    const webpack = require("webpack");
    plugins.push(
      new webpack.NormalModuleReplacementPlugin(/\/process-update/, (resource) => {
        if (resource.context.indexOf("webpack-hot-middleware") !== -1)
          resource.request = "__webpack-hot-middleware-process-update-fix";
      })
    );
  }

  return { aliases, plugins };
}

function getBasicSettings(opts, env, pkg = Package.getSingletonSync("package.json").get()) {
  let mode = opts.minify ? "production" : "development";
  let hot = env.isDevServer && opts.hot !== false && opts.targetEnvironment === "web";
  let hasReact =
    ("react" in (pkg.dependencies || {}) || "react" in (opts.externals || {})) && opts.targetEnvironment === "web";
  // NOTE React hot loading doesn't currently work in uu5-lib because it needs special transpilation plugin
  // for root component (and for other files) and our root component is defined directly in demo .html page
  // and transpiled by Uu5Loader, not by webpack
  let reactHot = hasReact && hot && templateType === "uu5-app" && mode !== "production";
  let srcAbsPath = path.resolve(opts.sourcePath);
  return { mode, hot, reactHot, srcAbsPath };
}

function getModulePathFromProject(moduleName) {
  return getModulePathFromDirectory(moduleName, ".");
}

function getModulePathFromDirectory(moduleName, dir) {
  let pkgPath = buildHelpers.resolvePackageJsonPath(moduleName, dir);
  return pkgPath ? path.dirname(pkgPath) : null;
}

function getHtmlTemplateParametersFn(dataToFill) {
  // taken from html-webpack-plugin/index.js#templateParametersGenerator() and added remembering of compilation&assets
  return function templateParametersGenerator(compilation, assets, assetTags, options) {
    Object.assign(dataToFill, { compilation, assets });
    return {
      compilation: compilation,
      webpackConfig: compilation.options,
      htmlWebpackPlugin: {
        tags: assetTags,
        files: assets,
        options: options,
      },
    };
  };
}

const KNOWN_LIBS_USING_OIDC = ["uu_appg01", "uu_plus4u5g02", "uu_plus4u5g01"];
function getUuAppOidcPath(pkg) {
  let done = new Set([pkg.name]);
  function dive(inDir, pkg) {
    let result = getModulePathFromDirectory("uu_appg01_oidc", inDir);
    if (!result) {
      // if project doesn't depend directly on uu_appg01_oidc (and is e.g. installed via pnpm) then try to find
      // it via uu_appg01/uu_plus4u5g02/uu_plus4u5g01 modules first, then via any other (devkit-based)
      let deps = [...new Set(Object.keys(pkg.dependencies || {}).concat(Object.keys(pkg.devDependencies || {})))];
      deps = deps.filter((it) => !done.has(it));
      deps.forEach((it) => done.add(it));
      let score = (name) =>
        KNOWN_LIBS_USING_OIDC.includes(name) ? 2 : KNOWN_LIBS_USING_OIDC.some((it) => name.startsWith(it)) ? 1 : 0;
      deps.sort((a, b) => score(b) - score(a)); // highest score first
      for (let indirectLibName of deps) {
        let indirectLibPath = getModulePathFromDirectory(indirectLibName, inDir);
        if (!indirectLibPath) continue;
        let indirectPkg = require(path.join(indirectLibPath, "package.json"));
        if (!indirectPkg.spec) continue; // not devkit-based library => skip
        result = dive(indirectLibPath, indirectPkg);
        if (result) break;
      }
    }
    return result;
  }
  return dive(".", pkg);
}
