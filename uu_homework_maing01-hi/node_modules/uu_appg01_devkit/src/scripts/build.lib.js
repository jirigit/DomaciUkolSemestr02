const path = require("path");
const fs = require("fs-extra");

const shell = require("shelljs");
const paths = require("../config/paths.js");
const buildHelpers = require("./common/build-helpers.js");

let helpers; // lazy-loaded
let WebpackRunner;
let Package;
let DependencyProcessor;

module.exports = class Build {
  constructor(config) {
    this.config = config;
  }
  async process() {
    console.log("Building project.");
    if (!this.config.getMode()) this.config.setMode("production");

    shell.mkdir("-p", paths.buildDir);
    buildHelpers.checkBuildLock(this.config);

    if (!helpers) helpers = require("../tools/helpers.js");
    let UpdateFromUuappJson = helpers.requireByTemplateType(__dirname + "/update-from-uuapp-json.js");
    await new UpdateFromUuappJson(this.config).process();

    // NOTE Webpack might be run in nodejs-lib too, if it has configured
    // "uuBuildSettings.packs" or "uuBuildSettings.externals" in package.json
    // (used probably only in uu_appg01_core-* libraries).
    let templateType = helpers.getTemplateInfo().type;
    if (!Package) Package = require("uu_appg01_devkit-common/src/tools/package.js");
    let pkg = Package.getSingletonSync().get();
    if (
      (templateType !== "nodejs-lib" && templateType !== "nodejs-devkit") ||
      (pkg.uuBuildSettings && (pkg.uuBuildSettings.packs || pkg.uuBuildSettings.externals))
    ) {
      if (!WebpackRunner) WebpackRunner = require("./webpack/runner.js");
      WebpackRunner.mergeBuildConfig(this.config);
      let mode = this.config.getUsedMode();
      let config = this.config.getAll();
      let { watch, useCdnExactVersions } = config;

      // compute externals
      let externalsDetail;
      let externalsForApp;
      if (!DependencyProcessor) DependencyProcessor = require("./common/dependency-processor.js");
      let depProcessor = new DependencyProcessor("package.json", true, useCdnExactVersions);
      if (!config.skipExternalsDiscovery) {
        let {
          detail,
          config: externalsConfig,
          errorredExternals,
        } = depProcessor.getExternals("lib", { printErrors: true });
        if (errorredExternals.length > 0) process.exit(1);
        config.externals = externalsConfig;
        externalsDetail = detail;
      } else if (config.externals) {
        for (let k in config.externals) {
          let dep = config.externals[k];
          if (!dep || typeof dep !== "object") continue;
          depProcessor.replaceDependencyExpressions(k, dep);
        }
      }

      // TODO Next major - we can remove generating of target/dist-node/ folder entirely as it is currently
      // generated only for backward compatibility. The incompatibility will then be:
      // 1. If someone uses dist-node in their package.json in jest.moduleNameMapper item values for legacy submodules,
      //    they should change it, e.g.:
      //       "^uu5g04[-/]([^/?!]+)": "uu5g04/dist-node/$1/$1-build.js", ->
      //       "^uu5g04[-/]([^/?!]+)": "uu5g04/$1.js",
      // 2. If someone uses custom npm scripts and expects that folder there.

      // clean output directory
      let nodeDestDir = path.resolve(config.outputPath, "..", "dist-node");
      let cjsOutputPath = templateType === "uu5-lib" ? nodeDestDir : null;
      fs.emptyDirSync(config.outputPath);
      if (cjsOutputPath) fs.emptyDirSync(cjsOutputPath);

      // copy lib/ folder
      if (fs.existsSync("lib")) {
        shell.cp("-rf", "lib", config.outputPath);
        if (cjsOutputPath) shell.cp("-rf", "lib", cjsOutputPath);
      }

      this.showDependenciesSettings(config, pkg);

      // generate mock data
      if (config.useMockData) {
        fs.ensureDirSync("mock/data");
        fs.copySync(require.resolve("uu_appg01_devkit-common/src/templates/__uu5-app/mock/calls.js"), "mock/calls.js", {
          overwrite: false,
        });
        fs.copySync(
          require.resolve("uu_appg01_devkit-common/src/templates/__uu5-app/mock/data/loadDemoContent.json"),
          "mock/data/loadDemoContent.json",
          { overwrite: false }
        );
        fs.copySync(require.resolve("uu_appg01_devkit-common/src/templates/__uu5-app/src/calls.js"), "src/calls.js", {
          overwrite: false,
        });
      }

      let workspaceLibList = this.config.getWorkspaceLibraryList();
      let isLibInWorkspaceMultiLib = workspaceLibList.some((it) => it.name === pkg.name);

      // for uu5-lib and iso-lib - generate assets/example-config.js file for demos
      if (templateType === "uu5-lib" || templateType === "lib") {
        let templateFile = path.join("..", "example-config.js");
        if (fs.existsSync(templateFile)) {
          // NOTE example-config.js is for all libraries in multi-library project, i.e. we must merge dependencies
          // from all nested libraries.
          let libraries = isLibInWorkspaceMultiLib
            ? workspaceLibList
            : [{ type: templateType, path: path.resolve(".") }];
          let unconfiguredDeps = new Set();
          for (let { type, path: libPath } of libraries) {
            if (type !== "uu5-lib" && type !== "lib") continue;
            let depProcessor = new DependencyProcessor(path.join(libPath, "package.json"));
            let singleExternalsForAppDetails = depProcessor.getExternals("app");
            if (singleExternalsForAppDetails.errorredExternals.length > 0) {
              let errorredDeps = singleExternalsForAppDetails.errorredExternals.map((it) => it.name).sort();
              let templateFileContent = fs.readFileSync(templateFile, "utf-8");
              let templateFileContentNoComments = templateFileContent.replace(/\/\/.*|\/\*(\s|\S)*?\*\//g, "");
              let unconfiguredDeps0 = errorredDeps.filter((it) => templateFileContentNoComments.indexOf(it) === -1);
              for (let dep of unconfiguredDeps0) unconfiguredDeps.add(dep);
            }
            externalsForApp = { ...singleExternalsForAppDetails.config, ...externalsForApp };
          }
          if (unconfiguredDeps.size > 0) {
            console.warn(
              `${require("chalk").yellow(
                "WARN"
              )} Unable to compute URLs for demos for some external dependencies. You should configure them yourself in ${templateFile}:${[
                "",
                ...unconfiguredDeps,
              ].join("\n  ")}`
            );
          }
          let targetFile = path.join(config.outputPath, "assets", "example-config.js");
          this._generateExampleConfig(templateFile, targetFile, externalsForApp, workspaceLibList, watch);
        }
      }

      // run webpack
      let env = {
        isDevServer: watch,
        isDistributionBuild: !watch && mode !== "development",
        sameProductFrontendLibs: isLibInWorkspaceMultiLib
          ? workspaceLibList.filter((it) => it.type === "lib" || it.type === "uu5-lib").map((it) => it.name)
          : undefined,
      };
      let webpackConfig = require("../config/webpack.config.js").getFromConfig(config, env);
      if (webpackConfig && (!Array.isArray(webpackConfig) || webpackConfig.length > 0)) {
        await new WebpackRunner(webpackConfig, config).run({
          watch,
          onCompile: watch ? this._onWatchedCompile.bind(this, pkg) : null,
        });

        // additional build steps
        if (templateType === "lib") {
          // isomorphic libraries need extra entry point for their .tgz for browser (so that tools such as webpack
          // will know that when building for browser, they should use this entry point which will redirect it to dist/ files)
          let destDir = config.outputPath;
          let distRootFilesDir = path.resolve(destDir, "..", "dist-root");
          fs.emptyDirSync(distRootFilesDir);
          let content = `module.exports = process.env.NODE_ENV === "production" ? require("./dist/${pkg.name}.min.js") : require("./dist/${pkg.name}.js");\n`;
          fs.writeFileSync(path.join(distRootFilesDir, "index-browser.js"), content, "utf-8");
        } else if (templateType === "uu5-lib") {
          let srcDir = config.sourcePath;
          let destDir = config.outputPath;
          let srcDirAbsPath = path.resolve(srcDir);

          // finish building of CJS (Node-like) variant of the library by preparing submodule files
          // that will be in the root of built NPM .tgz file (these will ensure that applications
          // such as those created by create-react-app can import our submodules via "lib/submodule")
          // NOTE 2.x We'll preserve target/dist/, target/dist-node/, structure for backward compatibility.
          // In next major we should just make target/build/ and build all variants there.
          let distRootFilesDir = path.resolve(destDir, "..", "dist-root");
          fs.emptyDirSync(distRootFilesDir);
          let submodules = getSubmodules(config.packs, pkg.name);
          let cjsFileMap = { index: pkg.name };
          submodules.forEach(({ name }) => (cjsFileMap[name.substr(pkg.name.length + 1)] = name));
          for (let [cjsFile, builtFile] of Object.entries(cjsFileMap)) {
            let content = `module.exports = process.env.NODE_ENV === "production" ? require("./dist/${builtFile}.min.js") : require("./dist/${builtFile}.js");\n`;
            fs.writeFileSync(path.join(distRootFilesDir, cjsFile + ".js"), content, "utf-8");

            // for backward compatibility with devkit <= 5.x, generate also target/dist-node/ files
            // (redirect them to ../dist/ files)
            // TODO Next major - remove (see todo above, regarding /dist-node/ removal).
            let backCompatContent1 = `module.exports = require("../dist/${builtFile}.js");\n`;
            fs.writeFileSync(path.join(nodeDestDir, builtFile + ".js"), backCompatContent1, "utf-8");
            let backCompatContent2 = `module.exports = require("../dist/${builtFile}.min.js");\n`;
            fs.writeFileSync(path.join(nodeDestDir, builtFile + ".min.js"), backCompatContent2, "utf-8");
          }
          // for backward compatibility generate also entrypoints based on packs
          // (e.g. uu5g04-bricks with entry point bricks/bricks-build.js will end-up in dist-node/bricks/bricks-build.js
          // and in .tgz file it will just redirect to require("../../bricks.js") which is during build located it dist-root/bricks.js)
          // TODO Next major - remove (see todo above, regarding /dist-node/ removal).
          submodules.forEach(({ name, entryPoint }) => {
            let content = `module.exports = require(${JSON.stringify(
              path.relative(path.resolve(srcDir, entryPoint), path.resolve(srcDir)).replace(/\\/g, "/") +
                "/" +
                name.substr(pkg.name.length + 1) +
                ".js"
            )});\n`;
            let destFile = path.join(
              nodeDestDir,
              path.relative(path.resolve(srcDir), path.resolve(srcDir, entryPoint))
            );
            fs.ensureDirSync(path.dirname(destFile));
            fs.writeFileSync(destFile, content, "utf-8");
          });

          // generate index.d.ts file so that there's Intellisense available in IDEs
          if (!config.skipBuildIntellisense) {
            console.log("Generating files for better Intellisense in IDEs.");
            let srcIndexDTs = path.join(srcDir, "index.d.ts");
            let destIndexDTs = path.join(distRootFilesDir, "index.d.ts");
            if (fs.existsSync(srcIndexDTs)) fs.copySync(srcIndexDTs, destIndexDTs);
            else {
              let processEnv = require("../config/process-env.js")(pkg, "development", "browser");
              delete processEnv.NODE_ENV;
              let babelConfig = require("../config/.babelrc.js").getOptions("development", processEnv);
              const Es6ExportsReader = require("./intellisense/es6-exports-reader");
              let exportsReader = new Es6ExportsReader(babelConfig);

              let { packs = [] } = config;
              let mainNamespace = pkg.namespace;
              let packNsMap = {};
              for (let pack of packs) {
                if (
                  pack &&
                  pack.libraryGlobalVariable &&
                  (pack.libraryGlobalVariable === mainNamespace ||
                    pack.libraryGlobalVariable.startsWith(mainNamespace + "."))
                ) {
                  packNsMap[pack.libraryGlobalVariable] = pack;
                }
              }

              let mainExports;
              let mainNamespaceFixUp;
              let packsSorted = Object.values(packNsMap).sort(
                (a, b) => a.libraryGlobalVariable.length - b.libraryGlobalVariable.length
              ); // TODO Sort by dependencies in-between the packs (e.g. uu5g04 <= uu5g04-bricks <= uu5g04-forms).
              // 1st pack is always the one with the main namespace
              for (let pack of packsSorted) {
                let entryFile = (pack.entryPoints || []).slice(-1)[0];
                if (entryFile) {
                  let exports = exportsReader.getExportsFromFile(path.resolve(srcDirAbsPath, entryFile));
                  if (pack.libraryGlobalVariable === mainNamespace) mainExports = exports;
                  else {
                    let { default: _, ...exportsWithoutDefault } = exports;
                    let nsParts = pack.libraryGlobalVariable.substr(mainNamespace.length + 1).split(".");
                    if (!mainExports) {
                      // this can happen if there's pkg.namespace vs. packs[0].libraryGlobalVariable discrepancy
                      // e.g. uu_contentkitg01 is UuContentKit.Bricks, uu_contentkitg01-tables is UuContentKit.Tables,
                      //      but pkg.namespace === "UuContentKit"
                      // => we'll only process exports from 1st pack so that `import Xyz from "uu_contentkitg01";` has proper Intellisense - UuContentKit.Bricks.*
                      //    (`import "uu_contentkitg01-tables";` won't have Intellisense as it's correct that it is not present
                      //    in Xyz due to the discrepancy)
                      mainExports = exports;
                      mainNamespaceFixUp = pack.libraryGlobalVariable;
                      break;
                    }
                    let targetField = mainExports;
                    nsParts.forEach((part, i, list) => {
                      targetField[part] = {
                        type: "namespace",
                        objectFields: i === list.length - 1 ? exportsWithoutDefault : {},
                      };
                      targetField = targetField[part].objectFields;
                    });
                  }
                }
              }
              if (mainExports) {
                const ExportsToTypings = require("./intellisense/exports-to-typings");
                let exportsToTypings = new ExportsToTypings();
                let moduleNameOfNamespaceRoot =
                  mainNamespace.indexOf(".") === -1
                    ? pkg.name
                    : getLibraryNameByNamespace(mainNamespace.split(".").shift(), externalsDetail); // TODO Compute for non-roots. E.g. if mainNamespace === "UU5.Tiles" then root is "UU5" and module is "uu5g04".
                let typings = exportsToTypings.serialize(
                  mainExports,
                  mainNamespaceFixUp || mainNamespace,
                  mainNamespaceFixUp ? undefined : moduleNameOfNamespaceRoot
                );
                fs.writeFileSync(destIndexDTs, typings, "utf-8");
              }
            }
          }

          // generate also dist-esm/ folder (for backward compatibility) but keep it empty
          // TODO Next major - remove.
          let distEsmFilesDir = path.resolve(destDir, "..", "dist-esm");
          fs.ensureDirSync(distEsmFilesDir);
        }
      }
    }
  }

  showDependenciesSettings(config, pkg) {
    let deps = config.externals;
    let externalDeps = {};
    let externalDepsInfo =
      Object.keys(deps)
        .filter((depName) => !!deps[depName])
        .map((depName) => {
          let dep = deps[depName];
          externalDeps[depName] = dep;
          let paddedDepName = (depName + "                      ").substr(0, Math.max(20, depName.length));
          return `${paddedDepName}`;
        })
        .join("\n") || "<none>";
    let bundledDepsInfo =
      Object.keys(pkg.dependencies || {})
        .filter((depName) => !externalDeps[depName])
        .join("\n") || "<none>";
    console.log(`
BUILD OVERVIEW
External dependencies (including transitive):
${externalDepsInfo.replace(/(^|\n)/g, "$1  ")}

Dependencies from package.json bundled directly into main JS file (if imported):
${bundledDepsInfo.replace(/(^|\n)/g, "$1  ")}
`);
  }

  _onWatchedCompile(pkg, stats) {
    // run postbuild script from package.json after 1st compilation when in "watch" mode
    if (!this._ranPostBuildScript) {
      this._ranPostBuildScript = true;
      if (pkg && pkg.scripts && pkg.scripts.postbuild) {
        require("child_process").spawn("npm run -s postbuild", {
          shell: true,
          cwd: process.cwd(),
          stdio: "inherit",
        });
      }
    }
  }

  _generateExampleConfig(templateFile, targetFile, externals, workspaceLibList, watch) {
    let imports = {};
    if (externals) {
      const addImport = (name, fullUrl) => {
        imports[name] = fullUrl.pathname + fullUrl.search; // omit origin
      };
      for (let [name, info] of Object.entries(externals)) {
        if (!info) continue;
        let url = new URL(info.cdnBaseUri + info.mainMinified);
        addImport(name, url);
      }
      for (let workspaceLib of workspaceLibList) {
        if (!workspaceLib.sourceUri) continue;
        let url = new URL(workspaceLib.sourceUri.replace(/%s/g, () => workspaceLib.version.replace(/\..*/, ".0.0")));
        let isBeta = workspaceLib.version.match(/[-.][a-zA-Z]/);
        if (isBeta) url.pathname = "/beta" + url.pathname;
        addImport(workspaceLib.pkg.name, url);
      }
    }
    const generate = () => {
      let contentTemplate = fs.readFileSync(templateFile, "utf-8");
      let content = contentTemplate;
      content = content.replace(
        /(\n\s*(?:var|let|const)\s+imports\s*=\s*)\{\s*\}(\s*;?\s*)(?:\/\/.*)?/,
        (m, g1, g2) => g1 + JSON.stringify(imports, null, 2).replace(/\n/g, "\n  ") + g2
      );
      content = content.replace(/(^|\s*\n\s*)\/\/.*/g, "");
      fs.ensureDirSync(path.dirname(targetFile));
      fs.writeFileSync(targetFile, content, "utf-8");
    };
    generate();

    if (watch) {
      const chokidar = require("chokidar");
      let watcher = chokidar.watch(templateFile, { ignoreInitial: true, persistent: false });
      let plannedTimeout;
      watcher.on("all", (event, path) => {
        if (!plannedTimeout) {
          plannedTimeout = setTimeout(() => {
            plannedTimeout = undefined;
            generate();
          }, 50);
        }
      });
    }
  }
};

function getSubmodules(packs, pkgName) {
  let result = [];
  if (packs) {
    packs.forEach((pack) => {
      if (!(pack.outputFile || "").match(/\.js$/)) return;
      let name = pack.outputFile
        .split(/[/\\]/)
        .pop()
        .replace(/(\.min)?\.js$/, "");
      if (name.startsWith(pkgName + "-")) {
        result.push({ name, entryPoint: pack.entryPoints[pack.entryPoints.length - 1] });
      }
    });
  }
  return result;
}

function getLibraryNameByNamespace(ns, externalsDetail) {
  if (!externalsDetail || !ns) return;
  for (let external of Object.values(externalsDetail)) {
    let { namespace, name } = ((external || {}).sourceMeta || {}).json || {};
    if (namespace === ns) return name;
  }
}
