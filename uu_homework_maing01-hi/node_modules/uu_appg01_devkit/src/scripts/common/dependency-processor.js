const fs = require("fs");
const path = require("path");
const semver = require("semver");
const Package = require("uu_appg01_devkit-common/src/tools/package.js");
const { resolvePackageJsonPath } = require("../../tools/helpers.js");

const DEFAULT_CDN_URL = "https://cdn.plus4u.net";
const EXTERNALS_TYPE_APP = "app";
const EXTERNALS_TYPE_LIB = "lib";
const LIB_REGISTRY_EXCLUDED_DEPS = {
  react: true,
  "react-dom": true,
  "create-react-class": true,
  "prop-types": true,
};

module.exports = class DependencyProcessor {
  static getCdnName(libName, isUuAppLib) {
    let cdnLibName;
    if (libName === "uu_plus4u5g01-console") {
      // exception for the library which doesn't conform to naming conventions
      cdnLibName = libName.replace(/_/g, "-");
    } else if (isUuAppLib) {
      let libNameBase = libName.split("-")[0];
      cdnLibName = (
        libNameBase.indexOf("_") === -1 && libNameBase.match(/^uu/) ? "uu-" + libNameBase : libNameBase
      ).replace(/_/g, "-");
    } else {
      cdnLibName = "libs/" + libName;
    }
    return cdnLibName;
  }

  static getJsFileDirectDeps(jsContent) {
    let deps = [];
    // assume UMD header, i.e. something like:
    //   if (define.amd) define(["dep", ...], factory);     <=== this is what we need (our result should be ["dep", ...])
    //   else if (exports) root[cjsName] = factory(require("dep"), ...);
    //   else root["UU5"]["Bricks"] = factory(root["dep"], ...);
    jsContent.replace(/\bdefine\(/, (m, index) => {
      let closingBracketIndex = jsContent.indexOf("}", index);
      let headerContent = jsContent.slice(index, closingBracketIndex);
      let depsArrayStr = (headerContent.match(/\[[^\]]*\]/) || ["[]"])[0]; // deps array, i.e. array in define(["abc", "abd"], ...) call
      try {
        deps = JSON.parse(depsArrayStr);
      } catch (e) {
        // ignore (best effort only)
      }
    });
    return deps;
  }

  static getDirectDependencyVersionMap(externals, fallBackToUrls = false) {
    if (!externals) return;
    // NOTE "externals" can be app-based (items contain "baseUri" + "main" fields) or lib-based (items contain "uri" field)

    // TODO Next major - this method currently returns versions from URL. So if we have in package.json "uu_xyz": "^0.8.2",
    // URL contains /uu-xyz/0.0.0/, and this method returns map with "uu_xyz": "0.x" (this is how apps behaved). We should
    // switch this behavior to use the version in package.json, i.e. return map with "uu_xyz": "^0.8.2", or at least "0.8.x"
    // which would make the behaviour in browser be consistent with npm installation resolving (versions for Jest tests will
    // then be same as when running in browser).
    let directDependencyVersionMap = {};
    for (let [depName, depItem] of Object.entries(externals)) {
      if (!depItem || typeof depItem !== "object") continue; // skip special modules ("module", ...)
      let { detail, main, baseUri, uri } = depItem;
      if (!uri && typeof baseUri === "string") uri = (baseUri || "").replace(/\/*$/, "/") + main;
      if (typeof uri !== "string") continue;

      let versionSpecifier;
      if (!detail) {
        // it's an explicitly configured uuBuildSettings.externals.xyz key, or we're using skipExternalsDiscovery
        versionSpecifier = parseVersionFromCdnUri(uri);
      } else {
        let { cdnVersion, cdnVersionExact, topLevel } = detail.replacedTopLevel || detail;
        if (topLevel) {
          // it's a top-level dependency (from uuApp's / uuLib's package.json)
          versionSpecifier = cdnVersionExact ? cdnVersion : cdnVersion?.replace(/^(\d+)\.0\.0$/, (m, g) => g + ".x");
        } else {
          // not a top-level dependency => skip
          continue;
        }
      }
      let value = versionSpecifier || (fallBackToUrls ? uri : undefined);
      if (value != null) {
        directDependencyVersionMap[depName] = value;
      }
    }

    // sort direct dependencies by name
    let tmpMap = directDependencyVersionMap;
    directDependencyVersionMap = {};
    Object.keys(tmpMap)
      .sort()
      .forEach((key) => (directDependencyVersionMap[key] = tmpMap[key]));

    return directDependencyVersionMap;
  }

  constructor(packageJson = "package.json", useCdn = true, useCdnExactVersions = undefined) {
    this.packageJson = packageJson;
    this.useCdn = useCdn;
    this.useCdnExactVersions =
      useCdnExactVersions ?? Package.getSingletonSync(this.packageJson).get().uuBuildSettings?.useCdnExactVersions;
  }

  // TODO Update to always return all information (not based on app/lib).
  /**
   * @param {"app"|"lib"} type Whether to return externals configuration as needed by "lib" project or by "app" project.
   */
  getExternals(type, { printErrors = false } = {}) {
    // compute all externals, including transitive, from dependencies in package.json
    let externals = this._computeExternals(this.packageJson, type);
    let externalsKeys = Object.keys(externals).sort();
    let errorredExternals = [];
    let config = {};
    for (let k of externalsKeys) {
      // change order to be sorted
      let item = externals[k];
      delete externals[k];
      externals[k] = item;

      if (item.value instanceof Error) {
        if (printErrors) {
          let chain = [item.name];
          let meta = item.sourceMeta;
          while (meta) {
            chain.push(meta.moduleName);
            meta = meta.ownerMeta;
          }
          chain.splice(-1, 1, "<project>");
          console.error(
            require("chalk").red("ERROR") +
              " Error while processing dependency chain: " +
              chain.reverse().join(" -> ") +
              ": " +
              (item.value.stack || item.value.toString()).replace(/^Error:/, "")
          );
        }
        errorredExternals.push(item);
      } else if (!(k in config)) {
        config[k] = item.value;
        if (config[k] && typeof config[k] === "object") {
          Object.defineProperty(config[k], "detail", {
            enumerable: false,
            configurable: true,
            get: () => {
              let { value, ...rest } = item;
              return rest;
            },
          });
        }
      }
    }

    return { detail: externals, config: config, errorredExternals };
  }

  /**
   * Replaces expressions in depSettings. Supported expressions:
   * ${version}
   * ${floatingVersion}
   * ${dependency['some-dep'].version}
   * ${dependency['some-dep'].floatingVersion}
   * ${devDependency['some-dep'].version}
   * ...
   * Any key from package.json can be used in the expression.
   *
   * For backward compatibility, it's possible to use % as delimiters, i.e. %version%, ...
   */
  replaceDependencyExpressions(depName, depSettings, ownerMeta = this._getMeta(this.packageJson)) {
    if (depSettings && typeof depSettings === "object") {
      for (let depOption in depSettings) {
        let depOptionValue = depSettings[depOption];
        if (typeof depOptionValue !== "string" || !depOptionValue) continue;
        depSettings[depOption] = depOptionValue.replace(/%([^%]*)%|\$\{([^}]*)\}/g, (m, ex1, ex2) => {
          // support %something% for backward compatibility
          let expression = ex1 || ex2;
          // extract bracketed values such as ['uu5g04'] into array (because they can contain dots) & replace them with ". "
          // ${dependencies['uu5g04'].version}  =>  ${dependencies. .version}
          let bracketedValues = [];
          expression = expression.replace(/\[([^\]]+)\]/g, (m, value) => {
            bracketedValues.push(value.replace(/^(['"])((\s|\S)*)\1$/, "$2"));
            return ". ";
          });
          // split by dot & replace spaces by bracketed values
          let parts = expression.split(".").map((it) => (it === " " ? bracketedValues.shift() : it));
          if (parts.length === 1) parts = ["dependencies", depName].concat(parts);

          let resolvedValue = ownerMeta.json;
          let i = 0;
          let depMeta;
          while (i < parts.length && resolvedValue != null) {
            if (parts[i].match(/dependencies/i)) {
              depMeta = this._getDependencyMeta(parts[++i], ownerMeta.path, ownerMeta, true);
              resolvedValue = depMeta ? depMeta.json : { version: "0.0.0" };
            } else if (parts[i] === "floatingVersion") {
              if (depMeta && depMeta.requestedVersion) {
                resolvedValue = this._toCdnVersion(
                  depMeta.requestedVersion,
                  resolvedValue.version,
                  depMeta && depMeta.isUuAppLib
                );
              } else {
                resolvedValue = resolvedValue["version"];
              }
            } else {
              resolvedValue = resolvedValue[parts[i]];
            }
            i++;
          }
          return resolvedValue != null ? resolvedValue : m;
        });
      }
    }
    return depSettings;
  }

  _computeExternals(packageJsonFile, externalsType, meta = undefined, parentInfo = null, cumulativeResult = {}) {
    if (meta === undefined) meta = this._getMeta(packageJsonFile, undefined, parentInfo?.sourceMeta);
    let addExternal = (external, overwrite = false) => {
      let { name } = external; // name, value, sourceType, sourceLocation; "value" can be true (auto-compute as external; e.g. for 3rd-party libs)
      let prevExternal = cumulativeResult[name];
      if (
        overwrite ||
        !(name in cumulativeResult) ||
        cumulativeResult[name].value === true ||
        external.topLevelExplicit ||
        (!cumulativeResult[name].topLevelExplicit &&
          isCdnVersionNewer(
            external.cdnVersion,
            cumulativeResult[name].cdnVersion,
            external.cdnVersionExact,
            cumulativeResult[name].cdnVersionExact
          ))
      ) {
        cumulativeResult[name] = external;
      }

      // devkit <= 5.x flattens dependencies, i.e. if uuApp depends on uu5tilesg02 ^1.0.0 and a transitive lib depends on ^2.0.0,
      // the result is single ^2.0.0; however, for Uu5Loader.initUuApp() which uses uuAppLibraryRegistry's dependency/load we need
      // direct dependencies only, and these must be unflattened so that we can transition uuApps into allowing them to use
      // multiple major versions of the same library (while ensuring backward compatibility within devkit 5.x)
      // => if we're going to overwrite direct dependency due to flattening, remember info about the original direct dependency too,
      //    so that we can construct direct dependency map from the result
      let cumulatedExternal = cumulativeResult[name];
      if (prevExternal) {
        if (cumulatedExternal === prevExternal && !cumulatedExternal.topLevel && external.topLevel) {
          cumulatedExternal.replacedTopLevel = external;
        } else if (cumulatedExternal === external && !cumulatedExternal.topLevel && prevExternal.topLevel) {
          cumulatedExternal.replacedTopLevel = prevExternal;
        }
      }
    };

    // add explicit externals from uuBuildSettings.externals
    let uuBuildSettings = meta.json.uuBuildSettings || {};
    let explicitExternals = uuBuildSettings.externals || uuBuildSettings.dependencies || {};
    Object.keys(explicitExternals).forEach((externalName) => {
      let externalValue = explicitExternals[externalName];
      if (parentInfo !== null && externalName === meta.json.name) return; // e.g. uu5g04 has itself in its uuBuildSettings.externals because of submodules => skip self reference
      if (parentInfo !== null && externalValue === false) return; // skip those marked as locally non-external (if we're in transitive library)
      if (externalName === "UU_ENVIRONMENT" || externalName === "module") return; // skip legacy externals and "module" (RequireJS); these aren't typically explicitly given but e.g. uuappdesignkitg01 for some reason has it in its package.json...
      let useAsIs = !(
        parentInfo ||
        typeof externalValue !== "object" ||
        // we're in top-level package.json of a library but are requesting "app"-type externals (e.g. when generating demo page)
        (externalsType === EXTERNALS_TYPE_APP && meta.json.spec && meta.json.spec.match(/^(uu5-lib|iso-lib|lib)/))
      ); // we're in top-level package.json => keep value as-is as the developer specified it
      let depConfigValue = this._computeDepConfigValue(meta, externalName, externalValue, externalsType, useAsIs);
      let { value, cdnVersion, cdnVersionExact, meta: externalMeta } = depConfigValue;
      let isLegacySubmodule =
        externalMeta && externalMeta.json.name === meta.json.name && externalMeta.moduleName !== externalMeta.json.name;
      addExternal({
        name: externalName,
        value: value,
        sourceType: "uuBuildSettings",
        sourceLocation: packageJsonFile,
        sourceMeta: meta,
        topLevelExplicit: !parentInfo,
        // if it's legacy submodule - override topLevel settings to be same as the original's main module settings
        // (e.g. if uuApp has package.json with dependencies: { uu5g04: "^1.0.0" }, uu5g04 is marked as "topLevel: true" and
        // we want uu5g04-bricks, ..., which are added after processing uu5g04's package.json, to be also marked as "topLevel: true";
        // and we need it so that uu5g05-bricks, ..., is sent to dependency/load when bootstrapping uuApp in browser)
        topLevel: !parentInfo || (isLegacySubmodule && parentInfo.topLevel),
        cdnVersion,
        cdnVersionExact,
        meta: externalMeta,
      });
    });

    if (meta.json.dependencies && (!meta.json.uuBuildSettings || !meta.json.uuBuildSettings.skipExternalsDiscovery)) {
      let browserField = meta.json.browser || {};
      let traverseTransitivelyList = [];
      for (let depName in meta.json.dependencies) {
        if (typeof browserField === "object" && depName in browserField) continue; // skip dependencies that are re-mapped / bundled if building for browser

        if (depName.startsWith("uu_appg01_core-")) continue; // TODO Remove. Necessary because uu_appg01_oidc < 2.0.0 has direct import of uu_appg01_core-perflog (basically it bundles stuff from uu_appg01_core duplicitly). Also because uu_appg01_core bundles these inside and it doesn't have it in uuBuildSettings.externals: { uu_appg01_core-uri: false, ... }.
        if (depName === "uu_appg01_server-client") continue; // TODO Remove. Necessary because uu_appg01 bundles this inside and it doesn't have it in uuBuildSettings.externals: { uu_appg01_server-client: false }.

        let depMeta, depValue;
        try {
          depMeta = this._getDependencyMeta(depName, packageJsonFile, meta);
        } catch (e) {
          // include this dependency as an errorred one
          depValue = e;
        }

        // add the dependency as external if it's uu5-lib / iso-lib, transitively
        if (!depMeta || depMeta.isUuAppLib) {
          let depParentInfo = {
            sourceType: "dependency",
            sourceLocation: packageJsonFile,
            sourceMeta: meta,
            topLevelExplicit: false,
            topLevel: !parentInfo,
          };
          if (!(depName in explicitExternals) || explicitExternals[depName] === true) {
            let cdnVersion, cdnVersionExact;
            if (depMeta) {
              ({
                value: depValue,
                cdnVersion,
                cdnVersionExact,
              } = this._computeDepConfigValue(meta, depName, undefined, externalsType));
            }
            addExternal({
              name: depName,
              value: depValue,
              ...depParentInfo,
              cdnVersion,
              cdnVersionExact,
              meta: depMeta,
            });
          }
          if (depMeta) {
            // we'll add transitive dependencies *after* we process the current package.json
            traverseTransitivelyList.push(() => {
              this._computeExternals(depMeta.path, externalsType, depMeta, depParentInfo, cumulativeResult);
            });
          }
        }
      }
      traverseTransitivelyList.forEach((fn) => fn());
    }

    return cumulativeResult;
  }

  _getDependencyMeta(depName, packageJsonFile, ownerMeta = null, skipIfNonexisting = false) {
    try {
      // 1. Handle also case if depName is submodule ("uu5g04-bricks", i.e. we need node_modules/uu5g04/package.json)
      // 2. Handle also case if depName is submodule ("uu5g05-elements-gds", i.e. we need uu5g05-elements/package.json).
      let name = depName;
      let depPkgJsonFile;
      let firstError;
      while (name) {
        try {
          if (ownerMeta && ownerMeta.json.name === name) {
            depPkgJsonFile = path.resolve(ownerMeta.path);
          } else {
            let fromDir = this._projectHasDirectDependency(name)
              ? path.dirname(path.resolve(this.packageJson))
              : packageJsonFile.replace(/[^/\\]*$/, "");
            depPkgJsonFile = resolvePackageJsonPath(name, fromDir);
            if (!depPkgJsonFile) {
              throw Object.assign(new Error(`Module '${name}' not found. From: ${fromDir}`), {
                code: "MODULE_NOT_FOUND",
              });
            }
          }
          break;
        } catch (e) {
          if (!firstError) firstError = e;
          if (e.code === "MODULE_NOT_FOUND") {
            name = name.split("-").slice(0, -1).join("-");
          } else {
            throw e;
          }
        }
      }
      if (!depPkgJsonFile) throw firstError;
      let meta = this._getMeta(depPkgJsonFile, depName, ownerMeta);
      if (!meta.isUuAppLib && name !== depName) throw firstError; // we simplified depName, e.g. "react-dom" into "react" and ended in non-uuApp lib => don't allow that
      return meta;
    } catch (e) {
      if (skipIfNonexisting && e.code === "MODULE_NOT_FOUND") return null;
      throw e;
    }
  }

  _projectHasDirectDependency(depName) {
    let pkg = Package.getSingletonSync(this.packageJson).get();
    return pkg.dependencies && pkg.dependencies[depName];
  }

  _computeDepConfigValue(meta, libName, libValue, externalsType, useValueAsIs) {
    let result;
    if (
      useValueAsIs ||
      libValue === false ||
      (externalsType === EXTERNALS_TYPE_LIB &&
        ((typeof libValue === "string" && LIB_REGISTRY_EXCLUDED_DEPS[libName]) ||
          (libValue && libValue.globalVariable && libValue.uri)))
    ) {
      result = { value: libValue };
    } else {
      let depMeta = this._getDependencyMeta(libName, meta.path, meta, true);
      if (!depMeta) {
        let depCdnName = DependencyProcessor.getCdnName(libName, true);
        result = {
          value: new Error(`Unable to find out URL & version for external dependency '${libName}' defined in ${
            meta.path
          }
Configure this library in your package.json in uuBuildSettings.externals manually, e.g.:
  ${JSON.stringify(libName)}: {
    ${
      externalsType === EXTERNALS_TYPE_APP
        ? `"cdnBaseUri": "${DEFAULT_CDN_URL}/${depCdnName}/X.Y.Z/"`
        : `"globalVariable": "${this._estimateGlobalVariableName(libName)}",
    "uri": "${DEFAULT_CDN_URL}/${depCdnName}/X.Y.Z/${libName}.min.js"`
    }
  }`),
        };
      } else {
        let localNaming = this._discoverLocalNamingForModule(depMeta, this.useCdn);
        let depValue = localNaming;
        if (!(depValue instanceof Error)) {
          let depCdnName = DependencyProcessor.getCdnName(depMeta.json.name, depMeta.isUuAppLib);
          let depCdnVersion = this._toCdnVersion(depMeta.requestedVersion, depMeta.json.version, depMeta.isUuAppLib);
          let depVersionFromParent =
            (meta.json.dependencies || {})[depMeta.json.name] ||
            (meta.json.devDependencies || {})[depMeta.json.name] ||
            "";
          let isBeta =
            depMeta.isUuAppLib &&
            (depMeta.json.version.match(/^\d+\.\d+\.\d+-/) || depVersionFromParent.match(/^https?:\/\/.*\/beta\//)); // version has specifier (e.g. "1.2.3-test.1") or was installed from URL containing "/beta/"
          let depCdnBaseUri = `${DEFAULT_CDN_URL}/${isBeta ? "beta/" : ""}${depCdnName}/${depCdnVersion}/`;
          if (externalsType === EXTERNALS_TYPE_APP) {
            depValue = {
              cdnBaseUri: depCdnBaseUri,
              ...depValue,
            };
            if (depMeta.isUuAppLib && depValue.localBaseUri && depValue.main) {
              let jsFile = path.join(depValue.localBaseUri, depValue.main);
              if (fs.existsSync(jsFile)) {
                let jsContent = fs.readFileSync(jsFile, "utf-8");
                let directDeps = DependencyProcessor.getJsFileDirectDeps(jsContent);
                if (directDeps && directDeps.length > 0) depValue.dependencyMap = directDeps;
              }
            }
          } else if (externalsType === EXTERNALS_TYPE_LIB) {
            let globalVariableName =
              (typeof libValue === "string" && libValue) ||
              (libValue && libValue.globalVariable) ||
              this._discoverGlobalVariableNameForModule(
                depMeta,
                path.join(localNaming.localBaseUri, localNaming.main || localNaming.mainMinified)
              ) ||
              this._estimateGlobalVariableName(depMeta.moduleName);
            depValue = {
              globalVariable: globalVariableName,
              uri: (libValue && libValue.uri) || depCdnBaseUri + localNaming.mainMinified,
            };
          } else {
            throw new Error("Unsupported externalsType: " + externalsType);
          }
        }
        result = { value: depValue, meta: depMeta };
      }
    }
    let uri;
    if (result && result.value && !(result.value instanceof Error)) {
      result.value = this.replaceDependencyExpressions(libName, result.value, meta);
      uri = result.value.uri || result.value.cdnBaseUri;
    }
    let cdnVersion = uri && uri.startsWith(DEFAULT_CDN_URL) ? uri.match(/\/(\d+\.[^/]+)/)?.[1] : undefined;
    if (cdnVersion) {
      result.cdnVersion = cdnVersion;
      result.cdnVersionExact =
        uri.startsWith(DEFAULT_CDN_URL + "/libs/") ||
        !cdnVersion.match(/^\d+\.0\.0$/) ||
        result.meta?.requestedVersion === cdnVersion; // exact X.0.0, e.g. "uu5xyzg01": "1.0.0"
    }
    return result;
  }

  _discoverLocalNamingForModule(meta, useCdn) {
    let result; // e.g. { localBaseUri: "node_modules/...", main: "uu_lib.js", mainMinified: "uu_lib.min.js" }
    let { moduleName } = meta;
    let moduleDir = path.dirname(meta.path);
    let candidates = meta.isUuAppLib ? ["dist", "target/dist"] : ["dist", "umd", "cjs", "target/dist", "."];
    for (let candidate of candidates) {
      let dir = path.resolve(moduleDir, candidate);
      if (fs.existsSync(dir)) {
        result = { localBaseUri: path.relative(".", dir).replace(/\\/g, "/") + "/" };
        // TODO Remove these special cases:
        // 1. react-dnd-touch-backend doesn't have pre-built files for browser in its npm module.
        //    Our CDN contains custom build of it => configure with naming used by our CDN.
        // 2. Production CDN uses renamed files for react & react-dom (react.min.js instead of react.production.min.js).
        if (moduleName === "react-dnd-touch-backend") {
          result.main = "Touch.browserified.js";
          result.mainMinified = "Touch.browserified.js";
        } else if (useCdn && moduleName.match(/^(react|react-dom)$/)) {
          result.main = moduleName + ".js";
          result.mainMinified = moduleName + ".min.js";
        } else {
          let main, mainMinified;
          for (let k of entryNameGenerator(moduleName, dir, true)) {
            if (fs.existsSync(path.join(dir, k))) {
              mainMinified = k;
              break;
            }
          }
          for (let k of entryNameGenerator(moduleName, dir, false)) {
            if (fs.existsSync(path.join(dir, k))) {
              main = k;
              break;
            }
          }

          if (!main) main = mainMinified;
          if (!mainMinified) {
            if (main && meta.isUuAppLib && candidate === "target/dist") mainMinified = main.replace(/\.js$/, ".min.js");
            else mainMinified = main;
          }
          if (!main && candidate === "target/dist" && meta.isUuAppLib) {
            // target/dist can be empty (cleaned-up / not yet built) => don't fail in such case, i.e. allow to auto-configure
            // it via naming conventions if it is uuAppLib
            result = undefined;
            continue;
          }
          if (!main) {
            result = new Error(`Unable to configure URL & naming for external library '${moduleName}'. There is no ${
              moduleName + ".js"
            } file in ${dir + path.sep}
Configure this library in your package.json in uuBuildSettings.externals manually.`);
          } else {
            result.main = main;
            result.mainMinified = mainMinified;
          }
        }
        break;
      }
    }
    if (
      !result &&
      meta.isUuAppLib &&
      (meta.moduleName === meta.json.name || meta.moduleName.startsWith(meta.json.name + "-"))
    ) {
      // NOTE This can happen when having multiple projects in single Git where one
      // depends on another which wasn't built yet. Since it's uuAppLib (built by devkit)
      // assume that it follows naming conventions.
      result = {
        localBaseUri: "target/dist/",
        main: moduleName + ".js",
        mainMinified: moduleName + ".min.js",
      };
    }
    if (!result) {
      result = new Error(`Unable to configure URL & naming for external library '${moduleName}'. There is no ${
        path.resolve(moduleDir, candidates[0]) + path.sep
      } directory with ${moduleName + ".js"} file in it.
Configure this library in your package.json in uuBuildSettings.externals manually.`);
    }
    return result;
  }

  _discoverGlobalVariableNameForModule(meta, entryFilePath) {
    // TODO Remove if possible. Hardcoded for react-dnd-touch-backend because it doesn't have
    // pre-built files for browser in its npm module (use value suitable for our CDN).
    if (meta.moduleName === "react-dnd-touch-backend") return "reactDndTouchBackend";

    if (meta.moduleName === meta.json.name && meta.json.namespace) return meta.json.namespace;
    if (!fs.existsSync(entryFilePath)) return;
    let jsContent = fs.readFileSync(entryFilePath, "utf-8");
    let namespace;
    // assume UMD header, i.e. something like:
    //   if (define.amd) define(["dep", ...], factory);
    //   else if (exports) root[cjsName] = factory(require("dep"), ...);
    //   else root["UU5"]["Bricks"] = factory(root["dep"], ...);     <=== this is what we need (our result should be "UU5.Bricks")
    // alternatively, if minified it looks like:
    //   else a.UU5.Bricks=b(a.dep,...)
    jsContent.replace(/\bdefine\(/, (m, index) => {
      let closingBracketIndex = jsContent.indexOf("}", index);
      let headerContent = jsContent.substr(index, closingBracketIndex);
      let factoryFnName = headerContent.match(/([a-zA-Z0-9_$]+)\s*\)/)[1]; // factory fn name, i.e. last parameter in define(...) call
      let exportVarExpressionRegExpStr = "[.\\[\\]'\"a-zA-Z0-9_$]+"; // for matching root["UU5"]['Bricks']
      let allMatches = headerContent.match(
        new RegExp(exportVarExpressionRegExpStr + "\\s*=\\s*" + factoryFnName + "\\(", "g")
      );
      if (allMatches) {
        let lastMatch = allMatches.pop().match(new RegExp("^(" + exportVarExpressionRegExpStr + ")"))[0];
        let dotParts = lastMatch.split(/\.|\[['"]|(?:['"]\](?:\[['"]|\.|$))/); // e.g. root["UU5"].Bricks => ["root", "UU5", "Bricks"]
        if (dotParts[dotParts.length - 1] === "") dotParts.pop(); // because split transforms: root["UU5"]["Bricks"] => ["root", "UU5", "Bricks", ""]
        if (dotParts.length > 1 && !dotParts.some((part) => part.length === 0)) {
          namespace = dotParts.slice(1).join(".");
          if (namespace.match(/[^a-zA-Z0-9$_.]/)) namespace = undefined; // weird value (file probably does not have UMD header)
        }
      }
    });
    return namespace;
  }

  _estimateGlobalVariableName(libName) {
    return libName
      .replace(/g\d\d/, "")
      .replace(/-(.)/, (m, g) => "." + g.toUpperCase())
      .replace(/-(.)/g, (m, g) => g.toUpperCase())
      .replace(/^uu5(.)/, (m, g) => "UU5." + g.replace(".", "").toUpperCase())
      .replace(/^uu_plus4u5(.)/, (m, g) => "Plus4U5." + g.replace(".", "").toUpperCase())
      .replace(/(?:^|_)(.)/g, (m, g) => g.toUpperCase());
  }

  _toCdnVersion(versionSpecifier, installedVersion = null, isUuAppLib = false) {
    if (!isUuAppLib || this.useCdnExactVersions) return installedVersion || versionSpecifier; // currently, all 3rd-party libs must always be exact

    let match = versionSpecifier.match(/^(?:\^(\d+)|~(\d+\.\d+)|(\d+)\.x|(\d+\.\d+)\.x)/);
    // ^1.2.0 => 1.x
    // ~1.2.0 => 1.2.x
    // 1.x => 1.x
    // 1.2.x => 1.2.x
    // other => exact version
    // TODO Change to the above. We're now mapping inexact to 1.0.0 instead of 1.x / 1.2.x.
    let version;
    if (match) version = match[1] || match[3] ? (match[1] || match[3]) + ".0.0" : (match[2] || match[4]) + ".0";
    else version = installedVersion || versionSpecifier;
    return version;
  }

  _getMeta(packageJson, moduleName = null, ownerMeta = null) {
    let pkg = Package.getSingletonSync(packageJson).get();
    let requestedVersion =
      moduleName && moduleName !== pkg.name && ownerMeta && ownerMeta.moduleName === pkg.name // if moduleName is submodule ("uu5g04-bricks") then use the same requestedVersion as main ("uu5g04")
        ? ownerMeta.requestedVersion
        : ownerMeta && (ownerMeta.json.dependencies || {})[pkg.name]
        ? ownerMeta.json.dependencies[pkg.name]
        : ownerMeta && (ownerMeta.json.devDependencies || {})[pkg.name]
        ? ownerMeta.json.devDependencies[pkg.name]
        : pkg._from
        ? pkg._from.replace(/^[^@]+@/, "")
        : pkg.version;
    requestedVersion = requestedVersion.replace(
      /^https?:[^?]*\/(\d+[^/]*).*/, // some older uuApp modules have a URL to .tgz instead of version specifier in their dependencies
      (m, g) => (g.endsWith(".0.0") ? "^" + g : g)
    );
    return {
      json: pkg,
      path: packageJson,
      isUuAppLib: !!(
        (pkg.spec && pkg.spec.match(/^(uu5-lib|iso-lib|lib)/)) ||
        (!pkg.spec && ("uuBuildSettings" in pkg || (moduleName || pkg.name).match(/^(uu_|uu5|uuappdesignkitg01$)/)))
      ), // uu_* and uu5* for older uu_appg01, uu5mathg01, ... which wouldn't be detected as uuApp libs (they use old template, not devkit)
      moduleName: moduleName || pkg.name,
      requestedVersion: requestedVersion,
      ownerMeta,
    };
  }
};

function* entryNameGenerator(baseName, dir, minified = false) {
  // TODO Remove later. Serves for backward compatibility because entry point for uu_appg01 < 4.0.0 is uu_appg01-base.js.
  if (baseName === "uu_appg01") {
    yield "uu_appg01-base" + (minified ? ".min" : "") + ".js";
  }

  if (minified) {
    yield baseName + ".min.js";
    yield baseName + ".production.min.js";
  } else {
    yield baseName + ".js";
    yield baseName + ".development.js";
  }
  // try additional variants:
  // a) if there's single .js file in folder then take that (e.g. react-dnd-touch-backend has dist/Touch.js)
  // b) if there're only 2 .js files (X.js + X.min.js) then take those (e.g. react-dnd has dist/ReactDnD.js, ReactDnD.min.js)
  let jsFiles = fs
    .readdirSync(dir)
    .filter((fileName) => fileName.endsWith(".js"))
    .sort();
  if (jsFiles.length === 1) yield jsFiles[0];
  else if (jsFiles.length === 2 && jsFiles[1] === jsFiles[0].replace(/\.js$/, ".min.js")) {
    if (minified) yield jsFiles[1];
    else yield jsFiles[0];
  }
}

function isCdnVersionNewer(versionA, versionB, versionAExact = true, versionBExact = true) {
  if (!versionA || !versionB) return undefined;
  if (versionA === versionB) return false;
  // if not exact, consider version such as "3.0.0" as latest 3.x
  let modVersionA = versionAExact ? versionA : versionA.replace(/^(\d+)\.0\.0$/, (m, g1) => g1 + ".999999999999999.0");
  let modVersionB = versionBExact ? versionB : versionB.replace(/^(\d+)\.0\.0$/, (m, g1) => g1 + ".999999999999999.0");
  return semver.gt(modVersionA, modVersionB);
}

function parseVersionFromCdnUri(url) {
  let version;
  let urlVersion = url?.match?.(/(\d+\.\d+\.\d+(-[^/]+)?)/)?.[1];
  if (urlVersion) {
    let urlRangeMatch = urlVersion.match(/^(\d+)\.0\.0$/);
    let is3rdParty = url.slice(0, url.indexOf(urlVersion)).includes("/libs/");
    if (!is3rdParty && urlRangeMatch) {
      version = urlRangeMatch[1] + ".x";
    } else if (semver.valid(urlVersion)) {
      version = urlVersion;
    }
  }
  return version;
}
