// import/export from **/lsi.js, **/*-lsi.js files

const fs = require("fs-extra");
const path = require("path");
const util = require("util");
const readDir = util.promisify(fs.readdir);
const stat = util.promisify(fs.stat);
const readFile = util.promisify(fs.readFile);
const writeFile = util.promisify(fs.writeFile);
const { Parser } = require("acorn");
const walk = require("acorn-walk");
const escodegen = require("escodegen");

const LSI = "lsi.js";
const LSI_SUFFIX = `-${LSI}`;
const SKIP_FOLDERS_REGEXP = /^(node_modules|target)$/;

class LsiInJsExporter {
  constructor(opts = {}) {
    this.sourcePath = opts.sourcePath;
    this.labelSeparator = opts.labelSeparator;
  }

  async export(registry) {
    let { sourcePath, labelSeparator } = this;

    let lsiPaths = await this._getLsiPaths(sourcePath);
    for (let lsiPath of lsiPaths) {
      console.log(`Parsing ${lsiPath}`);
      let sourceCode = await readFile(lsiPath, "utf-8");
      let ast;
      try {
        ast = Parser.parse(sourceCode, { sourceType: "module", ecmaVersion: 2020 });
      } catch (e) {
        console.log(`WARNING! skipping lsi file ${lsiPath}, reason: invalid file syntax`);
        continue;
      }
      let innerMostObjects = this._getInnerMostObject(ast);
      let oneFileRegistry = this._processLsiFile(ast, innerMostObjects, lsiPath, labelSeparator);
      if (oneFileRegistry) {
        for (let item of oneFileRegistry) registry.addItem(...item);
      }
    }
  }

  async _getLsiPaths(pth) {
    let arr = await readDir(pth);
    let result = [];
    for (let file of arr) {
      if (SKIP_FOLDERS_REGEXP.test(file)) {
        continue;
      }
      let subPath = path.join(pth, file);
      let fileStat = await stat(subPath);
      if (fileStat.isDirectory()) {
        let partialRes = await this._getLsiPaths(subPath);
        result.push(...partialRes);
      } else if (file.endsWith(LSI_SUFFIX) || file === LSI) {
        result.push(path.join(pth, file));
      }
    }
    return result;
  }

  _processLsiFile(fileAst, innerMostObjects, lsiPath, labelSeparator) {
    let items = [];
    for (let innerMostObject of innerMostObjects) {
      let chain = this._getObjectExpressionHierarchy(fileAst, innerMostObject);
      let label = chain.join(labelSeparator);
      // if the label is an empty string or undefined, then the object is not an lsi object
      if (!label) {
        continue;
      }

      // same labels in one file are undesirable
      if (items.find((it) => it[0] === lsiPath && it[1] === label)) {
        console.log(`WARNING! skipping lsi file ${lsiPath}, reason: lsi objects with ambiguous labeling`);
        return null;
      }

      let lsi = {};
      for (let property of innerMostObject.properties) {
        let language = property.key.name || property.key.value;
        let leafNode = property.value;
        if (leafNode.type === "TemplateLiteral") {
          let literalString = "";
          for (let i = 0; i < leafNode.quasis.length; i++) {
            literalString = `${literalString}${leafNode.quasis[i].value.raw}`;
            let expression = leafNode.expressions[i];
            if (expression) {
              literalString = `${literalString}\${${expression.name}}`;
            }
          }
          lsi[language] = `\`${literalString}\``;
        } else if (leafNode.type === "Literal") {
          lsi[language] = property.value.value;
        }
      }

      items.push([lsiPath, label, lsi]);
    }
    return items;
  }

  // takes an innermost object node and search for its outer object nodes
  // as long as they are there, return an array of them starting from the
  // outermost and ending with the innermost
  //
  // example:
  // assuming source code { alpha: { beta: { cs: "some stuff" } } };
  // then innermostObjectNode is an AST representation of { cs: "some stuff" } object
  // and _getObjectExpressionHierarchy returns [alpha, beta]
  _getObjectExpressionHierarchy(fileAst, innermostObjectNode) {
    let res = [];
    let pos = innermostObjectNode.start - 1;
    let childNode = innermostObjectNode;
    let findRes;
    while ((findRes = walk.findNodeAround(fileAst, pos, "ObjectExpression"))) {
      for (let property of findRes.node.properties) {
        if (property.value === childNode) {
          // key.name for Identifier, i.e. {a:1}, key.value for Literal, i.e. {"a":1}
          res.unshift(property.key.name || property.key.value);
        }
      }

      childNode = findRes.node;
      pos = findRes.node.start - 1;
    }

    return res;
  }

  _getInnerMostObject(ast) {
    let innerMostObjects = [];
    walk.simple(ast, {
      ObjectExpression: (node) => {
        if (this._isInnermostObject(node)) {
          innerMostObjects.push(node);
        }
      },
    });
    return innerMostObjects;
  }

  _isInnermostObject(node) {
    if (node.type !== "ObjectExpression") {
      return false;
    }
    for (let property of node.properties) {
      if (!property.value || (property.value.type !== "Literal" && property.value.type !== "TemplateLiteral")) {
        return false;
      }
    }
    return true;
  }
}

class LsiInJsImporter {
  constructor(opts = {}) {
    this.baseSourcePath = opts.baseSourcePath;
    this.labelSeparator = opts.labelSeparator;
  }

  async import(filePath, itemList) {
    let fileName = path.basename(filePath);
    if (!fileName.endsWith(LSI_SUFFIX) && fileName !== LSI) return false; // not importable by this importer

    let { baseSourcePath, labelSeparator } = this;
    let absolutePath = path.resolve(baseSourcePath, filePath);
    console.log(`Importing to ${absolutePath}`);
    let sourceCode;
    try {
      sourceCode = await readFile(absolutePath, "utf-8");
    } catch (e) {
      console.log(`WARNING! lsi file ${absolutePath} does not exist, hence it can not be imported`);
      return true;
    }

    let ast;
    try {
      ast = Parser.parse(sourceCode, { sourceType: "module", ecmaVersion: 2020 });
    } catch (e) {
      console.log(`ERROR! Could not parse lsi file ${filePath}`, e);
      return true;
    }
    for (let { label, lsi } of itemList) {
      let node = this._getLsiNode(ast, label, labelSeparator);
      node && this._replaceLsi(node, lsi);
    }

    try {
      let sourceCode = escodegen.generate(ast);
      await writeFile(absolutePath, sourceCode, "utf-8");
    } catch (e) {
      console.log(`ERROR! import of lsi file ${absolutePath} failed: ${e}`);
    }

    return true;
  }

  _replaceLsi(node, lsiObject) {
    node.properties = [];
    for (let [language, text] of Object.entries(lsiObject)) {
      if (text) {
        let property = {
          type: "Property",
          method: false,
          shorthand: false,
          computed: false,
          key: {
            type: "Literal",
            value: language,
          },
          kind: "init",
        };
        if (text.startsWith("`") && text.endsWith("`")) {
          text = text.slice(1).slice(0, text.length - 2);
          property.value = {
            type: "TemplateLiteral",
            expressions: [],
            quasis: [
              {
                type: "TemplateElement",
                value: {
                  raw: text,
                  cooked: text,
                },
                tail: true,
              },
            ],
          };
        } else {
          property.value = {
            type: "Literal",
            value: text,
            raw: `"${text}"`,
          };
        }
  
        node.properties.push(property);
      }
    }
  }

  // find the lsi node according to its label
  _getLsiNode(ast, label, labelSeparator) {
    let parts = label.split(labelSeparator);
    let found = false;
    let theChosenOne = null;
    walk.ancestor(ast, {
      // only ObjectExpression are interesting
      ObjectExpression(node, ancstrs) {
        // already found one
        if (found) {
          return;
        }
        // acorn-walk uses the `ancstrs` array internally (do not modify)
        // node is also the last entry in ancestors => `j` starts from length-2
        for (let i = parts.length - 1, j = ancstrs.length - 2; i >= 0; i--, j--) {
          // the closest ancestor has to be a property and it has to be labeled correctly
          let property = ancstrs[j];
          if (property.type !== "Property" || (property.key.name !== parts[i] && property.key.value !== parts[i])) {
            return;
          }
          // the second closest ancestors has to be an object
          let objectExpression = ancstrs[--j];
          if (objectExpression.type !== "ObjectExpression") {
            return;
          }
        }
        // happiness!
        found = true;
        theChosenOne = node;
      },
    });
    return theChosenOne;
  }
}

module.exports = {
  LsiInJsExporter,
  LsiInJsImporter,
};
