// import/export from **/lsi/en.json, *.json files

const fs = require("fs-extra");
const path = require("path");
const util = require("util");

const readDir = util.promisify(fs.readdir);
const stat = util.promisify(fs.stat);
const readFile = util.promisify(fs.readFile);
const writeFile = util.promisify(fs.writeFile);
const ensureDir = util.promisify(fs.ensureDir);
const { fileExists } = require("../../tools/helpers.js");

const SKIP_FOLDERS_REGEXP = /^(node_modules|target)$/;

class LsiInJsonExporter {
  constructor(opts = {}) {
    this.sourcePath = opts.sourcePath;
    this.labelSeparator = opts.labelSeparator;
  }

  async export(registry) {
    let { sourcePath, labelSeparator } = this;

    let lsiFolders = await this._getLsiFolders(sourcePath);
    for (let { folderPath, fileList } of lsiFolders) {
      console.log(`Parsing ${folderPath}${path.sep}*.json`);
      let itemMap = {}; // key => lsi object, e.g. { "formHeader": { en: ..., cs: ... } }
      try {
        await Promise.all(
          fileList.map(async (fileName) => {
            let fileContent = await readFile(path.join(folderPath, fileName), "utf-8");
            let json;
            try {
              json = JSON.parse(fileContent);
            } catch (e) {
              let err = new Error("Invalid JSON in file: " + fileName);
              err.stack = "";
            }
            let language = fileName.slice(0, -".json".length); // remove ".json"
            this._processLsiFile(json, language, itemMap, labelSeparator);
          })
        );
      } catch (e) {
        console.log(`WARNING! Skipping lsi folder ${folderPath}${path.sep}, reason: ${e}`);
        continue;
      }
      for (let [key, lsi] of Object.entries(itemMap)) {
        registry.addItem(folderPath, key, lsi);
      }
    }
  }

  async _getLsiFolders(pth) {
    let arr = await readDir(pth);
    let result = [];
    for (let file of arr) {
      if (SKIP_FOLDERS_REGEXP.test(file)) {
        continue;
      }
      let subPath = path.join(pth, file);
      let fileStat = await stat(subPath);
      if (fileStat.isDirectory()) {
        if (file === "lsi") {
          let fileList = (await readDir(subPath)).filter((it) => it.endsWith(".json"));
          result.push({ folderPath: subPath, fileList });
        } else {
          let partialRes = await this._getLsiFolders(subPath);
          result.push(...partialRes);
        }
      }
    }
    return result;
  }

  _processLsiFile(fileJson, language, itemMap, labelSeparator) {
    this._walkObject(fileJson, (keyChain, value) => {
      if (typeof value !== "object") {
        let label = keyChain.join(labelSeparator);
        if (!itemMap[label]) itemMap[label] = {};
        itemMap[label][language] = value;
      }
    });
  }

  _walkObject(obj, callback) {
    let keyChain = [];
    function doWalk(obj) {
      if (typeof obj === "object" && obj) {
        for (let k in obj) {
          keyChain.push(k);
          let result = callback(keyChain, obj[k]);
          if (result !== false) doWalk(obj[k]);
          keyChain.pop();
        }
      }
    }
    return doWalk(obj);
  }
}

class LsiInJsonImporter {
  constructor(opts = {}) {
    this.baseSourcePath = opts.baseSourcePath;
    this.labelSeparator = opts.labelSeparator;
  }

  async import(filePath, itemList) {
    if (!filePath.match(/(^|[/\\])lsi$/)) return false; // only paths ending with /lsi are importable by this importer

    let { baseSourcePath, labelSeparator } = this;
    let targetFolder = path.resolve(baseSourcePath, filePath);
    console.log(`Importing to ${targetFolder}${path.sep}*.json`);
    let jsonsByLanguage = {};
    for (let { label, lsi } of itemList) {
      let labelKeys = label.split(labelSeparator);
      for (let [language, value] of Object.entries(lsi)) {
        if (!jsonsByLanguage[language]) {
          let targetFile = path.join(targetFolder, language + ".json");
          let initialValue = {};
          if (await fileExists(targetFile)) {
            let content = await readFile(targetFile, "utf-8");
            try {
              initialValue = (content ? JSON.parse(content) : null) || {};
            } catch (e) {
              throw new Error(`Unable to parse existing JSON in ${targetFile}: ${e}`);
            }
          }
          jsonsByLanguage[language] = initialValue;
        }
        if (value != null && value !== "") {
          this._defineKey(jsonsByLanguage[language], labelKeys, value);
        }
      }
    }

    // write files (en.json, ...) into target folder
    await ensureDir(targetFolder);
    for (let [language, lsiStructure] of Object.entries(jsonsByLanguage)) {
      let targetFile = path.join(targetFolder, language + ".json");
      let content = JSON.stringify(lsiStructure, null, 2) + "\n";
      await writeFile(targetFile, content, "utf-8");
    }

    return true;
  }

  _defineKey(targetObject, keyChain, value) {
    let obj = targetObject;
    for (let i = 0; i < keyChain.length - 1; i++) {
      let k = keyChain[i];
      if (!obj[k]) obj[k] = {};
      if (typeof obj[k] !== "object") {
        console.warn(
          `WARNING! Changed key '${keyChain.slice(0, i + 1).join(".")}' to an object, original value: ${obj[k]}`
        );
        obj[k] = {};
      }
      obj = obj[k];
    }
    obj[keyChain[keyChain.length - 1]] = value;
  }
}

module.exports = {
  LsiInJsonExporter,
  LsiInJsonImporter,
};
