const fs = require("fs-extra");
const path = require("path");
const util = require("util");
const stat = util.promisify(fs.stat);
const readFile = util.promisify(fs.readFile);
const writeFile = util.promisify(fs.writeFile);
const ensureDir = util.promisify(fs.ensureDir);
const callbackStringify = require("csv-stringify").stringify;
const stringify = util.promisify(callbackStringify);
const parseCallback = require("csv-parse").parse;
const csvParse = util.promisify(parseCallback);
const { fileExists } = require("../../tools/helpers");
const { LsiInJsExporter, LsiInJsImporter } = require("./lsi-in-js.js");
const { LsiInJsonExporter, LsiInJsonImporter } = require("./lsi-in-json.js");

const DEFAULT_EXPORT_FOLDER = "target";
const DEFAULT_EXPORT_FILE = "lsi-export.csv";
const FILE = "file";
const LABEL = "label";

const stringifyOptions = {
  delimiter: ';',
  quoted: true
};

const parseOptions = { 
  relax: true, 
  relax_column_count: true,
  delimiter: ';',
  quoted: true
 };

// the 8204 is an arbitrary whitespace character, because why not..
const LABEL_SEPARATOR = `${String.fromCodePoint(8204)}.${String.fromCodePoint(8204)}`;

class LsiExporter {
  constructor(opts = {}) {
    this.baseSourcePath = opts.baseSourcePath || process.cwd();
    this.sourcePath = path.resolve(this.baseSourcePath, opts.relativeSourcePath || "");
    let relativeTargetPath = opts.relativeTargetPath || path.join(DEFAULT_EXPORT_FOLDER, DEFAULT_EXPORT_FILE);
    this.targetPath = path.resolve(this.baseSourcePath, relativeTargetPath);
    this.labelSeparator = LABEL_SEPARATOR;
  }

  async process() {
    let { sourcePath, targetPath, baseSourcePath, labelSeparator } = this;

    // check there is something to scan at all (even though no distinction between file and folder is made,
    // so one could try to scan a file if he is brave enough..)
    if (!(await fileExists(sourcePath))) {
      console.log(`${sourcePath} does not exist. Aborting script.`);
      return;
    }

    // stuff it all into the memory
    let registry = {
      relPathCache: {},
      languages: {},
      itemList: [],
      addItem(labelSourcePath, label, lsiObject) {
        let { languages, itemList, relPathCache } = registry;
        let langValueList = new Array(Object.keys(languages).length);
        for (let [lang, value] of Object.entries(lsiObject)) {
          let langIndex = languages[lang];
          if (langIndex === undefined) langIndex = languages[lang] = Object.keys(languages).length;
          langValueList[langIndex] = value;
        }
        let relPath =
          relPathCache[labelSourcePath] ||
          (relPathCache[labelSourcePath] = path.relative(
            path.resolve(baseSourcePath),
            path.resolve(sourcePath, labelSourcePath)
          ));
        itemList.push([relPath, label, ...langValueList]);
      },
    };
    await new LsiInJsExporter({ sourcePath, labelSeparator }).export(registry);
    await new LsiInJsonExporter({ sourcePath, labelSeparator }).export(registry);

    // add the header
    registry.itemList.unshift([FILE, LABEL, ...Object.keys(registry.languages)]);

    // generate output (is all the handling of missing folders really that necessary if devkit will be the only one calling it?)
    let targetDir = path.dirname(targetPath);
    if (!(await fileExists(targetDir))) {
      console.log(`Creating ${targetDir}`);
      await ensureDir(targetDir);
    }
    if ((await fileExists(targetPath)) && (await stat(targetPath)).isDirectory()) {
      targetPath = path.join(targetPath, DEFAULT_EXPORT_FILE);
    }
    let csvMegaString = await stringify(registry.itemList, stringifyOptions);
    console.log("Generating CSV file");
    try {
      await writeFile(targetPath, csvMegaString, "utf-8");
    } catch (e) {
      console.log(`CSV could not be exported, reason: ${e}`);
      return;
    }
    console.log(`Lsi exported to ${targetPath}`);
  }
}

class LsiImporter {
  constructor(opts = {}) {
    this.baseSourcePath = opts.baseSourcePath || process.cwd();
    let relativeCsvPath = opts.relativeTargetPath || path.join(DEFAULT_EXPORT_FOLDER, DEFAULT_EXPORT_FILE);
    this.csvPath = path.resolve(this.baseSourcePath, relativeCsvPath);
    this.labelSeparator = LABEL_SEPARATOR;
  }

  async process() {
    let { csvPath, baseSourcePath, labelSeparator } = this;
    console.log("Parsing CSV file");
    if (!(await fileExists(csvPath))) {
      console.log(`CSV file ${csvPath} does not exist. Aborting script.`);
      return;
    }
    let itemsByFileMap = await this._getItemsByFileMap(csvPath);

    console.log("Importing lsi files");
    let importers = [
      new LsiInJsImporter({ baseSourcePath, labelSeparator }),
      new LsiInJsonImporter({ baseSourcePath, labelSeparator }),
    ];
    for (let [filePath, items] of Object.entries(itemsByFileMap)) {
      let imported = false;
      for (let importer of importers) {
        if (await importer.import(filePath, items)) {
          imported = true;
          break;
        }
      }
      if (!imported) {
        console.warn(`WARNING! Unable to import ${items.length} lsis for file: ${filePath}`);
      }
    }

    console.log("Finished");
  }

  async _getItemsByFileMap(csvPath) {
    let csvFile = await readFile(csvPath, "utf-8");
    let csvItems = await csvParse(csvFile, parseOptions);
    let csvHeaderItem = csvItems.shift();
    let itemsByFileMap = {};
    for (let csvItem of csvItems) {
      let [filePath, label] = csvItem;
      let lsi = {};
      for (let i = 2; i < csvItem.length; i++) lsi[csvHeaderItem[i]] = csvItem[i];
      let itemsByFile = itemsByFileMap[filePath];
      if (!itemsByFile) itemsByFile = itemsByFileMap[filePath] = [];
      itemsByFile.push({ label, lsi });
    }
    return itemsByFileMap;
  }
}

module.exports = {
  LsiExporter,
  LsiImporter,
};
