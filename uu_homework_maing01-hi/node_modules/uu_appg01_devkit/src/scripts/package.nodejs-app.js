const fs = require("fs");
const path = require("path");

const paths = require("../config/paths.js");
const zip = require("../tools/zip.js");
const UuCloudConfig = require("./uu_cloud/uu-cloud-config");
const Pack = require("uu_appg01_devkit-common/src/tools/package.js");
const helpers = require("../tools/helpers.js");

const DEFAULT_FILES = ["app.js", "package.json", "app", "config", "env", "public", ".npmrc"];

module.exports = class Package {

  constructor(config) {
    this.config = config;
  }

  async process() {
    // Ensure project is built before packaging
    await helpers.exec("npm run --loglevel=error build -- " + this.config.toCommandLineArgs().join(" ")); // TODO Escaping.
    Pack.getSingletonSync("package.json").loadSync(); // reload as version might have changed

    let pkg = Pack.getSingletonSync("package.json").get();
    let uuCloudConfig = new UuCloudConfig(path.resolve("."), pkg.name, pkg.version, paths.buildDir, this.config);

    console.log("Creating uuCloud descriptor.");
    let descriptorPath = uuCloudConfig.generateCloudDescriptor();
    const uuSubAppDescriptor = uuCloudConfig.updateUuSubAppDescriptor();
    uuCloudConfig.updateAsidDescriptor(uuSubAppDescriptor);

    console.log("  " + descriptorPath);

    console.log("Creating metamodel zip archive(s).");
    await this._createMetaModelZipArchieves(uuCloudConfig);

    console.log("Creating App package.");
    let projectName = pkg.name;
    let projectVersion = uuCloudConfig.getQualifiedVersion();
    let qualifiedAppName = `${projectName}-${projectVersion}`;
    let appPackagePath = path.join(paths.buildDir, `${qualifiedAppName}.zip`);
    let packFiles = new Set([...DEFAULT_FILES, ...(pkg.files || [])]);
    if (this._includePackageLock()) {
      packFiles.add("package-lock.json");
    }
    await zip(appPackagePath, appPackage => {
      for (let packFile of Array.from(packFiles)) {
        if (this._fileExists(packFile)) {
          if (this._isDirectory(packFile)) {
            appPackage.directory(`${packFile}/`, `${qualifiedAppName}/${packFile}`);
          } else {
            appPackage.file(packFile, {name: `${qualifiedAppName}/${packFile}`});
          }
        }
      }
    });
    console.log("  " + appPackagePath);
  }

  async _createMetaModelZipArchieves(uuCloudConfig) {
    const metaModelRootDir = uuCloudConfig.metaModelRootDir;
    const uuBtMetaModelDir = uuCloudConfig.uuBtMetaModelDir;
    const uuMtMetaModelDir = uuCloudConfig.uuMtMetaModelDir;

    if (!metaModelRootDir) {
      console.log("Warning: Meta model directory is missing");
      return;
    }
    if (fs.readdirSync(metaModelRootDir).length == 0) {
      console.log("Warning: Meta model file is missing");
      return;
    }

    const uuBtMetaModelZip = path.resolve(metaModelRootDir, "..", "metamodel_uu-businessterritory-maing01.zip");
    const uuMtMetaModelZip = path.resolve(metaModelRootDir, "..", "metamodel_uu-myterritory-maing01.zip");
    
    if (!uuBtMetaModelDir && !uuMtMetaModelDir) {
      console.log(
        "Warning: Meta model directory contains neither the uuBusinessTerritory nor the uuMyTerritory folder.\n" +
        "  Contents of meta model directory will be archieved as uuBusinessTerritory meta model.\n" +
        "  " + await this._createZip(metaModelRootDir, uuBtMetaModelZip)
      );
      return;
    }

    if (uuBtMetaModelDir) {
      if (fs.readdirSync(uuBtMetaModelDir).length == 0) {
        console.log("Warning: Meta model file for uuBusinessTerritory is missing");
      } else {
        console.log("  " + await this._createZip(uuBtMetaModelDir, uuBtMetaModelZip));
      }
    }
    if (uuMtMetaModelDir) {
      if (fs.readdirSync(uuMtMetaModelDir).length == 0) {
        console.log("Warning: Meta model file for uuMyTerritory is missing");
      } else {
        console.log("  " + await this._createZip(uuMtMetaModelDir, uuMtMetaModelZip));
      }
    }
  }

  async _createZip(sourceDir, outputPath) {
    const zip = require("../tools/zip");
    const dataPath = path.relative(".", outputPath);
    await zip(dataPath, (archive) => {
      archive.directory(sourceDir, "metamodel");
    });
    return dataPath;
  }

  _fileExists(file) {
    return fs.existsSync(`./${file}`);
  }

  _isDirectory(file) {
    return fs.lstatSync(`./${file}`).isDirectory();
  }

  _includePackageLock() {
    let packageLock = this.config.commandLineConfig.packageLock;
    if (!packageLock) {
      let appBoxPackageLock;
      const devkit = this.config.get("devkit");
      const mode = this.config.getUsedMode();
      appBoxPackageLock = devkit[mode]?.appBoxPackageLock;
      if (!appBoxPackageLock) {
        appBoxPackageLock = this.config.get("appBoxPackageLock");
      }
      packageLock = appBoxPackageLock ? appBoxPackageLock : "omitted";
    }
    return packageLock == "included";
  }
};
