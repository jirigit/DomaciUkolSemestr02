"use strict";

const Cp = require("child_process");
const Got = require("got");
const Path = require("path");
const Fs = require("fs-extra");
const paths = require("../config/paths.js");

const COMPONENT_REPORT_CHUNK_SIZE = 128;
const COMPONENT_REPORT_URL = "https://ossindex.sonatype.org/api/v3/component-report";
const COMPONENT_REPORT_HEADERS = { "Accept": "application/vnd.ossindex.component-report.v1+json", "Content-Type": "application/vnd.ossindex.component-report-request.v1+json" };

const ALLOWED_OUTPUT_FORMATS = ["HTML", "XML", "CSV", "JSON", "JUNIT", "ALL", "SARIF", "JENKINS"];
const DEFAULT_OUTPUT_FORMAT = ["JSON"];
const PROVIDER_OWASP = "owaspDependencyCheck";
const PROVIDER_SONATYPE = "sonatypeOSSIndex";

module.exports = class VulnerabilityScan {

  constructor(config) {
    this.config = config;
  }

  async process() {
    this._checkRequiredProvider();

    if (this._isSonatypeReportRequired()) { //XXX this relies on the fact that if Sonatype is not specified, OWASP is always used
      console.log("Warning: The Sonatype OSS Index is deprecated and may be removed in a future release of uuAppDevKit.");

      let formats = this._getOutputFormats();
      if (!(formats.length == 1 && formats.includes("json"))) {
        console.log("Warning: For provider Sonatype OSS Index, the only supported format is JSON, other formats will not be generated.");
      }

      await this._sonatypeReport();
    } else {
      await this._dependencyCheckReport();
    }
  }

  async _dependencyCheckReport() {
    const reportFolder = Path.resolve(Path.join(paths.buildDir, "owasp-report"));
    //console.log(`folder for owasp report: ${reportFolder}`);

    const owaspBinFolder = Path.resolve(Path.join(paths.buildDir, "owasp-bin"));
    //console.log(`folder for owasp bin files: ${owaspBinFolder}`);

    await Fs.mkdirpSync(Path.dirname(reportFolder));
    const cmd = `owasp-dependency-check --disableYarnAudit --disableNodeAudit ${this._getDisabledDevDependenciesParams()} --bin=\"${owaspBinFolder}\" --out=\"${reportFolder}\" --scan=\"${process.cwd()}\" ${this._getOutputFormatParameters()}`;
    //console.log(`Command line: ${cmd}`);

    console.log("Generating reports using the Dependency Check tool...");
    let success = false;
    await new Promise((resolve, reject) => {
      Cp.exec(cmd, {}, (err, stdout, stderr) => {
        if (stderr) {
          console.error(stderr);
        }

        if (err) {
          console.error(err);
          reject(err);
        } else {
          resolve(stdout);
        }

        success = !stderr && !err;
      });
    })

    this._reformatContent(reportFolder);
    this._moveContentToParent(reportFolder);
    this._deleteFolder(reportFolder);
    if (success) {
      console.log("Report creation completed.");
    } else {
      console.log("Report creation failed.");
    }
  }

  _reformatContent(folder) {
    try {
      Fs.readdirSync(folder).forEach(filename => {
        if (filename.toLowerCase().endsWith(".json")) {
          let filepath = Path.resolve(folder, filename);
          this._reformatJsonFile(filepath);
        }
      });
    } catch (e) {
      console.log("Failed to reformat JSON content generated from the Dependency Check tool. Exception: " + e);
    }
  }

  _reformatJsonFile(filepath) {
    if (filepath.toLowerCase().endsWith(".json")) {
      let content = Fs.readJSONSync(filepath);
      Fs.writeFileSync(filepath, JSON.stringify(content, null, 2));
    }
  }

  _moveContentToParent(folder) {
    try {
      Fs.readdirSync(folder).forEach(filename => {
        let source = Path.resolve(folder, filename);
        let target = Path.resolve(folder, "..", filename);
        Fs.moveSync(source, target, { overwrite: true });
      });
    } catch (e) {
      console.log("Failed to move Dependency Check report(s) to folder with reports. Exception: " + e);
    }
  }

  _deleteFolder(folder) {
    try {
      Fs.removeSync(folder);
    } catch (e) {
      console.log("Failed to delete (it's expected to be empty) folder \"" + folder + "\". Exception: " + e);
    }
  }

  /* The OWASP DC documentation for NPM is wrong. The formats cannot be specified 
   * as "-f FORMAT1 FORMAT2 FORMAT3", it must be specified like "-f FORMAT1 -f FORMAT2 -f FORMAT3".
   * https://www.npmjs.com/package/owasp-dependency-check */
  _getOutputFormatParameters() {
    let formats = this._getOutputFormats();
    let result = "-f " + formats.join(" -f ");
    return result;
  }

  _getOutputFormats() {
    let result = DEFAULT_OUTPUT_FORMAT; // this is the default option if there is no specific format required by user

    let parOutputFormat = this.config.commandLineConfig.outputFormat;
    if (parOutputFormat) {
      result = parOutputFormat.toUpperCase().split(",");
      result = result.filter(value => {
        let isIncluded = ALLOWED_OUTPUT_FORMATS.includes(value)
        if (!isIncluded) {
          console.log(`Warning: Format ${value} was not recognized and will be skipped.`);
        }
        return isIncluded;
      });

      if (result.length == 0) {
        console.log(`Warning: No supported format specified, the default (${DEFAULT_OUTPUT_FORMAT}) will be used.`);
        result = DEFAULT_OUTPUT_FORMAT;
      }
    }

    return result;
  }

  _checkRequiredProvider() {
    const awailableProviders = [PROVIDER_SONATYPE, PROVIDER_OWASP];
    let providers = awailableProviders.map(item => item.toLowerCase());

    let parProvider = this.config.commandLineConfig.provider;
    if (parProvider && !providers.includes(parProvider.toLowerCase())) {
      console.log(`Warning: The specified provider (${parProvider}) is not supported, the default will be used. The valid providers are: ${awailableProviders}`);
    }
  }

  _isSonatypeReportRequired() {
    let result = false;
    let parProvider = this.config.commandLineConfig.provider;
    if (parProvider) {
      result = parProvider.toLowerCase() === PROVIDER_SONATYPE.toLowerCase();
    }
    return result;
  }

  _getDisabledDevDependenciesParams() {
    // https://jeremylong.github.io/DependencyCheck/dependency-check-cli/arguments.html
    let result = "";
    if (!this._isDevDependenciesEnabled()) {
      result = "--nodeAuditSkipDevDependencies --nodePackageSkipDevDependencies";
    }
    return result;
  }

  _isDevDependenciesEnabled() {
    let result = this.config.commandLineConfig.devDependencies && this.config.commandLineConfig.devDependencies === "true";
    return result;
  }

  async _sonatypeReport() {
    let skipDevelopment = !this._isDevDependenciesEnabled();
    console.log("Checking project dependencies.");
    let projectNpmInfo = await new Promise(function (resolve, reject) {
      console.log(" ...loading dependencies");
      Cp.exec("npm ls --long --all --json", { maxBuffer: 100 * 1024 * 1024 }, (err, stdout) => {
        try {
          resolve(JSON.parse(stdout));
        } catch (e) {
          reject(e);
        }
      });
    });
    let libraryData = this._processNpmInfo(projectNpmInfo);
    let projectDependencies = {};
    for (let [dependencyName, dependencyData] of Object.entries(projectNpmInfo.dependencies)) {
      projectDependencies[dependencyName] = dependencyData.version;
    }
    let projectDevDependencies = projectNpmInfo.devDependencies;
    let parsedDependencies = this._parseDependencies(libraryData, projectDependencies, projectDevDependencies, skipDevelopment);
    let dependencyList = Object.keys(parsedDependencies);
    console.log(` ...scanning ${dependencyList.length} libraries`);

    let i, chunk, scanned = 0;
    for (i = 0; i < dependencyList.length; i += COMPONENT_REPORT_CHUNK_SIZE) {
      chunk = dependencyList.slice(i, i + COMPONENT_REPORT_CHUNK_SIZE);
      let partialReport = await this._getComponentReport(chunk);
      for (let componentReport of partialReport) {
        let coordinate = decodeURIComponent(componentReport.coordinates);
        let dependency = parsedDependencies[coordinate];
        if (componentReport.description && !dependency.description) {
          dependency.description = componentReport.description;
        }
        if (componentReport.vulnerabilities.length > 0) {
          dependency.vulnerabilities = componentReport.vulnerabilities;
        }
      }
      scanned += chunk.length;
      console.log(` ...${scanned} libraries scanned`);
    }
    console.log(` ...scan complete`);

    let dependencyReport = Path.resolve(Path.join(paths.buildDir, "vulnerability_scan_report.json"));
    console.log(`\nGenerating report.`);
    Fs.mkdirpSync(Path.dirname(dependencyReport));
    Fs.writeFileSync(dependencyReport, JSON.stringify(parsedDependencies, null, 2));
    console.log(` => file://${Path.resolve(".", dependencyReport)}\n`)
  }

  _processNpmInfo(npmInfo, result = {}) {
    if (!npmInfo || !npmInfo.dependencies) {
      return result;
    }

    for (let [dependencyName, dependencyData] of Object.entries(npmInfo.dependencies)) {
      let dependencyVersion = dependencyData.version;
      if (!dependencyVersion) {
        continue;
      }

      let libraryVersionMap = result[dependencyName];
      if (!libraryVersionMap) {
        libraryVersionMap = {};
        result[dependencyName] = libraryVersionMap;
      }
      let libraryData = libraryVersionMap[dependencyVersion];
      if (!libraryData) {
        libraryData = { devDependencies: [], dependencies: {} };
        libraryVersionMap[dependencyVersion] = libraryData;
      }

      if (!libraryData.description) {
        if (dependencyData.description != null) {
          libraryData.description = dependencyData.description;
        } else if (dependencyData.path) {
          // TODO Npm 8 does not provide description directly, we have to parse it from package.json
          let packageJson = Path.join(dependencyData.path, "package.json");
          if (Fs.existsSync(packageJson)) {
            libraryData.description = JSON.parse(Fs.readFileSync(packageJson)).description;
          }
        }
      }
      if (dependencyData.license) {
        libraryData.license = dependencyData.license;
      }
      if (dependencyData.devDependencies) {
        libraryData.devDependencies.push(...Object.keys(dependencyData.devDependencies));
      }
      if (dependencyData.dependencies) {
        for (let [nestedDependencyName, nestedDependencyData] of Object.entries(dependencyData.dependencies)) {
          libraryData.dependencies[nestedDependencyName] = nestedDependencyData.version;
        }
      }
      this._processNpmInfo(dependencyData, result);
    }
    return result;
  }

  _parseDependencies(libraryData, dependencies, devDependencies, skipDevelopment, result = {}, from = null, path = []) {
    if (!dependencies) {
      return result;
    }
    for (let [pkgName, pkgVersion] of Object.entries(dependencies)) {
      let dependency = libraryData[pkgName] && libraryData[pkgName][pkgVersion];
      if (!dependency || path.includes(pkgName)) {
        continue;
      }
      if (skipDevelopment && devDependencies && devDependencies[pkgName]) {
        continue;
      }
      let coordinate = `pkg:npm/${pkgName.replace(/^@/, "")}@${pkgVersion}`;
      let prevDependency = result[coordinate];
      if (!prevDependency || (prevDependency.level > path.length)) {
        result[coordinate] = {
          level: path.length,
          from: from || "ROOT",
          license: dependency.license || null,
          description: dependency.description || null,
          vulnerabilities: null
        };
      }
      this._parseDependencies(libraryData, dependency.dependencies, dependency.devDependencies, skipDevelopment, result, coordinate, [...path, pkgName]);
    }
    return result;
  }

  async _getComponentReport(dependencyList) {
    let body = JSON.stringify({ coordinates: dependencyList });
    let result = await Got(COMPONENT_REPORT_URL, {
      headers: COMPONENT_REPORT_HEADERS,
      method: "post",
      body: body
    });
    return JSON.parse(result.body);
  }

};
