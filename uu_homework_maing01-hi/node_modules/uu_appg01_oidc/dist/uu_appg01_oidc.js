/*!
 * Copyright (c) 2019 Unicorn a.s.
 * All rights reserved.
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("module"), require("uu_appg01_core"));
	else if(typeof define === 'function' && define.amd)
		define("uu_appg01_oidc", ["module", "uu_appg01_core"], factory);
	else if(typeof exports === 'object')
		exports["uu_appg01_oidc"] = factory(require("module"), require("uu_appg01_core"));
	else
		root["UuApp"] = root["UuApp"] || {}, root["UuApp"]["Oidc"] = factory(root["undefined"], root["UuApp"]);
})(this, (__WEBPACK_EXTERNAL_MODULE_module__, __WEBPACK_EXTERNAL_MODULE_uu_appg01_core__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./browser/authentication-service.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  AuthenticationService: CoreAuthenticationService,
  InvalidCredentials
} = __webpack_require__("./browser/uu_appg01_core-authentication.js");
const {
  Config,
  BaseError
} = __webpack_require__("./browser/uu_appg01_core-utils.js");
const {
  LoggerFactory
} = __webpack_require__("./browser/uu_appg01_core-logging.js");
const {
  AppClient
} = __webpack_require__("./browser/uu_appg01_core-appclient.js");
const DefaultServiceLoader = __webpack_require__("./internal/default-service-loader.js");
const OAuthClient = __webpack_require__("./internal/oauth-client.js");
const Session = __webpack_require__("./session.js");
const AbstractAuthorizationFlow = __webpack_require__("./browser/internal/abstract-authorization-flow.js");
const ImplicitFlow = __webpack_require__("./browser/internal/implicit-flow.js");
const CodeFlow = __webpack_require__("./browser/internal/code-flow.js");
const CodeFlowV2 = __webpack_require__("./browser/internal/code-flow-v2.js");
const Os8Flow = __webpack_require__("./browser/internal/os8-flow.js");
const ClientCredentialsProvider = __webpack_require__("./browser/internal/client-credentials-provider.js");
const SessionStateChangeNotifier = __webpack_require__("./browser/internal/session-state-change-notifier.js");
const BrowserSession = __webpack_require__("./browser/internal/browser-session.js");
const Dom = __webpack_require__("./browser/ui/dom.js");
const InteractionRequired = __webpack_require__("./browser/interaction-required.js");
const META_SERVICE_NAME = "uu_appg01_oidc";
const CONFIG_REQUESTED_ACR_VALUES = "uu_app_oidc_requested_acr_values";
const CONFIG_MAX_AUTHENTICATION_AGE = "uu_app_oidc_max_authentication_age";
const CONFIG_PREFIX = "uu_app_oidc_providers_";
const SECONDARY_PROVIDERS_ENABLED_CFG = "uu_app_oidc_secondary_providers_enabled";
const CONFIG_REDIRECT_URI_KEY = "uu_app_oidc_redirect_uri";
const CONFIG_AUTHN_FLOW_OVERRIDE = "uu_app_oidc_authn_flow_override";
const CONFIG_BACKEND_AVAILABLE = "uu_app_oidc_backend_available";
const CONFIG_BACKEND_GRANT_CALL_TOKEN_AVAILABLE = "uu_app_oidc_backend_grant_call_token_available";
const DEFAULT_AUTHN_TYPE = "implicit";
const DEFAULT_CROSSDOMAIN_STRATEGY = "cookie";
const DEFAULT_SCOPE_MODE = "baseUri";
const RESTORE_SESSION_DISABLED = "disabled";
const FORWARD_CROSSDOMAIN_STRATEGY = "forward";
const JWT_TOKEN_REGEX = /^[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+$/;

/**
 * Frontend implementation of authentication service based on uuOIDC.
 */
class AuthenticationService {
  /**
   * Internal function invoked once page is loaded.
   * @return {Promise<void>}
   * @private
   */
  static async _onPageLoad(callToken) {
    if (!this._onPageLoadPromise) {
      this._onPageLoadFinished = false;
      let onPageLoadInternal = async function () {
        let restoreOnLoad = AbstractAuthorizationFlow.getRestoreSessionOnLoad();
        if (restoreOnLoad !== RESTORE_SESSION_DISABLED) {
          await this.restoreSession({
            callToken
          });
        } else {
          // In case restore of session is not enabled, we have to do some
          // initialization anyway in order to interactive authentication to
          // work (Browsers are limiting maximum number of awaits when
          // displaying popup, therefore these data must be loaded beforehand).
          let primaryProvider = this._providers[this._primaryProvider];
          if (primaryProvider) {
            await primaryProvider._loadAsyncData();
          }
        }
        this._onPageLoadFinished = true;
      }.bind(this);
      this._onPageLoadPromise = onPageLoadInternal();
    }
    return this._onPageLoadPromise;
  }

  /**
   * Load and initialize authentication service(s)
   * @private
   */
  static load(reconfigure = false) {
    DefaultServiceLoader.load(AuthenticationService, reconfigure);
  }

  /**
   * Creates new instance of uuOIDC authentication service and registers it
   * as authentication service with given name.
   * @param {String} name Service name
   * @param {Object|null} opts Service options
   * @param {String|Uri|null} opts.serviceUri Base URI of OIDC server
   * @param {number} options.tokenCacheSize Maximal size of call token cache
   * @param {number} options.tokenTimeLeeway Time verification tolerance (in seconds)
   */
  static create(name, opts = {}) {
    // Do not allow reinitialization of already registered services
    let force = opts.force || false;
    if (!force && this._providers[name]) {
      return;
    }
    let authService = new this(name, opts);
    // Register service in global authentication service component
    CoreAuthenticationService._register(name, authService);
    // Register oidc meta-service to be able to use multiple oidc providers via generic API
    CoreAuthenticationService._register(META_SERVICE_NAME, this);
    // Store service localy
    // (to be able to choose service based on tokens)
    this._providers[name] = authService;
    if (!this._primaryProvider) {
      this._primaryProvider = name;
    }
    this._restoreSessionPromise = null;
    this._isRestoringSession = false;
    this._logger = LoggerFactory.get("uuapp.oidc.AuthenticationService");
  }

  /**
   * Authenticates user (using primary authentication service).
   * @param {Object|null} options Options
   * @param {String} options.acrValues Requested authentication level
   * @param {String} options.maxAge Requested maximum age (in seconds) of user authentication
   * @param {String} options.prompt One of null (show login page if not authenticated), "login" (show login page regardless of authentication state), "none" (silently find out authentication state).
   * @param {String} options.language What language the login page should use.
   * @param {String} options.os8Token Authenticates the user using uuOS8 token.
   * @param {Boolean} options.usePopup Flag if login form should be displayed in popup (default) or in main application window.
   * @param {String} options.scopeMode Scope mode (one of [useCase, allUseCases, baseUri, none]). Applied only if scope is not explicitly set.
   * @param {String} scope Scope allows for limitations of where resulting session can be used (defaults to application baseUri unless scope mode is set to "none").
   * @returns {Promise<Session>} User session for authenticated user.
   */
  static async authenticate(options, scope = null) {
    if (!this._onPageLoadPromise) {
      // Workaround for IE 11 (due to unreliable promises, authenticate
      // method can be invoked before onPageLoad is called)
      this._onPageLoad(null);
    }
    if (!this._onPageLoadFinished) {
      // May block popup but ensures authentication works in case popup
      // is not used, and allows for next authentication with popup works
      await this._onPageLoadPromise;
    }
    let primaryProvider = this._providers[this._primaryProvider];
    return await primaryProvider.authenticate(options, scope);
  }

  /**
   * Returns whether an authentication of primary authentication service is in progress.
   * @returns {boolean} Whether an authentication of primary authentication service is in progress.
   */
  static isAuthenticating() {
    let primaryProvider = this._providers[this._primaryProvider];
    return primaryProvider ? primaryProvider.isAuthenticating() : null;
  }

  /**
   * Returns name of primary authentication service.
   * @returns {String} Name of primary authentication service
   */
  static getServiceName() {
    let primaryProvider = this._providers[this._primaryProvider];
    return primaryProvider ? primaryProvider.getServiceName() : null;
  }

  /**
   * Returns URI of primary authentication service.
   * @returns {String} URI of primary authentication service
   */
  static async getServiceUri() {
    let primaryProvider = this._providers[this._primaryProvider];
    return primaryProvider ? await primaryProvider.getServiceUri() : null;
  }

  /**
   * Returns URI of primary authentication service.
   * @returns {String} URI of primary authentication service
   * @deprecated
   */
  static getProviderUri() {
    let primaryProvider = this._providers[this._primaryProvider];
    return primaryProvider ? primaryProvider.getProviderUri() : null;
  }

  /**
   * Returns current session of primary authentication service or null if the user is not logged in.
   * @returns {Session} Current session of primary authentication service or null if the user is not logged in.
   */
  static getCurrentSession() {
    let primaryProvider = this._providers[this._primaryProvider];
    return primaryProvider ? primaryProvider.getCurrentSession() : null;
  }

  /**
   * Restores session of primary authentication service.
   * @param {Object|null} options Options
   * @param {String} options.acrValues Requested authentication level
   * @param {String} options.maxAge Requested maximum age (in seconds) of user authentication
   * @returns {Promise<Session>} Promise resolved when session restoration ends.
   */
  static async restoreSession(options = {}) {
    // If redirection was used for session restore, provide original referrer
    let authReferrer = sessionStorage.getItem("uu_app_oidc_auth_referrer");
    sessionStorage.removeItem("uu_app_oidc_auth_referrer");
    document.originalReferrer = authReferrer || "";
    if (!this._restoreSessionPromise) {
      this._isRestoringSession = true;
      let restoreSessionInternal = async function () {
        let secondaryProvidersEnabled = Config.getBoolean(SECONDARY_PROVIDERS_ENABLED_CFG);
        if (secondaryProvidersEnabled == null) {
          secondaryProvidersEnabled = false;
        }
        if (!secondaryProvidersEnabled || Object.keys(this._providers).length === 1) {
          try {
            return await this._providers[this._primaryProvider].restoreSession(options);
          } finally {
            this._isRestoringSession = false;
          }
        } else {
          this._logger.debug("Trying to restore session for any available authentication service.");
          let sortedProviders = [];
          sortedProviders.push(this._providers[this._primaryProvider]);
          for (let provider of Object.values(this._providers)) {
            if (provider.getServiceName() !== this._primaryProvider) {
              sortedProviders.push(provider);
            }
          }
          let authenticationErrors = [];
          let session = null;
          let origPrimaryProvider = this._primaryProvider;
          for (let provider of sortedProviders) {
            this._primaryProvider = provider.getServiceName();
            try {
              session = await provider.restoreSession(options);
              if (session.getIdentity() && session.getIdentity().getUuIdentity()) {
                this._logger.debug(`Setting ${provider.getServiceName()} as default service.`);
                break;
              }
            } catch (e) {
              authenticationErrors.push([provider.getServiceName(), e]);
            }
            this._primaryProvider = origPrimaryProvider;
          }
          if (!session.getIdentity()) {
            this._logger.debug(`No existing session found, keeping ${this._primaryProvider} as default service.`);
            if (authenticationErrors.length > 0) {
              // Log authentication errors
              for (let [serviceName, error] of authenticationErrors) {
                this._logger.error(`Authentication with ${serviceName} failed.`, error);
              }
              // "Throw" last of errors
              this._isRestoringSession = false;
              throw authenticationErrors.pop()[1];
            } else {
              this._isRestoringSession = false;
              return session;
            }
          } else {
            this._isRestoringSession = false;
            return session;
          }
        }
      }.bind(this);
      this._restoreSessionPromise = restoreSessionInternal();
    }
    return this._restoreSessionPromise;
  }

  /**
   * Returns whether the session of primary authentication service is in process of being restored.
   * @returns {boolean} Whether the session of primary authentication service is in process of being restored.
   */
  static isRestoringSession() {
    return this._isRestoringSession;
  }

  /**
   * Adds listener for specified event on primary authentication service.
   * Listener is a function accepting an event object, which contains following fields:
   *
   * * **type** The type of the event, e.g. "sessionChanged".
   * * **data** The data passed to the event.
   * @param {string} eventType The event to register listener for.
   * @param {function(Event)} listenerFn The function to be called whenever the event is trigerred.
   * @return {Function()} Function for unregistering the listener (the listener can be unregistered also by {@link #removeListener}).
   */
  static addListener(eventType, listenerFn) {
    let removeFnList = [];
    for (let provider of Object.values(this._providers)) {
      removeFnList.push(provider.addListener(eventType, listenerFn));
    }
    return function () {
      for (let removeFn of removeFnList) {
        removeFn();
      }
    };
  }

  /**
   * Removes listener for specified event on primary authentication service.
   * @param {string} eventType The event to remove listener for.
   * @param {function(Event)} listenerFn The listener (function) to unregister.
   * @return {boolean} True if the listener got removed, false otherwise (listener was not registered).
   */
  static removeListener(eventType, listenerFn) {
    for (let provider of Object.values(this._providers)) {
      provider.removeListener(eventType, listenerFn);
    }
  }

  /**
   * Returns whether the user (global) session of primary authentication service is expiring.
   * @returns {boolean} Whether the user (global) session of primary authentication service is expiring.
   */
  static isSessionExpiring() {
    let primaryProvider = this._providers[this._primaryProvider];
    return primaryProvider ? primaryProvider.isSessionExpiring() : null;
  }

  /**
   * Forces trigger of particular event.
   * @param {String} eventType Event to be triggered
   * @param {Object} data Data to be passed
   */
  static _triggerEvent(eventType, data) {
    for (let provider of Object.values(this._providers)) {
      provider._triggerEvent(eventType, data);
    }
  }

  /**
   * Creates new instance of uuOIDC authentication service.
   * @param {String} name Service name
   * @param {Object|null} opts Service options
   * @param {String|Uri|null} opts.serviceUri Base URI of OIDC server
   * @param {number} options.tokenCacheSize Maximal size of call token cache
   * @param {number} options.tokenTimeLeeway Time verification tolerance (in seconds)
   */
  constructor(name, opts = {}) {
    if (!name) {
      throw new BaseError("Service name is not defined");
    }
    this._serviceName = name;
    this._serviceUri = opts.serviceUri;
    if (!this._serviceUri) {
      throw new BaseError(`There is no service URI defined for service ${this._serviceName}`);
    }
    this._oauthClient = null;
    this._loadOauthClientPromise = this._loadOauthClient(this._serviceName, this._serviceUri, opts);
    this._callTokenType = opts.callTokenType;
    this._callTokenIntrospectAge = opts.callTokenIntrospectAge;
    this._emptySession = BrowserSession.from(Session._createEmptySession(), undefined, undefined, undefined, undefined, this);
    this._currentSession = this._emptySession;
    this._runningAuthnPromise = null;
    this._restoreSessionPromise = null;
    this._isRestoringSession = false;
    this._listeners = [];
    this._globalSessionExpiring = false;
    this._defaultAcrValues = Config.getString(CONFIG_REQUESTED_ACR_VALUES, false) || "low standard high veryHigh";
    this._defaultMaxAge = Config.getNumber(CONFIG_MAX_AUTHENTICATION_AGE, false);
    this._defaultScopeMode = Config.getString(CONFIG_PREFIX + this._serviceName + "_default_call_token_scope_mode") || DEFAULT_SCOPE_MODE;
    this._logger = LoggerFactory.get("uuapp.oidc.AuthenticationService");
    this._redirectUri = Dom.toFullAppUrl(Config.getString(CONFIG_REDIRECT_URI_KEY) || "/oidc/callback");
    this._authnFlow = null;
    this._loadAuthnFlowPromise = this._loadAuthnFlow();
    this._autoLogoutSupportInitialized = false;
    this._autoTokenRefreshInitialized = false;
    this._sessionExtendedAndExpiringSupportInitialized = false;
    this._sessionStateChangeNotifierInitialized = false;
  }

  /**
   * Returns name of authentication service
   * @returns {String} Name of authentication service
   */
  getServiceName() {
    return this._serviceName;
  }

  /**
   * Returns URI of authentication service
   * @returns {String} URI of authentication service
   */
  async getServiceUri() {
    if (!this._oauthClient) {
      await this._loadOauthClientPromise;
    }
    return (await this._oauthClient.getIssuerList())[0];
  }

  /**
   * Returns URI of authentication service.
   * @returns {String|Uri|*} URI of authentication service
   * @deprecated
   */
  getProviderUri() {
    return this._serviceUri;
  }

  /**
   * Returns current session or null if the user is not logged in.
   * @returns {Session} Current session or null if the user is not logged in.
   */
  getCurrentSession() {
    return this._currentSession;
  }

  /**
   * Restores session, i.e. checks whether to user is logged in on remote server
   * and initializes session if (s)he is.
   * @param {Object|null} options Options
   * @param {String} options.acrValues Requested authentication level
   * @param {String} options.maxAge Requested maximum age (in seconds) of user authentication
   * @returns {Promise<Session>} Promise resolved when session restoration ends. In case of failure
   *   the promise is still resolved successfully but with null.
   */
  async restoreSession(options = {}) {
    // NOTE All invocations return the same promise, i.e. this method restores session single time only.
    if (!this._restoreSessionPromise) {
      this._isRestoringSession = true;
      this._logger.debug(`Trying to restore session for ${this.getServiceName()}.`);
      let {
        acrValues,
        maxAge,
        callToken
      } = options || {};
      let clientId = await ClientCredentialsProvider.getClientId(this._serviceName);
      let session = BrowserSession.loadFromCache(this, clientId);
      let restoreSessionFn;
      let restoreSessionArgs;
      if (session && session.matches(acrValues || this._defaultAcrValues, maxAge || this._defaultMaxAge)) {
        this._logger.debug(`Session for ${this.getServiceName()} loaded from cache.`);
        restoreSessionFn = this._authenticateBySession.bind(this);
        restoreSessionArgs = session;
      } else if (callToken) {
        this._logger.warn(`Trying to initialize session by access_token for ${this.getServiceName()}. This method is deprecated and is going to be removed!`);
        restoreSessionFn = this._authenticateByCallToken.bind(this);
        restoreSessionArgs = callToken;
      } else {
        restoreSessionFn = this._restoreSession.bind(this);
        restoreSessionArgs = {
          acrValues,
          maxAge
        };
      }
      this._restoreSessionPromise = restoreSessionFn(restoreSessionArgs).then(r => {
        this._logger.debug(`Session for ${this.getServiceName()} restored.`);
        this._isRestoringSession = false;
        return r;
      }, e => {
        if (e && (e.code && e.code.match(/(interaction|login|account_selection|consent)_required/i) || e.message && e.message.match(/interaction required/i))) {
          this._logger.debug(`Restore of session for ${this.getServiceName()} failed, user interaction is required (${e.code}).`);
        } else {
          this._logger.error(`Restore of session for ${this.getServiceName()} failed.`, e);
        }
        this._isRestoringSession = false;
        return this._currentSession;
      });
    }
    return this._restoreSessionPromise;
  }

  /**
   * Returns whether the session is in process of being restored.
   * @returns {boolean} Whether the session is in process of being restored.
   */
  isRestoringSession() {
    return this._isRestoringSession;
  }

  /**
   * Invokes immediate session check.
   * @param {Boolean} forceSessionExtend Flag whether check should be done via explicit extension of session.
   * @returns {null} Result of check is propagated to attached listeners.
   */
  checkSession(forceSessionExtend = false) {
    if (forceSessionExtend && this._currentSession && this._currentSession.isAuthenticated()) {
      this._silentTokenRefresh(true);
    } else if (this._sessionChecker) {
      this._sessionChecker._checkState();
    }
    return null;
  }

  /**
   * Authenticates user (using primary authentication service).
   * @param {Object|null} options Options
   * @param {Object} options.authenticationContext Custom object for persisting application state during authentication process (passed context is returned
   *                   when user is sucessfully authenticated allowing application to continue with its flow which was interrupted by authentication)
   * @param {String} options.acrValues Requested authentication level
   * @param {String} options.maxAge Requested maximum age (in seconds) of user authentication
   * @param {String} options.prompt One of null (show login page if not authenticated), "login" (show login page regardless of authentication state), "none" (silently
   *                   find out authentication state) and "registration" (shows registration page instead of login form).
   * @param {String} options.language What language the login page should use.
   * @param {String} options.os8Token Authenticates the user using uuOS8 token.
   * @param {Boolean} options.usePopup Flag if login form should be displayed in popup (default) or in main application window.
   * @param {String} options.scopeMode Scope mode (one of [useCase, allUseCases, baseUri, none]). Applied only if scope is not explicitly set.
   * @param {String} options.loginHint Optional identification of user which we want to authenticate (usable with prompt "login" and "registration")
   * @param {String} scope Scope allows for limitations of where resulting session can be used (defaults to application baseUri unless scope mode is set to "none").
   * @returns {Promise<Session>} User session for authenticated user.
   */
  async authenticate(options, scope = null) {
    if (this._runningAuthnPromise && this._equalsArray(this._runningAuthnArgs, Array.prototype.slice.call(arguments))) {
      let {
        uiComponent
      } = this._runningAuthnPromise;
      if (uiComponent && typeof uiComponent.focus === "function") uiComponent.focus();
      return this._runningAuthnPromise;
    }
    if (!this._oauthClient) {
      await this._loadOauthClientPromise;
    }
    let flow;
    if (options && options.os8Token) {
      flow = new Os8Flow(this._oauthClient, this._serviceName, this._redirectUri);
    } else {
      if (!this._authnFlow) {
        await this._loadAuthnFlowPromise;
      }
      flow = this._authnFlow;
    }
    let scopeMode = options && options.scopeMode ? options.scopeMode : this._defaultScopeMode;
    if ((!scope || scope.length == 0) && scopeMode !== "none") {
      scope = Dom.canonicalAppBaseUri || Dom.appBaseUri;
      scope = scope.replace(/\/$/, "");
    }
    try {
      this._runningAuthnArgs = Array.prototype.slice.call(arguments);
      this._runningAuthnPromise = flow.authenticate(options, scope);
      let result = await this._runningAuthnPromise;
      let supportedAcrValues = await this._oauthClient.getSupportedAcrValues();
      let session = new Session(this._serviceName, this._oauthClient, supportedAcrValues, result.claims, result.idToken, result.accessToken);
      session = BrowserSession.from(session, result.authenticationContext, result.globalSessionExpiresAt, result.globalSessionState, this);
      session._authConstraints = {
        scope: result.scope,
        acrValues: result.acrValues,
        maxAge: result.maxAge
      };
      this._currentSession = session;
      this._initHandlers();
      if (session) {
        session._onCloseListener = this._onSessionClose.bind(this);
        session.storeToCache(result.clientId);
      }
      this._triggerEvent("sessionChanged", session);
      return session;
    } finally {
      this._runningAuthnArgs = [];
      this._runningAuthnPromise = null;
    }
  }

  /**
   * Returns whether an authentication is in progress.
   * @returns {boolean} Whether an authentication is in progress.
   */
  isAuthenticating() {
    return !!this._runningAuthnPromise;
  }

  /**
   * Adds listener for specified event. Listener is a function accepting an event object, which contains following fields:
   *
   * * **type** The type of the event, e.g. "sessionChanged".
   * * **data** The data passed to the event.
   * @param {string} eventType The event to register listener for.
   * @param {function(Event)} listenerFn The function to be called whenever the event is trigerred.
   * @return {Function()} Function for unregistering the listener (the listener can be unregistered also by {@link #removeListener}).
   */
  addListener(eventType, listenerFn) {
    let list = this._listeners[eventType];
    if (!list) list = this._listeners[eventType] = [];
    list.push(listenerFn);
    return this.removeListener.bind(this, eventType, listenerFn);
  }

  /**
   * Removes listener for specified event.
   * @param {string} eventType The event to remove listener for.
   * @param {function(Event)} listenerFn The listener (function) to unregister.
   * @return {boolean} True if the listener got removed, false otherwise (listener was not registered).
   */
  removeListener(eventType, listenerFn) {
    let list = this._listeners[eventType];
    if (!list) return false;
    let idx = list.indexOf(listenerFn);
    if (idx != -1) list.splice(idx, 1);
    return idx != -1;
  }

  /**
   * Returns whether the user (global) session is expiring.
   * @returns {boolean} Whether the user (global) session is expiring.
   */
  isSessionExpiring() {
    return this._globalSessionExpiring;
  }

  // ======================== Private methods ================================

  async _loadAsyncData() {
    if (!this._oauthClient) {
      await this._loadOauthClientPromise;
    }
    await this._oauthClient.getMetadata();
    await ClientCredentialsProvider.getClientId(this._serviceName);
  }
  async _loadOauthClient(serviceName, serviceUri, opts) {
    let mtlsEnabled = Config.getBoolean(CONFIG_PREFIX + serviceName + "_mtls_enabled", false);
    if (mtlsEnabled) {
      opts["mtlsGateway"] = Config.get(CONFIG_PREFIX + serviceName + "_mtls_gateway");
    }
    let customOauthRealization = Config.get(CONFIG_PREFIX + serviceName + "_oauth_frontend_realization");
    if (customOauthRealization) {
      if (typeof customOauthRealization === "string") {
        try {
          customOauthRealization = await SystemJS.import(customOauthRealization);
        } catch (e) {
          throw new BaseError("Unable to load custom oauth realization.", e);
        }
      }
      if (typeof customOauthRealization === "function") {
        this._oauthClient = new customOauthRealization(serviceUri, opts);
      } else if (typeof customOauthRealization === "object") {
        this._oauthClient = customOauthRealization;
      } else {
        throw new BaseError(`Oauth realization '${customOauthRealization}' is not supported.`);
      }
    } else {
      this._oauthClient = new OAuthClient(serviceUri, opts);
    }
  }
  async _loadAuthnFlow() {
    if (!this._oauthClient) {
      await this._loadOauthClientPromise;
    }
    let authnFlowOverride = Config.get(CONFIG_AUTHN_FLOW_OVERRIDE);
    if (authnFlowOverride) {
      if (typeof authnFlowOverride === "string") {
        try {
          authnFlowOverride = await SystemJS.import(authnFlowOverride);
        } catch (e) {
          throw new BaseError("Unable to load authentication flow override.", e);
        }
      }
      if (typeof authnFlowOverride === "function") {
        this._authnFlow = new authnFlowOverride(this._oauthClient, this._serviceName, this._redirectUri, Dom.appBaseUri);
      } else if (typeof authnFlowOverride === "object") {
        this._authnFlow = authnFlowOverride;
      } else {
        throw new BaseError(`Authentication flow override '${authnFlowOverride}' is not supported.`);
      }
    } else {
      let authenticationType = Config.getString(CONFIG_PREFIX + this._serviceName + "_authentication_type") || DEFAULT_AUTHN_TYPE;
      let crossdomainStrategy = Config.getString(CONFIG_PREFIX + this._serviceName + "_session_crossdomain_strategy") || DEFAULT_CROSSDOMAIN_STRATEGY;
      let backendAvailable = Config.getBoolean(CONFIG_BACKEND_AVAILABLE);
      if (authenticationType === "code" && !backendAvailable) {
        this._logger.warn("Authentication type [code] requested, but no comatible backend found. Switching to [implicit].");
        authenticationType = "implicit";
      }
      if (authenticationType === "implicit") {
        if (crossdomainStrategy === FORWARD_CROSSDOMAIN_STRATEGY) {
          this._logger.warn("Session crossdomain strategy set to [forward] which is not supported by authentication type [implicit]. Configuration is ignored.");
        }
        this._authnFlow = new ImplicitFlow(this._oauthClient, this._serviceName, this._redirectUri, Dom.appBaseUri);
      } else if (authenticationType === "code") {
        if (crossdomainStrategy === FORWARD_CROSSDOMAIN_STRATEGY) {
          if (Config.getBoolean(CONFIG_BACKEND_GRANT_CALL_TOKEN_AVAILABLE)) {
            this._authnFlow = new CodeFlowV2(this._oauthClient, this._serviceName, this._redirectUri, Dom.appBaseUri);
          } else {
            this._logger.warn("Session crossdomain strategy set to [forward] which is not supported by application backend. Configuration is ignored.");
            this._authnFlow = new CodeFlow(this._oauthClient, this._serviceName, this._redirectUri, Dom.appBaseUri);
          }
        } else {
          this._authnFlow = new CodeFlow(this._oauthClient, this._serviceName, this._redirectUri, Dom.appBaseUri);
        }
      } else {
        throw new BaseError(`Authentication type '${authenticationType}' is not supported.`);
      }
    }
  }
  async _restoreSession(options) {
    if (this._runningAuthnPromise && this._equalsArray(this._runningAuthnArgs, Array.prototype.slice.call(arguments))) {
      let {
        uiComponent
      } = this._runningAuthnPromise;
      if (uiComponent && typeof uiComponent.focus === "function") uiComponent.focus();
      return this._runningAuthnPromise;
    }
    if (!this._oauthClient) {
      await this._loadOauthClientPromise;
    }
    let flow;
    if (options && options.os8Token) {
      flow = new Os8Flow(this._oauthClient, this._serviceName, this._redirectUri);
    } else {
      if (!this._authnFlow) {
        await this._loadAuthnFlowPromise;
      }
      flow = this._authnFlow;
    }
    let scopeMode = options && options.scopeMode ? options.scopeMode : this._defaultScopeMode;
    let scope;
    if (scopeMode !== "none") {
      scope = Dom.canonicalAppBaseUri || Dom.appBaseUri;
      scope = scope.replace(/\/$/, "");
    }
    try {
      this._runningAuthnArgs = Array.prototype.slice.call(arguments);
      if (flow.restoreSession) {
        this._runningAuthnPromise = flow.restoreSession(options, scope);
      } else {
        options = {
          prompt: "none",
          ...options
        };
        this._runningAuthnPromise = flow.authenticate(options, scope);
      }
      let result = await this._runningAuthnPromise;
      let supportedAcrValues = await this._oauthClient.getSupportedAcrValues();
      let session = new Session(this._serviceName, this._oauthClient, supportedAcrValues, result.claims, result.idToken, result.accessToken);
      session = BrowserSession.from(session, result.authenticationContext, result.globalSessionExpiresAt, result.globalSessionState, this);
      session._authConstraints = {
        scope: result.scope,
        acrValues: result.acrValues,
        maxAge: result.maxAge
      };
      this._currentSession = session;
      this._initHandlers();
      if (session) {
        session._onCloseListener = this._onSessionClose.bind(this);
        session.storeToCache(result.clientId);
      }
      this._triggerEvent("sessionChanged", session);
      return session;
    } finally {
      this._runningAuthnArgs = [];
      this._runningAuthnPromise = null;
    }
  }
  async _authenticateBySession(session) {
    let mockRunningAuthPromise = async function () {
      // Load data which are normally loaded during authentication
      // (we need to load them so they are available synchronously later)
      await ClientCredentialsProvider.getClientId(this._serviceName);
      if (!this._oauthClient) {
        await this._loadOauthClientPromise;
      }
      await this._oauthClient.getSupportedAcrValues();
      return {
        session,
        authCtx: session.getAuthenticationContext(),
        globalSessionExpiresAt: session.getExpiresAt(),
        globalSessionState: session.getState()
      };
    }.bind(this);
    try {
      this._runningAuthnPromise = mockRunningAuthPromise();
      await this._runningAuthnPromise;
      this._currentSession = session;
      this._initHandlers();
      if (session) {
        session._onCloseListener = this._onSessionClose.bind(this);
      }
      this._triggerEvent("sessionChanged", session);
      return session;
    } finally {
      this._runningAuthnArgs = [];
      this._runningAuthnPromise = null;
    }
  }
  async _authenticateByCallToken(callToken) {
    let mockRunningAuthPromise = async function () {
      let claims;
      let idToken;
      let accessToken;
      if (!this._oauthClient) {
        await this._loadOauthClientPromise;
      }
      // Parse and validate call token
      if (callToken.match(JWT_TOKEN_REGEX)) {
        claims = await this._oauthClient.parseToken(callToken, this._callTokenType);
        if (this._callTokenIntrospectAge != null && claims.iat && claims.iat + this._callTokenIntrospectAge < Date.now() / 1000) {
          let appClient = new AppClient({
            baseUri: Dom.canonicalAppBaseUri || Dom.appBaseUri
          });
          let headers = {
            authorization: `Bearer ${callToken}`
          };
          let params = {
            _: Date.now()
          }; // cache buster parameter
          claims = (await appClient.get("oidc/introspect", params, {
            headers
          })).data;
        }
        if (this._callTokenType === "idToken") {
          idToken = callToken;
          accessToken = null;
        } else if (this._callTokenType === "accessToken") {
          idToken = null;
          accessToken = callToken;
        } else {
          // uuOidc by default uses JWT format only for idToken
          idToken = callToken;
          accessToken = null;
        }
      } else {
        let appClient = new AppClient({
          baseUri: Dom.canonicalAppBaseUri || Dom.appBaseUri
        });
        let headers = {
          authorization: `Bearer ${callToken}`
        };
        let params = {
          _: Date.now()
        }; // cache buster parameter
        claims = (await appClient.get("oidc/introspect", params, {
          headers
        })).data;
        if (this._callTokenType === "idToken") {
          idToken = callToken;
          accessToken = null;
        } else if (this._callTokenType === "accessToken") {
          idToken = null;
          accessToken = callToken;
        } else {
          // uuOidc by default uses JWT format only for idToken
          idToken = null;
          accessToken = callToken;
        }
      }
      let supportedIssuers = await this._oauthClient.getIssuerList();
      if (!supportedIssuers.includes(claims.iss)) {
        throw new InvalidCredentials("Token is not trusted (unknown token issuer).");
      }
      // Load client id which is normally loaded during authentication
      // (we need to load it so it is available synchronously later)
      await ClientCredentialsProvider.getClientId(this._serviceName);
      let supportedAcrValues = await this._oauthClient.getSupportedAcrValues();
      // Prepare session instance
      let session = new Session(this._serviceName, this._oauthClient, supportedAcrValues, claims, idToken, accessToken);
      session = BrowserSession.from(session, null, null, null, null, this);
      // Override session.getCallToken() to return only token it was initialized with
      session.getCallToken = async function (scope = null, opts = {}) {
        let token = this._idToken || this._accessToken;
        if (token) {
          let excludeAuthType = opts ? opts.excludeAuthenticationType : false;
          if (excludeAuthType === true) {
            return token;
          } else {
            return `Bearer ${token}`;
          }
        } else {
          return null;
        }
      }.bind(session);
      // Override session.close() to do not invoke remote logout
      session.close = async function () {
        this.removeFromCache();
        if (this._authenticated && typeof this._onCloseListener === "function") {
          this._onCloseListener(this);
        }
        this._authenticated = false;
        this._idToken = null;
        this._accessToken = null;
      }.bind(session);
      return {
        session
      };
    }.bind(this);
    try {
      this._runningAuthnPromise = mockRunningAuthPromise();
      let {
        session
      } = await this._runningAuthnPromise;
      this._currentSession = session;
      if (session) {
        session._onCloseListener = this._onSessionClose.bind(this);
      }
      this._triggerEvent("sessionChanged", session);
      return session;
    } finally {
      this._runningAuthnArgs = [];
      this._runningAuthnPromise = null;
    }
  }
  _initHandlers() {
    if (!this._autoLogoutSupportInitialized) {
      this._initAutoLogoutSupport();
      this._autoLogoutSupportInitialized = true;
    }
    if (!this._autoTokenRefreshInitialized) {
      this._initAutoTokenRefresh();
      this._autoTokenRefreshInitialized = true;
    }
    if (!this._sessionExtendedAndExpiringSupportInitialized) {
      this._initSessionExtendedAndExpiringSupport();
      this._sessionExtendedAndExpiringSupportInitialized = true;
    }
    if (!this._sessionStateChangeNotifierInitialized) {
      this._initSessionStateChangeNotifier();
      this._sessionStateChangeNotifierInitialized = true;
    } else if (this._sessionChecker) {
      this._sessionChecker.enable();
    }
  }
  _initAutoLogoutSupport() {
    // auto-logout when server-side session reaches its expiration time (or when token
    // reaches its expiration time in case that server-side session info is not available)
    // triggering registered sessionChanged listeners
    // NOTE This assumes that whenever a token changes, sessionChanged listeners are run
    // (so that info from new token gets checked again).
    let autoLogoutTimeout;
    this.addListener("sessionChanged", event => {
      if (autoLogoutTimeout) {
        clearTimeout(autoLogoutTimeout);
        autoLogoutTimeout = null;
      }
      if (!this._currentSession || !this._currentSession.isAuthenticated()) return;

      // plan local logout
      let expiresAt = this._currentSession.getExpiresAt() || 1000 * (this._currentSession.getAttribute("exp") || 0);
      if (!expiresAt) return;
      let now = Date.now();
      let delay = Math.max(0, expiresAt - now);
      this._logger.debug(`Planning local auto-logout at ${this._toTimeString(new Date(now + delay))}.`);
      autoLogoutTimeout = setTimeout(() => {
        autoLogoutTimeout = null;
        this._localLogout();
      }, delay);
    });
  }
  _initAutoTokenRefresh() {
    // support for session auto-refresh when its nearing expiration or when tab is activated
    // NOTE This assumes that whenever a token changes, sessionChanged listeners are run
    // (so that token refreshing gets re-planned / cleaned).
    let tokenRefreshEnabled = Config.getBoolean(CONFIG_PREFIX + this._serviceName + "_token_refresh_enabled");
    if (tokenRefreshEnabled == null) tokenRefreshEnabled = true;
    let tokenRefreshLeeway = Config.getNumber(CONFIG_PREFIX + this._serviceName + "_token_refresh_leeway");
    if (tokenRefreshLeeway == null) tokenRefreshLeeway = 5 * 60;
    let tokenRefreshFailureRetryInterval = Config.getNumber(CONFIG_PREFIX + this._serviceName + "_token_refresh_failure_retry_interval");
    if (tokenRefreshFailureRetryInterval == null || tokenRefreshFailureRetryInterval < 0) tokenRefreshFailureRetryInterval = 30;
    if (tokenRefreshFailureRetryInterval) tokenRefreshFailureRetryInterval = Math.max(5, tokenRefreshFailureRetryInterval);
    let tokenRefreshFailureRetryCount = Config.getNumber(CONFIG_PREFIX + this._serviceName + "_token_refresh_failure_retry_count");
    if (tokenRefreshFailureRetryCount == null || tokenRefreshFailureRetryCount < 0) tokenRefreshFailureRetryCount = 3;
    this._tokenRefreshInProgressCount = 0;
    this._tokenRefreshFailureRetryInterval = tokenRefreshFailureRetryInterval;
    this._tokenRefreshFailureRetryCount = tokenRefreshFailureRetryCount;
    this._tokenRefreshFailureRetryTimer = null;
    let sessionRefreshTimeout;
    this.addListener("sessionChanged", e => {
      if (!tokenRefreshEnabled) return;
      if (sessionRefreshTimeout) {
        clearTimeout(sessionRefreshTimeout);
        sessionRefreshTimeout = null;
      }
      let expiresAt = this._currentSession && this._currentSession.isAuthenticated() && this._currentSession.getAttribute("exp") * 1000;
      if (!expiresAt) return;

      // plan token refresh
      let delay;
      let now = Date.now();
      let validity = expiresAt - now;
      if (validity <= 0) {
        this._logger.warn(`Received already expired token due to expired session - ending with local logout.`);
        this._localLogout();
        return;
      } else if (validity < tokenRefreshLeeway * 1000) {
        this._logger.warn(`Received token with unexpectedly short expiration time of ${Math.floor(validity / 1000)}s. Either session is ` + `nearing expiration, or current configuration of automatic token refresh is not suitable for used oidc provider.`);
        delay = validity - Math.floor(validity / 10); // refresh when expiration time is at 90%
      } else {
        delay = validity - tokenRefreshLeeway * 1000;
      }
      delay = Math.max(delay, 1000); // wait at least 1s between 2 token refreshes
      this._logger.debug(`Planning token auto-refresh at ${this._toTimeString(new Date(now + delay))}.`);
      sessionRefreshTimeout = setTimeout(() => {
        sessionRefreshTimeout = null;
        this._silentTokenRefresh();
      }, delay);
    });
    if (tokenRefreshEnabled) {
      window.addEventListener("focus", () => this.checkSession(true));
      document.addEventListener("visibilitychange", () => document.visibilityState === "visible" && this.checkSession(true));
    }
  }
  _initSessionExtendedAndExpiringSupport() {
    // support for "session extended" notification
    // NOTE This assumes that whenever a token changes, sessionChanged listeners are run.
    let sessionExtendByClientCertFailureRetryInterval = Config.getNumber(CONFIG_PREFIX + this._serviceName + "_session_extend_by_client_cert_failure_retry_interval");
    if (sessionExtendByClientCertFailureRetryInterval == null || sessionExtendByClientCertFailureRetryInterval < 0) sessionExtendByClientCertFailureRetryInterval = 30;
    if (sessionExtendByClientCertFailureRetryInterval) sessionExtendByClientCertFailureRetryInterval = Math.max(5, sessionExtendByClientCertFailureRetryInterval);
    let sessionExtendByClientCertFailureRetryCount = Config.getNumber(CONFIG_PREFIX + this._serviceName + "_session_extend_by_client_cert_failure_retry_count");
    if (sessionExtendByClientCertFailureRetryCount == null || sessionExtendByClientCertFailureRetryCount < 0) sessionExtendByClientCertFailureRetryCount = 3;
    this._sessionExtendByClientCertFailureRetryInterval = sessionExtendByClientCertFailureRetryInterval;
    this._sessionExtendByClientCertFailureRetryCount = sessionExtendByClientCertFailureRetryCount;
    const LEEWAY_MILLIS = 10 * 1000;
    let activeSessionExpiresAtMillis;
    this.addListener("sessionChanged", e => {
      let globalSessionExpiresAt = this._currentSession.getExpiresAt() || 0;
      let wasExtended = activeSessionExpiresAtMillis && globalSessionExpiresAt > activeSessionExpiresAtMillis + LEEWAY_MILLIS;
      activeSessionExpiresAtMillis = globalSessionExpiresAt;
      if (wasExtended) {
        this._globalSessionExpiring = false;
        let expiresAt = activeSessionExpiresAtMillis;
        // we're currently processing "sessionChanged" listeners so let them finish and run "sessionExtended" afterwards
        setTimeout(() => {
          this._triggerEvent("sessionExtended", {
            expiresAt: expiresAt
          });
        }, 0);
      }
    });

    // support for "session expiring" notification
    // NOTE Must be after "session extended" functionality (so that unblocking done there
    // gets performed sooner than the code below).
    // NOTE This assumes that whenever a token changes, sessionChanged listeners are run.
    let sessionExpiringNotificationTime = Config.getNumber(CONFIG_PREFIX + this._serviceName + "_session_expiring_notification_time");
    if (sessionExpiringNotificationTime == null) sessionExpiringNotificationTime = 30 * 60;
    let prevUuIdentity = undefined;
    let sessionExpiringTimeout;
    this.addListener("sessionChanged", e => {
      if (sessionExpiringNotificationTime <= 0) return; // disabled

      if (sessionExpiringTimeout) {
        clearTimeout(sessionExpiringTimeout);
        sessionExpiringTimeout = null;
      }
      let newIdentity = this._currentSession && this._currentSession.isAuthenticated() && this._currentSession.getIdentity();
      let newUuIdentity = newIdentity && newIdentity.getUuIdentity();
      if (newUuIdentity != prevUuIdentity) this._globalSessionExpiring = false;
      prevUuIdentity = newUuIdentity;
      let expiresAt = this._currentSession.getExpiresAt();
      if (!expiresAt) return; // not logged in || "session expiring" notification not supported on server
      if (this._globalSessionExpiring) return; // don't trigger "session expiring" multiple times for the same session

      let now = Date.now();
      let delay = Math.max(0, expiresAt - now - sessionExpiringNotificationTime * 1000);
      this._logger.debug(`Planning sessionExpiring notification at ${this._toTimeString(new Date(now + delay))}.`);
      sessionExpiringTimeout = setTimeout(async () => {
        sessionExpiringTimeout = null;
        // try to silently Session extend - if sucessfull then no need to trigger sessionExpiring event
        if (await this._trySilentSessionExtendByClientCert()) {
          return;
        }
        this._globalSessionExpiring = true;
        this._triggerEvent("sessionExpiring", {
          expiresAt: expiresAt
        });
      }, delay);
    });
    this.addListener("sessionExpiring", e => {
      let expiresAt = e.data.expiresAt;
      let delay = Math.floor((expiresAt - Date.now()) / 2);
      if (delay > 5000) {
        // below 5 seconds, it is probably impossible to finish re-authentication (session is practically expired)
        if (sessionExpiringTimeout) {
          clearTimeout(sessionExpiringTimeout);
        }
        sessionExpiringTimeout = setTimeout(() => {
          sessionExpiringTimeout = null;
          this._globalSessionExpiring = true;
          this._triggerEvent("sessionExpiring", {
            expiresAt: expiresAt
          });
        }, delay);
      }
    });
  }
  async _initSessionStateChangeNotifier() {
    // add session state checking which, in case that we were logged in and a logout
    // against OIDC is detected (e.g. in another browser tab), will log us out
    let sessionCheckInterval = Config.getNumber(CONFIG_PREFIX + this._serviceName + "_session_check_interval");
    if (sessionCheckInterval == null) sessionCheckInterval = 5;
    if (sessionCheckInterval && (await this._authnFlow.isCheckSessionSupported())) {
      let clientId = await ClientCredentialsProvider.getClientId(this._serviceName);
      this._sessionChecker = new SessionStateChangeNotifier(this._authnFlow, sessionCheckInterval, clientId, () => this._currentSession.getState());
      this._sessionChecker.onStateChange(() => {
        this._logger.info("Session state change detected.");
        // check login state against OpenID server (basically renew the token,
        // possibly logging out if the current user on OpenID server differs from ours)
        this._silentTokenRefresh(true);
      });
      this._sessionChecker.onStateUnknown(() => {
        this._logger.info("Unexpected session loss detected.");
        this._triggerEvent("sessionLost");
      });
    }
  }
  _triggerEvent(eventType, data) {
    this._logger.debug(`Launching event "${eventType}".`);
    let list = this._listeners[eventType];
    if (list) {
      let e = {
        type: eventType,
        data: data
      };
      list.forEach(it => it.call(this, e));
    }
  }
  _onSessionClose(session) {
    this._localLogout();
  }
  _localLogout() {
    this._logger.debug("Performing local-logout.");
    this._currentSession.removeFromCache();
    if (this._currentSession != this._emptySession) {
      this._currentSession = this._emptySession;
      this._globalSessionExpiring = false;
      this._triggerEvent("sessionChanged", this._currentSession);
    }
    if (this._sessionChecker) {
      this._sessionChecker.disable();
    }
    if (this._tokenRefreshFailureRetryTimer) {
      clearTimeout(this._tokenRefreshFailureRetryTimer);
      this._tokenRefreshFailureRetryTimer = null;
    }
  }

  /**
   * Tries to re-authenticate the user silently:
   * - if we are locally logged out => do nothing
   * - if a user is logged in (on remote) and it's the same user as ours => use the new token
   * - if a user is logged in (on remote) and it's not the same user as ours => perform local logout
   * - if a user is not logged in (on remote) => perform local logout
   */
  async _silentTokenRefresh(skipIfPlanned = false) {
    if (skipIfPlanned && (this._tokenRefreshFailureRetryTimer || this._tokenRefreshInProgressCount > 0)) {
      return;
    }
    if (this._tokenRefreshFailureRetryTimer) {
      clearTimeout(this._tokenRefreshFailureRetryTimer);
      this._tokenRefreshFailureRetryTimer = null;
    }
    let retryCount = 0;
    let doSilentRenew = async () => {
      if (!this._currentSession || !this._currentSession.isAuthenticated()) {
        // no-op (we're logged out and don't want to silently auto-login)
        return;
      }
      this._logger.debug("Silent token refresh - starting.");
      ++this._tokenRefreshInProgressCount;
      try {
        await this._doAuthenticateRefresh();
        --this._tokenRefreshInProgressCount;
      } catch (e) {
        --this._tokenRefreshInProgressCount;
        if (this._tokenRefreshFailureRetryTimer) {
          this._logger.debug("Silent token refresh - ending current run with no-op (operation ended with unexpected error and another retry is already planned).", e);
        } else if (this._tokenRefreshFailureRetryCount && retryCount < this._tokenRefreshFailureRetryCount) {
          this._logger.debug(`Silent token refresh - ended with unexpected error, will retry in ${this._tokenRefreshFailureRetryInterval}s.`, e);
          this._tokenRefreshFailureRetryTimer = setTimeout(() => {
            ++retryCount;
            this._tokenRefreshFailureRetryTimer = null;
            doSilentRenew();
          }, this._tokenRefreshFailureRetryInterval * 1000);
        } else {
          this._logger.debug(`Silent token refresh - ended with unexpected error (and no more retries are allowed). Logging out.`, e);
          this._localLogout();
        }
      }
    };
    await doSilentRenew();
  }
  async _trySilentSessionExtendByClientCert() {
    // do nothing if mtls NOT enabled
    if (!Config.getBoolean(CONFIG_PREFIX + this._serviceName + "_mtls_enabled", false)) {
      return;
    }
    let retryCount = 0;
    let doSilentExtend = async () => {
      this._logger.debug("Silent Session extend by Client Certificate - starting.");
      try {
        let authTime = this._currentSession.getAuthenticationTime().getTime() / 1000;
        let now = Date.now() / 1000;
        // maxAge calculated as maximum possible value - 5s tolerance
        let maxAge = Math.round(now - authTime - 5);
        await this.authenticate({
          prompt: "none",
          maxAge: maxAge
        });
        this._logger.debug(`Silent Session extend by Client Certificate - Session was extended`);
        return true;
      } catch (e) {
        if (this._sessionExtendByClientCertFailureRetryCount && retryCount < this._sessionExtendByClientCertFailureRetryCount) {
          this._logger.debug(`Silent Session extend by Client Certificate - ended with unexpected error, will retry in ${this._sessionExtendByClientCertFailureRetryInterval}s.`, e);
          await this._waitFor(this._sessionExtendByClientCertFailureRetryInterval * 1000);
          ++retryCount;
          return doSilentExtend();
        } else {
          this._logger.debug(`Silent Session extend by Client Certificate - ended with unexpected error (and no more retries are allowed).`, e);
          return false;
        }
      }
    };
    return await doSilentExtend();
  }
  _waitFor(millSeconds) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve();
      }, millSeconds);
    });
  }
  _equalsArray(array1, array2) {
    return array1.length === array2.length && array1.every((it, i) => it === array2[i]);
  }
  _toTimeString(date) {
    return (
      // date.getFullYear() + "-" + ("0" + (date.getMonth() + 1)).substr(-2) + "-" + ("0" + date.getDate()).substr(-2) + " " +
      ("0" + date.getHours()).substr(-2) + ":" + ("0" + date.getMinutes()).substr(-2) + ":" + ("0" + date.getSeconds()).substr(-2)
    );
  }
  async _doAuthenticateRefresh() {
    try {
      if (!this._oauthClient) {
        await this._loadOauthClientPromise;
      }
      if (!this._authnFlow) {
        await this._loadAuthnFlowPromise;
      }
      let authConstraints = this._currentSession ? this._currentSession._authConstraints : null;
      let scope = authConstraints ? authConstraints.scope : null;
      let acrValues = authConstraints ? authConstraints.acrValues : null;
      let maxAge = authConstraints ? authConstraints.maxAge : null;
      let result;
      if (this._authnFlow.refreshSession) {
        result = await this._authnFlow.refreshSession({
          acrValues,
          maxAge
        }, scope);
      } else {
        result = await this._authnFlow.authenticate({
          acrValues,
          maxAge,
          prompt: "none",
          usePopup: false
        }, scope);
      }
      if (!this._currentSession || !this._currentSession.isAuthenticated()) {
        // no-op (we've become logged out and don't want to silently auto-login)
        this._logger.debug("Silent token refresh - ending with no-op (local session is already logged out).");
      } else {
        let supportedAcrValues;
        if (this._currentSession && this._currentSession._supportedAcrValues) {
          supportedAcrValues = this._currentSession._supportedAcrValues;
        } else {
          supportedAcrValues = await this._oauthClient.getSupportedAcrValues();
        }
        let session = new Session(this._serviceName, this._oauthClient, supportedAcrValues, result.claims, result.idToken, result.accessToken);
        // if the user is different than the current one then perform logout
        let curSessIdentity = this._currentSession.getIdentity();
        let newSessIdentity = session.getIdentity();
        if (curSessIdentity && newSessIdentity && curSessIdentity.getUuIdentity() !== newSessIdentity.getUuIdentity() || (!curSessIdentity || !newSessIdentity) && curSessIdentity != newSessIdentity) {
          this._logger.debug("Silent token refresh - ending with local logout (user that is logged in on remote is different from the local one).");
          this._localLogout();
        } else {
          // everything is fine - use new session
          this._logger.debug("Silent token refresh - ending with token renewed.");
          let authCtx = this._currentSession.getAuthenticationContext();
          session = BrowserSession.from(session, authCtx, result.globalSessionExpiresAt, result.globalSessionState, this);
          session._authConstraints = authConstraints;
          this._currentSession = session;
          if (session) {
            session._onCloseListener = this._onSessionClose.bind(this);
            session.storeToCache(result.clientId);
          }
          this._triggerEvent("sessionChanged", session);
        }
      }
    } catch (e) {
      if (e instanceof InteractionRequired) {
        this._logger.debug(`Silent token refresh ending with local logout, user interaction is required (${e.code}).`);
        this._localLogout();
      } else {
        this._logger.error("Silent token refresh failed.", e);
        throw e;
      }
    }
  }
}
AuthenticationService._providers = {};
AuthenticationService._primaryProvider = null;

// Load all available OIDC authentication services
AuthenticationService.load(false);
module.exports = AuthenticationService;

/***/ }),

/***/ "./browser/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// polyfills for IE
if (!String.prototype.startsWith) {
  Object.defineProperty(String.prototype, 'startsWith', {
    value: function (search, pos) {
      pos = !pos || pos < 0 ? 0 : +pos;
      return this.substring(pos, pos + search.length) === search;
    }
  });
}

// FIXME Copy&pasted src/index.js because following doesn't work (cyclic warning):
// module.exports = require("../index.server.js"); // with "../index.server.js" remapped back to src/index.js in package.json ("browser" field)
let sessionWrapped = false;
module.exports = {
  get AuthenticationService() {
    return __webpack_require__("./browser/authentication-service.js");
  },
  get Session() {
    let Session = __webpack_require__("./session.js");
    if (!sessionWrapped) {
      sessionWrapped = true;
      (__webpack_require__("./browser/internal/oidcg01-session-wrapper.js").wrapClass)(Session, module.exports.AuthenticationService);
    }
    return Session;
  },
  get Internal() {
    return {
      get OAuthClient() {
        return __webpack_require__("./internal/oauth-client.js");
      },
      get AbstractAuthorizationFlow() {
        return __webpack_require__("./browser/internal/abstract-authorization-flow.js");
      },
      get ImplicitFlow() {
        return __webpack_require__("./browser/internal/implicit-flow.js");
      },
      get CodeFlow() {
        return __webpack_require__("./browser/internal/code-flow.js");
      },
      get AccessPolicyVerificationHandler() {
        return __webpack_require__("./browser/internal/access-policy-verification-handler.js");
      }
    };
  },
  // Legacy names for backward compatibility with uu_oidcg01
  get OidcAuthenticationService() {
    return this.AuthenticationService;
  },
  get OidcSession() {
    return this.Session;
  }
};

// export to legacy variable too
if (!window.UuOidc) window.UuOidc = {
  Session: module.exports.Session
};

// bootstrap in browser
// extract access_token parameter and mask it in current URL (so that user does
// not accidentally copy&paste it to somebody else)
let callToken;
if (window.history && window.history.replaceState) {
  let accessTokenMatch = location.href.match(/[?&]?access_token=([^&#]+)/);
  if (accessTokenMatch) {
    callToken = accessTokenMatch[1];
    try {
      // NOTE Can't use native URL API because of IE 11...
      var maskedUrl = location.href.replace(/([?&])access_token=[^&#]*(&)?/, (m, g1, g2) => g2 ? g1 : "");
      if (maskedUrl !== location.href) {
        history.replaceState(history.state, "", maskedUrl);
      }
    } catch (e) {
      // replacing state can fail - ignore in such case (e.g. when in <iframe srcdoc="..."></iframe>)
    }
  }
}

// Initialize authentication service in order for interactive authentication to work
// (wait until DOM is ready because we need BODY element to be present due to how implicit flow works)
let domReadyPromise;
if (document.readyState === "interactive" || document.readyState === "complete") {
  domReadyPromise = Promise.resolve();
} else {
  domReadyPromise = new Promise(resolve => {
    document.addEventListener("DOMContentLoaded", resolve, false);
  });
}
domReadyPromise.then(() => {
  module.exports.AuthenticationService._onPageLoad(callToken);
});

/***/ }),

/***/ "./browser/interaction-required.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  AuthenticationError
} = __webpack_require__("./browser/uu_appg01_core-authentication.js");

/**
 * Error raised in case authentication cannot be finished without user interaction.
 */
class InteractionRequired extends AuthenticationError {}
module.exports = InteractionRequired;

/***/ }),

/***/ "./browser/internal/abstract-authorization-flow.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Dom = __webpack_require__("./browser/ui/dom.js");
const PopupComponent = __webpack_require__("./browser/ui/popup-component.js");
const IframeComponent = __webpack_require__("./browser/ui/iframe-component.js");
const MainWindowComponent = __webpack_require__("./browser/ui/main-window-component.js");
const SyncCallNotPossible = __webpack_require__("./internal/sync-call-not-possible.js");
const InteractionRequired = __webpack_require__("./browser/interaction-required.js");
const ClientCredentialsProvider = __webpack_require__("./browser/internal/client-credentials-provider.js");
const {
  AuthenticationError
} = __webpack_require__("./browser/uu_appg01_core-authentication.js");
const {
  Config,
  Base64,
  BaseError
} = __webpack_require__("./browser/uu_appg01_core-utils.js");
const {
  LoggerFactory
} = __webpack_require__("./browser/uu_appg01_core-logging.js");
const CONFIG_RESTORE_SESSION_ON_LOAD_GLOBAL = "uu_app_oidc_restore_session_on_load";
const CONFIG_RESTORE_SESSION_ON_LOAD_UVE = "uuAppOidcRestoreSessionOnLoad";
const RESTORE_SESSION_DISABLED = "disabled";
const RESTORE_SESSION_OPTIONAL = "optional";
const CONFIG_REQUESTED_ACR_VALUES = "uu_app_oidc_requested_acr_values";
const CONFIG_MAX_AUTHENTICATION_AGE = "uu_app_oidc_max_authentication_age";
const CONFIG_PREFIX = "uu_app_oidc_providers_";
const LOGIN_POPUP_ENABLED_CONFIG = "_login_popup_enabled";
const LOGIN_POPUP_WIDTH_CONFIG = "_login_popup_width";
const LOGIN_POPUP_HEIGHT_CONFIG = "_login_popup_height";
const CONFIG_POST_LOGOUT_REDIRECT_URI_KEY = "uu_app_oidc_post_logout_redirect_uri";
const LOGOUT_TYPE_CONFIG = "_logout_type";
const LOGOUT_POPUP_WIDTH_CONFIG = "_logout_popup_width";
const LOGOUT_POPUP_HEIGHT_CONFIG = "_logout_popup_height";
const DEFAULT_SCOPE_MODE = "baseUri";
const DEFAULT_POPUP_WIDTH = 655;
const DEFAULT_POPUP_HEIGHT = 875;
const LOGIN_POPUP_DEFAULTS = {
  enabled: {
    oidcg01: true,
    oidcg02: true
  },
  width: {
    oidcg01: 599,
    oidcg02: DEFAULT_POPUP_WIDTH
  },
  height: {
    oidcg01: 600,
    oidcg02: DEFAULT_POPUP_HEIGHT
  }
};
const LOGOUT_DEFAULTS = {
  type: {
    oidcg01: "iframe",
    oidcg02: "iframe"
  },
  popupWidth: {
    oidcg01: 599,
    oidcg02: DEFAULT_POPUP_WIDTH
  },
  popupHeight: {
    oidcg01: 600,
    oidcg02: DEFAULT_POPUP_HEIGHT
  }
};
class AbstractAuthorizationFlow {
  static getRestoreSessionOnLoad() {
    let metaTag = document.querySelector(`meta[${CONFIG_RESTORE_SESSION_ON_LOAD_UVE}]`);
    let restoreOnLoad = metaTag ? metaTag.attributes[CONFIG_RESTORE_SESSION_ON_LOAD_UVE].value : null;
    if (!restoreOnLoad) {
      restoreOnLoad = Config.getString(CONFIG_RESTORE_SESSION_ON_LOAD_GLOBAL);
      if (restoreOnLoad == null || restoreOnLoad === "true") {
        restoreOnLoad = RESTORE_SESSION_OPTIONAL;
      } else if (restoreOnLoad === "false") {
        restoreOnLoad = RESTORE_SESSION_DISABLED;
      }
    }
    return restoreOnLoad;
  }
  constructor(oauthClient, serviceName, defaultRedirectUri) {
    this._oauthClient = oauthClient;
    this._serviceName = serviceName;
    this._defaultRedirectUri = defaultRedirectUri;
    let popupEnabled = Config.getBoolean(CONFIG_PREFIX + serviceName + LOGIN_POPUP_ENABLED_CONFIG);
    if (popupEnabled == null) {
      popupEnabled = LOGIN_POPUP_DEFAULTS.enabled[serviceName];
      this._popupEnabled = popupEnabled == null ? true : popupEnabled;
    } else {
      this._popupEnabled = popupEnabled;
    }
    this._defaultAcrValues = Config.getString(CONFIG_REQUESTED_ACR_VALUES, false);
    this._defaultMaxAge = Config.getNumber(CONFIG_MAX_AUTHENTICATION_AGE, false);
    this._logger = LoggerFactory.get("uuapp.oidc.internal." + serviceName + "." + this.constructor.name);
    this._checkSessionIframe = null;
    this._loadCheckSessionIframePromise = null;
    this._runningCheckSessionPromise = null;
    this._runningCheckSessionResolve = null;
  }
  getResponseType() {
    throw new Error("AbstractFlow.getResponseType must be implemented on child class.");
  }
  createAuthState(authCtx = null, usePopup = null) {
    let state = {
      r: Math.random().toString(32).substr(2),
      // Remember URI of UVE we are leaving (needed in case callback is done in main window - we have to redirect)
      appUri: location.pathname + location.search + (location.hash.length > 1 ? location.hash : ""),
      authCtx,
      usePopup
    };
    return state;
  }
  restoreSession(options, scope = null) {
    return this.authenticate(options, scope);
  }
  authenticate(options, scope = null) {
    let uiComponent;
    let resultPromise;
    resultPromise = (async () => {
      let {
        acrValues,
        maxAge,
        prompt,
        language,
        usePopup,
        authenticationContext,
        loginHint,
        noIframe
      } = options || {};
      if (acrValues == null) acrValues = this._defaultAcrValues;
      if (maxAge == null) maxAge = this._defaultMaxAge;
      if (usePopup == null) usePopup = true; // use login popup by default...
      usePopup = usePopup && this._popupEnabled; // ...unless globally disabled

      // NOTE Using synchronous variant (when prompt != "none") because typically this call is made after
      // clicking a button and we're going to show a popup window. Browsers will block the popup window unless
      // we open it within click event's lifetime or within single Promise (but not Promise chain because
      // that doesn't work on iPhones / Chrome). The sync variant works only if there already has been
      // async variant call, but that's sufficient for us, because we perform session initialization
      // with prompt == "none" (async) during this library's initialization.
      let authUri;
      let clientId;
      if (prompt === "none") {
        clientId = await ClientCredentialsProvider.getClientId(this._serviceName);
        authUri = await this._oauthClient.getAuthorizationUri(this.getResponseType(), this._defaultRedirectUri, clientId, acrValues, scope);
      } else {
        try {
          clientId = ClientCredentialsProvider.getClientIdSync(this._serviceName);
        } catch (e) {
          if (e instanceof SyncCallNotPossible) {
            this._logger.debug("Trying to reload client id on background.");
            ClientCredentialsProvider.getClientId(this._serviceName);
          }
          throw new BaseError(`Unable to get client credentials for service ${this._serviceName}: ${e.message}`, e);
        }
        try {
          authUri = this._oauthClient.getAuthorizationUriSync(this.getResponseType(), this._defaultRedirectUri, clientId, acrValues, scope);
        } catch (e) {
          if (e instanceof SyncCallNotPossible) {
            this._logger.debug("Trying to reload service metadata on background.");
            this._oauthClient.getMetadata();
          }
          throw new BaseError(`Unable to get metadata of service ${this._serviceName}: ${e.message}`, e);
        }
      }
      let nonce = Math.random().toString(32).substr(2);
      let state = Base64.urlSafeEncode(JSON.stringify(this.createAuthState(authenticationContext, usePopup)));
      let authFinalUri = this._addUriParams(authUri, {
        max_age: maxAge,
        login_hint: loginHint,
        prompt,
        state,
        nonce,
        language
      });
      let LoginVisualComponent = prompt !== "none" || noIframe ? usePopup ? PopupComponent : MainWindowComponent : IframeComponent;
      this._logger.debug(`Invoking authorization request: ${authFinalUri}`);
      let requestPromise = this.sendRequest(authFinalUri, LoginVisualComponent);
      if (resultPromise) resultPromise.uiComponent = requestPromise.uiComponent;else uiComponent = requestPromise.uiComponent;
      let authResponse = await requestPromise;
      return {
        authResponse,
        state,
        nonce,
        scope,
        acrValues,
        maxAge,
        clientId
      };
    })();
    if (uiComponent) resultPromise.uiComponent = uiComponent;
    return resultPromise;
  }
  getAuthResponseFromCallback(loginCallbackResult) {
    throw new Error("AbstractFlow.getAuthResponseFromCallback must be implemented on child class.");
  }
  async isCheckSessionSupported() {
    if (this._loadCheckSessionIframePromise == null) {
      this._loadCheckSessionIframePromise = this._loadCheckSessionIframe();
    }
    await this._loadCheckSessionIframePromise;
    return !!this._checkSessionIframe;
  }
  checkSession(query) {
    if (!this._runningCheckSessionPromise) {
      this._runningCheckSessionPromise = new Promise((resolve, reject) => {
        this._runningCheckSessionResolve = resolve;
        this.isCheckSessionSupported().then(supported => {
          if (!supported) {
            this._runningCheckSessionResolve = null;
            this._runningCheckSessionPromise = null;
            return reject(new BaseError("Check session is not supported."));
          }
          this._logger.debug(`Querying session state change from check session iframe. Query: ${query}`);
          this._checkSessionIframe.contentWindow.postMessage(query, this._iframeTrustedOrigin);
        });
      });
    }
    return this._runningCheckSessionPromise;
  }
  refreshSession(options, scope = null) {
    return this.authenticate(options, scope);
  }
  async getCallToken(options, scope = null) {
    let {
      idToken,
      accessToken,
      claims
    } = await this.authenticate(options, scope);
    let expireAt = claims.exp * 1000;
    return {
      idToken,
      accessToken,
      expireAt
    };
  }
  getEndSessionUri() {
    throw new Error("AbstractFlow.getEndSessionUri must be implemented on child class.");
  }
  isEndSessionIdTokenHintRequired() {
    return true;
  }
  async endSession(session) {
    let endSessionUri = this.getEndSessionUri();
    let idTokenHint = null;
    let useIdTokenHint = Config.getBoolean(CONFIG_PREFIX + session.getServiceName() + "_logout_token_hint_enabled");
    useIdTokenHint = useIdTokenHint != null ? useIdTokenHint : true;
    if (useIdTokenHint && this.isEndSessionIdTokenHintRequired()) {
      let cfgKey = `${CONFIG_PREFIX}${session.getServiceName()}_default_call_token_scope_mode`;
      let scopeMode = Config.getString(cfgKey) || DEFAULT_SCOPE_MODE;
      if (scopeMode === "none") {
        idTokenHint = session._idToken;
      } else {
        try {
          this._logger.debug("Obtaining token to be used as id_token_hint for end session request.");
          let opts = {
            callTokenType: "idToken",
            excludeAuthenticationType: true
          };
          idTokenHint = await session.getCallToken(endSessionUri, opts);
        } catch (e) {
          this._logger.warn("Unable to provide id_token_hint for end session request, using standard token.", e);
          idTokenHint = session._idToken;
        }
      }
    }
    // Parameter "post_logout_redirect_uri" can be sent only if token hint is given (without
    // token hint, redirect uri cannot be verified), or in case it is not required.
    if (idTokenHint || !this.isEndSessionIdTokenHintRequired()) {
      let postLogoutRedirectUri = Config.getString(CONFIG_POST_LOGOUT_REDIRECT_URI_KEY);
      if (postLogoutRedirectUri) {
        postLogoutRedirectUri = Dom.toFullAppUrl(postLogoutRedirectUri);
      } else {
        postLogoutRedirectUri = this._defaultRedirectUri;
      }
      endSessionUri += endSessionUri.includes("?") ? "&" : "?";
      endSessionUri += "post_logout_redirect_uri=" + encodeURIComponent(postLogoutRedirectUri);
      if (idTokenHint) {
        endSessionUri += "&id_token_hint=" + encodeURIComponent(idTokenHint);
      }
    }
    let logoutType = Config.getString(CONFIG_PREFIX + this._serviceName + LOGOUT_TYPE_CONFIG) || LOGOUT_DEFAULTS.type[this._serviceName];
    let width = Config.getNumber(CONFIG_PREFIX + this._serviceName + LOGOUT_POPUP_WIDTH_CONFIG) || LOGOUT_DEFAULTS.popupWidth[this._serviceName] || DEFAULT_POPUP_WIDTH;
    let height = Config.getNumber(CONFIG_PREFIX + this._serviceName + LOGOUT_POPUP_HEIGHT_CONFIG) || LOGOUT_DEFAULTS.popupHeight[this._serviceName] || DEFAULT_POPUP_HEIGHT;
    let LogoutVisualComponent = logoutType === "main" ? MainWindowComponent : logoutType === "popup" ? PopupComponent : IframeComponent;
    this._logger.debug(`Invoking end session request: ${endSessionUri}`);
    let resultPromise = new Promise((resolve, reject) => {
      new LogoutVisualComponent({
        width: width,
        height: height,
        url: endSessionUri,
        onResult: result => {
          if (result instanceof Error) {
            reject(result);
          } else {
            resolve();
          }
        }
      }).render();
    });
    return resultPromise;
  }
  sendRequest(uri, LoginVisualComponent = IframeComponent, getAuthResponseFromCallback = this.getAuthResponseFromCallback.bind(this)) {
    let uiComponent;
    let result = new Promise((resolve, reject) => {
      let width = Config.getNumber(CONFIG_PREFIX + this._serviceName + LOGIN_POPUP_WIDTH_CONFIG) || LOGIN_POPUP_DEFAULTS.width[this._serviceName] || DEFAULT_POPUP_WIDTH;
      let height = Config.getNumber(CONFIG_PREFIX + this._serviceName + LOGIN_POPUP_HEIGHT_CONFIG) || LOGIN_POPUP_DEFAULTS.height[this._serviceName] || DEFAULT_POPUP_HEIGHT;
      uiComponent = new LoginVisualComponent({
        width: width,
        height: height,
        url: uri,
        onResult: aLoginResult => {
          if (aLoginResult instanceof Error) return reject(aLoginResult);
          if (aLoginResult === false) return reject(new AuthenticationError("User refused to log in."));
          if (aLoginResult === PopupComponent.ERROR_POPUP_BLOCKED) return reject(new AuthenticationError("Login failed due to popup blocking."));
          let authResponse = getAuthResponseFromCallback(aLoginResult);

          // resolve the promise successfully with the token (iff there's no "error" field)
          if (authResponse.error) {
            let {
              error,
              error_description,
              uu_oidc_error_id,
              uu_oidc_error_code,
              ...rest
            } = authResponse;
            let errorCode = uu_oidc_error_code || error;
            let errorMessage = error_description || "Authentication error: " + error;
            let authnError;
            if (errorCode && errorCode.match(/(interaction|login|account_selection|consent)_required/i) || errorMessage && errorMessage.match(/interaction required/i)) {
              authnError = new InteractionRequired(errorMessage);
            } else {
              authnError = new AuthenticationError(errorMessage);
            }
            authnError.code = errorCode;
            if (uu_oidc_error_id) {
              authnError.id = uu_oidc_error_id;
            }
            Object.assign(authnError, rest);
            reject(authnError);
          } else {
            resolve(authResponse);
          }
        }
      });
      uiComponent.render();
    });
    result.uiComponent = uiComponent;
    return result;
  }
  async _loadCheckSessionIframe() {
    // add iframe with check_session_iframe URL
    await Dom.domReady;
    let iframeUrl = await this._oauthClient.getCheckSessionIframeUri();
    if (!iframeUrl) {
      this._logger.warn(`The OpenID Connect server ${this._oauthClient.getServiceUri()} doesn't support check_session_iframe endpoint.`);
      return;
    }
    return new Promise(resolve => {
      this._logger.debug(`Creating iframe with check_session_iframe endpoint URL: ${iframeUrl}`);
      let iframe = document.createElement("iframe");
      iframe.style.cssText = "position: absolute;top: -300px; left: -300px; width: 200px; height: 200px; opacity: 0;";
      iframe.tabIndex = "-1";
      iframe.onload = () => {
        this._iframeTrustedOrigin = iframeUrl.match(/^(https?:\/\/[^\/]+).*$/)[1] || null;
        this._checkSessionIframe = iframe;
        // add message handler for processing messages from the iframe
        window.addEventListener("message", this._onMessage.bind(this));
        resolve();
      };
      iframe.src = iframeUrl;
      document.body.appendChild(iframe);
    });
  }
  _onMessage(message) {
    this._logger.debug(`Received message from ${message.origin}: ${message.data}`);
    if (!this._checkSessionIframe || message.source !== this._checkSessionIframe.contentWindow || message.origin !== this._iframeTrustedOrigin) {
      this._logger.debug(`Message "${message.data}" from ${message.origin} is not from check session iframe, ignoring.`);
    } else {
      this._logger.debug(`Propagating session state "${message.data}" to listeners.`);
      if (this._runningCheckSessionResolve) {
        this._runningCheckSessionResolve(message.data);
      }
      this._runningCheckSessionResolve = null;
      this._runningCheckSessionPromise = null;
    }
  }
  _addUriParams(uri, params) {
    let paramParts = [];
    for (let k in params) {
      let v = params[k];
      if (v == null) continue;
      paramParts.push(encodeURIComponent(k) + "=" + encodeURIComponent(v + ""));
    }
    return uri + "&" + paramParts.join("&");
  }
}
module.exports = AbstractAuthorizationFlow;

/***/ }),

/***/ "./browser/internal/access-policy-verification-handler.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  Config
} = __webpack_require__("./browser/uu_appg01_core-utils.js");
const AuthenticationService = __webpack_require__("./browser/authentication-service.js");
let NOTIFICATION_DELAY = Config.getNumber("uu_app_oidc_unmet_access_policy_notification_delay") || 3000;
let errorReasonMap = null;
let notificationTimer = null;

/**
 * Interceptor for processing access policy verification errors, and firing
 * corresponding event on AuthenticationService to allow user re-authentication.
 */
class AccessPolicyVerificationHandler {
  constructor(next, options = null) {
    this._next = next;
    this._options = options || {};
  }
  async invoke(request, options = null) {
    try {
      return await this._next.invoke(request, options);
    } catch (e) {
      if (e.code === "uu-app-oidc/verifyAccessPolicy/untrustedSession" && e.paramMap) {
        this._recordError(e);
      }
      throw e;
    }
  }
  _recordError(e) {
    let errorReasonMap = this._getErrorReasonMap();
    let {
      maxAuthenticationAge,
      supportedAcrValues,
      deniedAuthenticationRealms
    } = e.paramMap;
    if (maxAuthenticationAge != null) {
      if (errorReasonMap.maxAuthenticationAge == null || errorReasonMap.maxAuthenticationAge > maxAuthenticationAge) {
        errorReasonMap.maxAuthenticationAge = maxAuthenticationAge;
      }
    }
    if (supportedAcrValues != null) {
      if (errorReasonMap.supportedAcrValues == null) {
        errorReasonMap.supportedAcrValues = supportedAcrValues;
      } else {
        errorReasonMap.supportedAcrValues = errorReasonMap.supportedAcrValues.filter(acr => supportedAcrValues.includes(acr));
      }
    }
    if (deniedAuthenticationRealms) {
      if (errorReasonMap.deniedAuthenticationRealms == null) {
        errorReasonMap.deniedAuthenticationRealms = deniedAuthenticationRealms;
      } else {
        deniedAuthenticationRealms.forEach(realm => {
          if (!errorReasonMap.deniedAuthenticationRealms.includes(realm)) {
            errorReasonMap.deniedAuthenticationRealms.push(realm);
          }
        });
      }
    }
  }
  _getErrorReasonMap() {
    if (errorReasonMap) {
      return errorReasonMap;
    }
    errorReasonMap = {};
    notificationTimer = setTimeout(() => {
      AuthenticationService._triggerEvent("untrustedSession", {
        ...errorReasonMap
      });
      errorReasonMap = null;
      notificationTimer = null;
    }, NOTIFICATION_DELAY);
    return errorReasonMap;
  }
}
module.exports = AccessPolicyVerificationHandler;

/***/ }),

/***/ "./browser/internal/browser-session.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {
  Config,
  Digest
} = __webpack_require__("./browser/uu_appg01_core-utils.js");
const {
  LoggerFactory
} = __webpack_require__("./browser/uu_appg01_core-logging.js");
const OidcSession = __webpack_require__("./session.js");
const ExternalCallTokenProvider = __webpack_require__("./browser/internal/external-call-token-provider.js");
const Dom = __webpack_require__("./browser/ui/dom.js");
const STORE_PREFIX = "uu_app_oidc_providers_";
const CONFIG_PREFIX = "uu_app_oidc_providers_";
const JWT_CLAIM_EXP = "exp";

// TODO Constant for workaround to allow sending of word values to G01
const G02_ACR_VALUES_OLD = ["none", "low", "medium", "high", "veryHigh"];
const G02_ACR_VALUES = ["none", "low", "standard", "high", "veryHigh"];
const logger = LoggerFactory.get("uuapp.oidc.Session");
const isNestedUri = function (nestedUri, rootUri) {
  let nestedUriElements = nestedUri.toString().split("/");
  let rootUriElements = rootUri.toString().split("/");
  if (rootUriElements.length > nestedUriElements.length) {
    return false;
  }
  for (let i = 0; i < rootUriElements.length; i++) {
    if (rootUriElements[i] !== nestedUriElements[i]) {
      return false;
    }
  }
  return true;
};
class BrowserSession {
  static from(session, authenticationContext, expiresAt, state, authnService) {
    if (!session) return session;

    // Cache base uri without trailing slashes (to be used when call token is requested)
    session._appBaseUri = Dom.appBaseUri.replace(/\/$/, "");

    // Add frontend specific method for returning authentication context
    session._authnCtx = authenticationContext || null;
    session.getAuthenticationContext = function () {
      return this._authnCtx;
    }.bind(session);

    // Add frontend specific method for returning session expiration time
    session._expiresAt = expiresAt || null;
    session.getExpiresAt = function () {
      return this._expiresAt;
    }.bind(session);

    // Add frontend specific method for returning session state
    session._state = state || null;
    session.getState = function () {
      return this._state;
    }.bind(session);

    // Add frontend specific field authnService required by ExternalCallTokenProvider
    Object.defineProperty(session, "_authnService", {
      get() {
        return authnService;
      },
      enumerable: false
    });

    // Override session.getCallTokenScope in order to provide
    // valid scope also for application using aliases
    session._origGetCallTokenScope = session.getCallTokenScope.bind(session);
    session.getCallTokenScope = function (uri = null, opts = {}) {
      if (!uri) {
        return null;
      }
      let scope;
      if (isNestedUri(uri, this._appBaseUri)) {
        scope = this._appBaseUri;
      } else {
        scope = this._origGetCallTokenScope(uri, opts);
      }
      return scope;
    }.bind(session);

    // Override session.getCallToken to support providing of tokens
    // for external calls without use of token exchange which is not
    // possible to realize on frontend
    session.getCallToken = async function (scope = null, opts = {}) {
      let token;
      if (scope == null || !isNestedUri(scope, this._appBaseUri)) {
        // Calls from aliased page to own backend via canonical URL are always
        // treated as external calls, as we need to do these calls with token
        // due to application session cookie is bound to another domain/path.
        token = await ExternalCallTokenProvider.getCallToken(session, scope, opts);
      } else {
        let callTokenType = opts ? opts.callTokenType : null;
        if (!callTokenType) {
          let cfgKey = `${this._configPrefix}call_token_type`;
          callTokenType = Config.getString(cfgKey);
        }
        if (callTokenType === "idToken") {
          token = this._idToken;
        } else if (callTokenType === "accessToken") {
          token = this._accessToken;
        } else if (!callTokenType) {
          token = this._idToken || this._accessToken;
        }
      }
      if (token) {
        let excludeAuthType = opts ? opts.excludeAuthenticationType : false;
        if (excludeAuthType === true) {
          return token;
        } else {
          return `Bearer ${token}`;
        }
      } else {
        return null;
      }
    }.bind(session);

    // Override session.actAs() to invoke authentication with login hint
    // in order to switch user on frontend.
    session.actAs = async function (uuIdentity, scope = null, opts = {}) {
      if (scope != null && typeof scope !== "string" && !Array.isArray(scope)) {
        opts = scope;
        scope = null;
      }
      opts = {
        ...opts
      };
      delete opts.prompt;
      opts.loginHint = uuIdentity;
      if (opts.usePopup == null) {
        opts.usePopup = false;
      }
      this.removeFromCache();
      return await this._authnService.authenticate(opts, scope);
    };

    // Override session.close() to perform logout in browser environment
    session.close = async function () {
      this.removeFromCache();
      if (this._authenticated) {
        try {
          await session._authnService._authnFlow.endSession(session);
          if (typeof this._onCloseListener === "function") {
            this._onCloseListener(this);
          }
          session._authenticated = false;
          session._idToken = null;
          session._accessToken = null;
        } catch (e) {
          logger.warn("Logout finished but session might not be cancelled - server responded with unexpected callback.", e);
          // Invoke explicit session check which will cause logout in case session was successfully canceled
          session._authnService.checkSession();
        }
      }
    }.bind(session);

    // Add frontend specific method to check if session matches given constraints
    session.matches = function (acrValues, maxAge) {
      let minAuthenticationLevelOfAssurance;
      if (acrValues) {
        let supportedValues = this._supportedAcrValues;
        // TODO Workaround for renaming of "medium" acrValue on G02 server
        let requestedValuesStr = acrValues.toString();
        if (supportedValues.includes("medium")) {
          requestedValuesStr = requestedValuesStr.replace("standard", "medium");
        } else if (supportedValues.includes("standard")) {
          requestedValuesStr = requestedValuesStr.replace("medium", "standard");
        }
        // ...end of workaround
        // Transform all values to number and find minimum (so we can delegate
        // call to session.assertTrustiness)
        let requestedValues = requestedValuesStr.split(" ");
        let transformedValues = [];
        requestedValues.forEach(requestedValue => {
          let transformedValue = Number(requestedValue);
          if (isNaN(transformedValue)) {
            transformedValue = supportedValues.indexOf(requestedValue);
            // TODO Workaround for checking word values against G01
            if (transformedValue < 0) {
              transformedValue = G02_ACR_VALUES.indexOf(requestedValue);
            }
            if (transformedValue < 0) {
              transformedValue = G02_ACR_VALUES_OLD.indexOf(requestedValue);
            }
            // ...end of workaround
          }

          if (transformedValue >= 0) {
            transformedValues.push(transformedValue);
          }
        });
        minAuthenticationLevelOfAssurance = Math.min(...transformedValues);
      }
      let maxAuthenticationAge;
      if (maxAge) {
        maxAuthenticationAge = maxAge;
      }
      try {
        this.assertTrustiness({
          minAuthenticationLevelOfAssurance,
          maxAuthenticationAge
        });
        return true;
      } catch (e) {
        return false;
      }
    }.bind(session);

    // Add frontend specific method to store session to session store
    session.storeToCache = function (clientId = null) {
      let sessionData = {
        attributes: this._attributes,
        acrValues: this._supportedAcrValues,
        idToken: this._idToken,
        acccessToken: this._accessToken,
        authnCtx: this._authnCtx,
        expiresAt: this._expiresAt,
        state: this._state,
        authConstraints: this._authConstraints,
        userAgent: Digest.sha1(navigator.userAgent)
      };
      let storeKey = `${STORE_PREFIX}${this._serviceName}_session`;
      if (clientId) {
        storeKey += `_${Digest.sha1(clientId)}`;
      }
      sessionStorage.setItem(storeKey, JSON.stringify(sessionData));
    }.bind(session);

    // Add frontend specific method to remove session from session store
    session.removeFromCache = function () {
      let storeKey = `${STORE_PREFIX}${this._serviceName}_session`;
      Object.keys(sessionStorage).forEach(key => {
        if (key && key.toString().startsWith(storeKey)) {
          sessionStorage.removeItem(key);
        }
      });
    }.bind(session);
    return session;
  }
  static loadFromCache(authnService, clientId = null) {
    let serviceName = authnService.getServiceName();
    let storeKey = `${STORE_PREFIX}${serviceName}_session`;
    if (clientId) {
      storeKey += `_${Digest.sha1(clientId)}`;
    }
    let sessionData = sessionStorage.getItem(storeKey);
    if (!sessionData) {
      return null;
    }
    try {
      sessionData = JSON.parse(sessionData);
      let now = Date.now() / 1000;
      let tokenExpiresAt = sessionData.attributes[JWT_CLAIM_EXP];
      let tokenLeeway = Config.getNumber(CONFIG_PREFIX + serviceName + "_token_refresh_leeway");
      if (tokenLeeway == null) tokenLeeway = 5 * 60;
      if (sessionData.expiresAt && sessionData.expiresAt <= now || tokenExpiresAt && tokenExpiresAt - tokenLeeway <= now) {
        logger.warn(`Cached session for ${serviceName} is expired.`);
        sessionStorage.removeItem(storeKey);
        return null;
      }
      if (sessionData.userAgent != Digest.sha1(navigator.userAgent)) {
        logger.warn(`UserAgent does not match on cached session for service ${serviceName}.`);
        sessionStorage.removeItem(storeKey);
        return null;
      }
      let oauthClient = authnService._oauthClient;
      let session = new OidcSession(serviceName, oauthClient, sessionData.acrValues, sessionData.attributes, sessionData.idToken, sessionData.acccessToken);
      session._authConstraints = sessionData.authConstraints;
      return BrowserSession.from(session, sessionData.authnCtx, sessionData.expiresAt, sessionData.state, authnService);
    } catch (e) {
      logger.error(`Unable to restore cached session for ${serviceName}.`, e);
      return null;
    }
  }
}
module.exports = BrowserSession;

/***/ }),

/***/ "./browser/internal/client-credentials-provider.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  Config,
  LruCache,
  Base64
} = __webpack_require__("./browser/uu_appg01_core-utils.js");
const {
  AppClient,
  PerflogHandler,
  RemoteErrorHandler,
  TransformParametersHandler,
  ApplicationError
} = __webpack_require__("./browser/uu_appg01_core-appclient.js");
const {
  LoggerFactory
} = __webpack_require__("./browser/uu_appg01_core-logging.js");
const SyncCallNotPossible = __webpack_require__("./internal/sync-call-not-possible.js");
const Dom = __webpack_require__("./browser/ui/dom.js");
const APP_CLIENT_INTERCEPTORS = [PerflogHandler, RemoteErrorHandler, TransformParametersHandler];
const CLIENT_ID_CACHE_SIZE = 256;
const CLIENT_ID_CACHE_TTL = 60 * 60 * 1000;
const CLIENT_ID_CACHE_STORAGE_KEY = "uu_app_oidc_cache_client_id";
const CLIENT_ID_CACHE = new LruCache({
  maxSize: CLIENT_ID_CACHE_SIZE,
  maxAge: CLIENT_ID_CACHE_TTL,
  localStorageKey: CLIENT_ID_CACHE_STORAGE_KEY
});
const LOGGER = LoggerFactory.get("uuapp.oidc.ClientCredentialsProvider");
const CONFIG_PREFIX = "uu_app_oidc_providers_";
const CLIENT_ID_SUFFIX = "_client_id";
const UNREGISTERED_ID_SUFFIX = "_unregistered_client_id";
const UNREGISTERED_CLIENT_ID_PREFIX = "uu-oidc:unregistered-client:";
// TODO Generate default client name based on fingerprint
const DEFAULT_CLIENT_NAME = Math.random().toString(16).substring(2, 10);

/**
 * Browser implementation of client credentials provider allowing of
 * dynamically loading client credentials (client_id) from backend.
 */
class ClientCredentialsProvider {
  /**
   * Returns OIDC client id for given service.
   * @param serviceName Name of registered authentication service.
   * @returns {Object} Client credentials
   */
  static async getClientId(serviceName) {
    let cacheKey = Base64.encode(`${Dom.appBaseUri}:${serviceName}`);
    let clientId = CLIENT_ID_CACHE.get(cacheKey) || Config.getString(`${CONFIG_PREFIX}${serviceName}${CLIENT_ID_SUFFIX}`);
    if (!clientId) {
      let result = null;
      try {
        let dtoIn = {
          serviceName: serviceName
        };
        let opts = {
          interceptors: APP_CLIENT_INTERCEPTORS
        };
        result = await AppClient.get(`${Dom.appBaseUri}oidc/getClientId`, dtoIn, opts);
        clientId = result.data.clientId;
      } catch (e) {
        if (e instanceof ApplicationError && e.status === 404) {
          // We are probably using legacy backend without new endpoint. Provide default credentials of unregistered client.
          LOGGER.warn(`Backend does not provide "oidc/getClientId" endpoint and custom configuration of clientId is not available. Using unregistered client.`);
          clientId = Config.get(`${CONFIG_PREFIX}${serviceName}${UNREGISTERED_ID_SUFFIX}`) || `${UNREGISTERED_CLIENT_ID_PREFIX}${DEFAULT_CLIENT_NAME}`;
        } else {
          throw e;
        }
      }
      CLIENT_ID_CACHE.set(cacheKey, clientId);
    }
    // Static cache is used to allow eviction of standard cache while
    // allow calling of getClientCredentialsSync in case cache was
    // evicted between asynchronous and synchronous invocation.
    this._clientIds[cacheKey] = clientId;
    return clientId;
  }

  /**
   * Returns OIDC client id for given service.
   * @param serviceName Name of registered authentication service.
   * @returns {Object} Client credentials
   */
  static getClientIdSync(serviceName) {
    let cacheKey = Base64.encode(`${Dom.appBaseUri}:${serviceName}`);
    let clientId = this._clientIds[cacheKey];
    if (!clientId) {
      throw new SyncCallNotPossible("Asynchronous method getClientId or getClientCredentials must be invoked prior to synchronous invocation");
    }
    return clientId;
  }

  /**
   * Returns OIDC client credentials for given service.
   * @param serviceName Name of registered authentication service.
   * @returns {Object} Client credentials
   */
  static async getClientCredentials(serviceName) {
    let clientId = await this.getClientId(serviceName);
    return {
      client_id: clientId,
      client_secret: null
    };
  }

  /**
   * Returns OIDC client credentials for given service.
   * @param serviceName Name of registered authentication service.
   * @returns {Object} Client credentials
   */
  static getClientCredentialsSync(serviceName) {
    let clientId = this.getClientIdSync(serviceName);
    return {
      client_id: clientId,
      client_secret: null
    };
  }
}

// Static "cache" for sync method
ClientCredentialsProvider._clientIds = {};
module.exports = ClientCredentialsProvider;

/***/ }),

/***/ "./browser/internal/code-flow-v2.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  AppClient
} = __webpack_require__("./browser/uu_appg01_core-appclient.js");
const ClientCredentialsProvider = __webpack_require__("./browser/internal/client-credentials-provider.js");
const {
  AuthenticationError
} = __webpack_require__("./browser/uu_appg01_core-authentication.js");
const AbstractAuthorizationFlow = __webpack_require__("./browser/internal/abstract-authorization-flow.js");
const CodeFlow = __webpack_require__("./browser/internal/code-flow.js");
const InteractionRequired = __webpack_require__("./browser/interaction-required.js");
const RESTORE_SESSION_FORCED = "forced";
const WINDOW = location.href.startsWith("about:") && window.frameElement ? parent : window;
const CSRF_COOKIE = new RegExp("uu.app.csrf=([^;]+)");

/**
 * Implementation of code flow with mitigation for thirdparty cookies.
 * (uses redirect for session restore, command for refresh and calltoken)
 */
class CodeFlowV2 extends CodeFlow {
  constructor(oauthClient, serviceName, redirectUri, appBaseUri) {
    super(oauthClient, serviceName, redirectUri);
    this._oauthClient = oauthClient;
    this._serviceName = serviceName;
    this._redirectUri = redirectUri;
    this._appBaseUri = appBaseUri;
    this._client = new AppClient();
    this._doOnlyLocalSessionCheck = false;
  }
  async restoreSession(options, scope) {
    let isAuthCallback = sessionStorage.getItem("uu_app_oidc_auth_cb");
    sessionStorage.removeItem("uu_app_oidc_auth_cb");
    let result = await this._restoreSessionViaAppSession(options, scope);
    let resultValid = result && this._assertConstraints(result.claims, options, isAuthCallback);
    if (!resultValid && !isAuthCallback) {
      result = await this._resotreSessionViaIdpSession(options, scope);
    }
    if (!result) {
      // We have to load asynchronous data, else interactive login will fail.
      await this._oauthClient.getMetadata();
      await ClientCredentialsProvider.getClientId(this._serviceName);
      this._throwInteractionRequired();
    }
    return result;
  }
  async checkSession(query) {
    let result;
    if (this._doOnlyLocalSessionCheck) {
      return this._isSessionValid() ? "unchanged" : "changed";
    } else {
      result = await super.checkSession(query);
      if (result === "unknown") {
        this._logger.warn("Switching global session check to application session check due to blocked thirdparty cookies.");
        this._doOnlyLocalSessionCheck = true;
        result = "unchanged";
      }
    }
    return result;
  }
  async refreshSession(options, scope = null) {
    if (!this._isSessionValid()) {
      this._throwInteractionRequired();
    }
    let authResponseTime = Date.now();
    let claims;
    try {
      claims = (await this._client.post(this._appBaseUri + "oidc/extendSession")).data;
    } catch (e) {
      if (e.status && e.status === 401) {
        this._throwInteractionRequired(e);
      } else {
        throw e;
      }
    }
    this._assertConstraints(claims, options, true);
    let globalSessionExpiresAt = authResponseTime + 1000 * claims.session_info.session_expires_in;
    let globalSessionState = claims.session_info.session_state;
    let clientId = claims.session_info.client_id;
    delete claims.session_info;
    delete claims.uuAppErrorMap;
    return {
      claims,
      globalSessionExpiresAt,
      globalSessionState,
      clientId
    };
  }
  async getCallToken(options, scope = null) {
    let grantResult = (await this._client.post(this._appBaseUri + "oidc/grantCallToken", {
      scope
    })).data;
    let expireAt = Date.now() + grantResult.expires_in * 1000;
    return {
      idToken: grantResult.id_token,
      accessToken: grantResult.access_token,
      expireAt
    };
  }
  async _restoreSessionViaAppSession(options, scope) {
    this._logger.debug("Trying to restore session based on existing application session.");
    if (!this._isSessionValid()) {
      this._logger.debug("Application session not found.");
      return null;
    }
    let authResponseTime = Date.now();
    let claims;
    try {
      claims = (await this._client.get(this._appBaseUri + "oidc/introspect", {
        _: Date.now()
      })).data;
    } catch (e) {
      this._logger.debug("Restoring of session based on existing application session failed.", e);
      return null;
    }
    if (!claims || !claims.session_info) {
      this._logger.debug("Application session not found.");
      return null;
    }
    let globalSessionExpiresAt = authResponseTime + 1000 * claims.session_info.session_expires_in;
    let globalSessionState = claims.session_info.session_state;
    let clientId = claims.session_info.client_id;
    delete claims.session_info;
    delete claims.uuAppErrorMap;
    let acrValues = options.acrValues || this._defaultAcrValues;
    let maxAge = options.maxAge || this._defaultMaxAge;
    let authenticationContext = sessionStorage.getItem("uu_app_oidc_auth_ctx");
    if (authenticationContext) {
      authenticationContext = JSON.parse(authenticationContext);
      sessionStorage.removeItem("uu_app_oidc_auth_ctx");
    }
    return {
      claims,
      idToken: null,
      accessToken: null,
      authenticationContext,
      globalSessionExpiresAt,
      globalSessionState,
      clientId,
      scope,
      acrValues,
      maxAge
    };
  }
  async _resotreSessionViaIdpSession(options, scope) {
    this._logger.debug("Restoring session by redirection to configured identity provider.");
    // We have to load metadata, else redirect will not work
    // due to requirement of metadata being available locally
    await this._oauthClient.getMetadata();
    options = {
      ...options,
      usePopup: false,
      prompt: "none",
      noIframe: true
    };
    if (AbstractAuthorizationFlow.getRestoreSessionOnLoad() === RESTORE_SESSION_FORCED) {
      delete options.prompt;
    }
    // Store current referrer to provide it after redirect
    sessionStorage.setItem("uu_app_oidc_auth_referrer", document.referrer);
    return this.authenticate(options, scope);
  }
  async _assertConstraints(claims, options, throwError) {
    let acrValues = options.acrValues || this._defaultAcrValues;
    if (acrValues && !acrValues.includes(claims.acr)) {
      if (throwError) {
        this._throwInteractionRequired();
      } else {
        return false;
      }
    }
    let maxAge = options.maxAge || this._defaultMaxAge;
    if (maxAge && (claims.auth_time + maxAge) * 1000 < Date.now()) {
      if (throwError) {
        this._throwInteractionRequired();
      } else {
        return false;
      }
    }
  }
  _isSessionValid() {
    let csrfToken = (CSRF_COOKIE.exec(WINDOW.document.cookie) || [])[1];
    if (!csrfToken) {
      return false;
    }
    let tokenParts = csrfToken.split(".");
    if (tokenParts.length === 3) {
      // Token with expiration (newer version of backend)
      return Number(tokenParts[0]) * 1000 > Date.now() ? true : false;
    } else {
      // Token without expiration (older version of backend)
      return true;
    }
  }
  _throwInteractionRequired(cause = null) {
    let error = new InteractionRequired("Authentication Request cannot be completed without displaying a user interface for End-User interaction.", cause);
    error.code = "interaction_required";
    throw error;
  }
}
module.exports = CodeFlowV2;

/***/ }),

/***/ "./browser/internal/code-flow.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  AuthenticationError
} = __webpack_require__("./browser/uu_appg01_core-authentication.js");
const {
  AppClient
} = __webpack_require__("./browser/uu_appg01_core-appclient.js");
const AbstractAuthorizationFlow = __webpack_require__("./browser/internal/abstract-authorization-flow.js");
const ImplicitFlow = __webpack_require__("./browser/internal/implicit-flow.js");
const RESPONSE_TYPE = "code";
const RESTORE_SESSION_FORCED = "forced";
const WINDOW = location.href.startsWith("about:") && window.frameElement ? parent : window;
const CSRF_COOKIE = new RegExp("uu.app.csrf=([^;]+)");
class CodeFlow extends AbstractAuthorizationFlow {
  constructor(oauthClient, serviceName, redirectUri, appBaseUri) {
    super(oauthClient, serviceName, redirectUri);
    this._oauthClient = oauthClient;
    this._serviceName = serviceName;
    this._redirectUri = redirectUri;
    this._appBaseUri = appBaseUri;
    this._client = new AppClient();
    // Code based flow uses implicit flow to obtain call token for external services
    this._implicitFlow = new ImplicitFlow(oauthClient, serviceName, redirectUri, appBaseUri);
  }
  getResponseType() {
    return RESPONSE_TYPE;
  }
  createAuthState(authCtx = null, usePopup = null) {
    let result = super.createAuthState(authCtx, usePopup);
    result.redirectUri = this._redirectUri;
    return result;
  }
  async restoreSession(options, scope = null) {
    let isAuthCallback = sessionStorage.getItem("uu_app_oidc_auth_cb");
    sessionStorage.removeItem("uu_app_oidc_auth_cb");
    options = {
      prompt: "none",
      ...options
    };
    if (!isAuthCallback && AbstractAuthorizationFlow.getRestoreSessionOnLoad() === RESTORE_SESSION_FORCED) {
      // We have to load metadata, else redirect will not work
      // due to requirement of metadata being available locally
      await this._oauthClient.getMetadata();
      delete options.prompt;
      options.usePopup = false;
      // Store current referrer to provide it after redirect
      sessionStorage.setItem("uu_app_oidc_auth_referrer", document.referrer);
    }
    return super.restoreSession(options, scope);
  }
  authenticate(options, scope = null) {
    let promise = super.authenticate(options, scope);
    let result = promise.then(({
      authResponse,
      state,
      nonce,
      scope,
      acrValues,
      maxAge,
      clientId
    }) => {
      return this._processAuthResponse(authResponse, state, nonce, scope, acrValues, maxAge, clientId);
    });
    result.uiComponent = promise.uiComponent;
    return result;
  }

  /**
   * @param {*} aLoginCallbackResult
   * @returns OpenID Authentication Response with fields such as id_token, token_type, issued_at, ...
   */
  getAuthResponseFromCallback(aLoginCallbackResult) {
    // extract login token
    // example of successful aLoginCallbackResult: "...?code=...&state=...
    // example of error aLoginCallbackResult:      "...?error=server_error&error_description=Interaction+required+to+authenticate+user%2C+but+parameter+%27prompt%3Dnone%27+specified+by+client%2C+so+interaction+is+not+possible.&uu_oidc_error_id=047a06f806d1b13-6f55e2af8c2ff99d&uu_oidc_error_code=UU.OIDC-SERVER%2FE000_UNEXPECTED_ERROR"
    let authResponse = {};
    aLoginCallbackResult.replace(/^[^?#]*[?#]?/, "").replace(/#/, "&").split(/&/).filter(Boolean).forEach(it => {
      let eqlIdx = it.indexOf("=");
      let key = decodeURIComponent((eqlIdx == -1 ? it.substr(0) : it.substr(0, eqlIdx)).replace(/\+/g, " "));
      let value = decodeURIComponent((eqlIdx == -1 ? "" : it.substr(eqlIdx + 1)).replace(/\+/g, " "));
      authResponse[key] = value;
    });
    return authResponse;
  }
  refreshSession(options, scope = null) {
    options = {
      prompt: "none",
      usePopup: false,
      ...options
    };
    return super.refreshSession(options, scope);
  }
  getCallToken(options, scope = null) {
    return this._implicitFlow.getCallToken(options, scope);
  }
  getEndSessionUri() {
    let endSessionUri = this._appBaseUri + "oidc/logout";
    let csrfToken = (CSRF_COOKIE.exec(WINDOW.document.cookie) || [])[1];
    if (csrfToken) {
      endSessionUri += `?csrf_token=${encodeURIComponent(csrfToken)}`;
    }
    return endSessionUri;
  }
  isEndSessionIdTokenHintRequired() {
    return false;
  }

  // ======================== Protected methods ================================

  async _processAuthResponse(authResponse, state, nonce, scope, acrValues, maxAge, clientId) {
    let authResponseTime = Date.now();
    await this._validateAuthResponse(authResponse, state, nonce);
    let claims = (await this._client.get(this._appBaseUri + "oidc/introspect", {
      _: Date.now()
    })).data;
    delete claims.session_info;
    delete claims.uuAppErrorMap;
    let {
      session_expires_in,
      session_state
    } = authResponse;
    let globalSessionExpiresAt = session_expires_in ? authResponseTime + 1000 * session_expires_in : null;
    sessionStorage.removeItem("uu_app_oidc_auth_cb");
    let authenticationContext = sessionStorage.getItem("uu_app_oidc_auth_ctx");
    if (authenticationContext) {
      authenticationContext = JSON.parse(authenticationContext);
      sessionStorage.removeItem("uu_app_oidc_auth_ctx");
    }
    return {
      claims: claims,
      idToken: null,
      accessToken: null,
      authenticationContext: authenticationContext,
      globalSessionExpiresAt: globalSessionExpiresAt,
      globalSessionState: session_state,
      clientId: clientId,
      scope: scope,
      acrValues: acrValues,
      maxAge: maxAge
    };
  }

  // ======================== Private methods ================================

  async _validateAuthResponse(authResponse, state, nonce) {
    // validate state
    if (state && authResponse.state !== state) {
      throw new AuthenticationError("Invalid 'state' in received authorization response. Expected " + state + " but got " + authResponse.state + ". Response: " + JSON.stringify(authResponse));
    }
  }
}
module.exports = CodeFlow;

/***/ }),

/***/ "./browser/internal/external-call-token-provider.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  Config
} = __webpack_require__("./browser/uu_appg01_core-utils.js");
const {
  LoggerFactory
} = __webpack_require__("./browser/uu_appg01_core-logging.js");
const Dom = __webpack_require__("./browser/ui/dom.js");
const CONFIG_PREFIX = "uu_app_oidc_providers_";
const DEFAULT_TOKEN_TIME_LEEWAY = 5 * 60;

/**
 * Component providing tokens for external calls
 * (call to URLs outside of current application scope)
 */
class ExternalCallTokenProvider {
  /**
   * Returns token to be used by client to call functionality provided by other application server.
   * @param {Session} currentSession Instance of current session in which scope we are requesting token.
   * @param {String|URI} callUri URI of called functionality.
   * @param {Object} opts Call token options.
   * @param {boolean|null} opts.callTokenType Variant of call token (possible values depends on actual authentication implementation).
   * @returns {Promise<String>} Call token
   */
  static async getCallToken(currentSession, callUri, opts) {
    let serviceName = currentSession.getServiceName();
    if (!serviceName || !currentSession._oauthClient) {
      return null;
    }
    callUri = callUri ? callUri.toString() : "";
    let providerKey = `${serviceName}|${callUri}`;
    let provider = this._providers[providerKey];
    if (!provider) {
      provider = new this(currentSession, callUri);
      this._providers[providerKey] = provider;
    }
    let sub = currentSession.getAttribute("sub");
    let authTime = currentSession.getAttribute("auth_time");
    return provider._getCallToken(sub, authTime, opts);
  }

  /**
   * Creates new external call token provider.
   * @param {Session} currentSession Instance of current session in which scope we are requesting token.
   * @param {String} callUri Call URI for which to provide token
   */
  constructor(currentSession, callUri) {
    this._serviceName = currentSession.getServiceName();
    this._callUri = callUri;
    this._configPrefix = `${CONFIG_PREFIX}${this._serviceName}_`;
    this._tokenTimeLeeway = Config.getNumber(`${this._configPrefix}token_time_leeway`, false) || DEFAULT_TOKEN_TIME_LEEWAY;
    this._logger = LoggerFactory.get("uuapp.oidc.ExternalCallTokenProvider");
    this._authnFlow = currentSession._authnService._authnFlow;
    this._runningPromise = null;
    this._idToken = null;
    this._accessToken = null;
    this._expireAt = null;
    this._baseUri = null;
    this._sub = null;
    this._authTime = null;
  }
  async _getCallToken(sub, authTime, opts = {}) {
    if (!this._isValid(sub, authTime)) {
      if (!this._runningPromise) {
        this._logger.debug(`Requesting new call token for ${this._callUri}`);
        let authOpts = {
          prompt: "none",
          usePopup: false
        };
        if (this._authnFlow.getCallToken) {
          this._runningPromise = this._authnFlow.getCallToken(authOpts, this._callUri);
        } else {
          this._runningPromise = this._authnFlow.authenticate(authOpts, this._callUri);
        }
      }
      try {
        let {
          idToken,
          accessToken,
          claims,
          expireAt
        } = await this._runningPromise;
        this._idToken = idToken;
        this._accessToken = accessToken;
        if (expireAt) {
          this._expireAt = expireAt;
        } else {
          this._expireAt = claims.exp * 1000;
        }
        this._baseUri = Dom.appBaseUri;
        this._sub = sub;
        this._authTime = authTime;
        this._logger.debug(`Call token for ${this._callUri} received`);
      } catch (e) {
        this._logger.error(`Unable to get call token for ${this._callUri}`, e);
        return null;
      } finally {
        this._runningPromise = null;
      }
    }
    let token = null;
    let callTokenType = opts ? opts.callTokenType : null;
    if (!callTokenType) {
      let cfgKey = `${this._configPrefix}call_token_type`;
      callTokenType = Config.getString(cfgKey);
    }
    if (callTokenType === "idToken") {
      token = this._idToken;
    } else if (callTokenType === "accessToken") {
      token = this._accessToken;
    } else if (!callTokenType) {
      token = this._idToken || this._accessToken;
    }
    return token;
  }
  _isValid(sub, authTime) {
    return this._baseUri === Dom.appBaseUri && this._sub === sub && this._authTime === authTime && !this._isExpired();
  }
  _isExpired() {
    if (!this._expireAt) {
      return true;
    }
    return Date.now() >= this._expireAt - this._tokenTimeLeeway * 2;
  }
}
ExternalCallTokenProvider._providers = {};
module.exports = ExternalCallTokenProvider;

/***/ }),

/***/ "./browser/internal/implicit-flow.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  AuthenticationError
} = __webpack_require__("./browser/uu_appg01_core-authentication.js");
const AbstractAuthorizationFlow = __webpack_require__("./browser/internal/abstract-authorization-flow.js");
const RESPONSE_TYPE = "id_token token";
const RESTORE_SESSION_FORCED = "forced";
class ImplicitFlow extends AbstractAuthorizationFlow {
  constructor(oauthClient, serviceName, redirectUri, appBaseUri) {
    super(oauthClient, serviceName, redirectUri);
    this._oauthClient = oauthClient;
    this._serviceName = serviceName;
  }
  getResponseType() {
    return RESPONSE_TYPE;
  }
  async restoreSession(options, scope = null) {
    let isAuthCallback = sessionStorage.getItem("uu_app_oidc_auth_cb");
    sessionStorage.removeItem("uu_app_oidc_auth_cb");
    options = {
      prompt: "none",
      ...options
    };
    if (!isAuthCallback && AbstractAuthorizationFlow.getRestoreSessionOnLoad() === RESTORE_SESSION_FORCED) {
      // We have to load metadata, else redirect will not work
      // due to requirement of metadata being available locally
      await this._oauthClient.getMetadata();
      delete options.prompt;
      options.usePopup = false;
      // Store current referrer to provide it after redirect
      sessionStorage.setItem("uu_app_oidc_auth_referrer", document.referrer);
    }
    return super.restoreSession(options, scope);
  }
  authenticate(options, scope = null) {
    let promise = super.authenticate(options, scope);
    let result = promise.then(({
      authResponse,
      state,
      nonce,
      scope,
      acrValues,
      maxAge,
      clientId
    }) => {
      return this._processAuthResponse(authResponse, state, nonce, scope, acrValues, maxAge, clientId);
    });
    result.uiComponent = promise.uiComponent;
    return result;
  }

  /**
   * @param {*} aLoginCallbackResult
   * @returns OpenID Authentication Response with fields such as id_token, token_type, issued_at, ...
   */
  getAuthResponseFromCallback(aLoginCallbackResult) {
    // extract login token
    // example of successful aLoginCallbackResult: "...#access_token=UUOIDCAT-27a13a6e626a40c49e036cbab55f3e27&id_token=eyJ0eXAiOi...&token_type=Bearer&expires_in=7200&scope=openid"
    // example of error aLoginCallbackResult:      "...#error=server_error&error_description=Interaction+required+to+authenticate+user%2C+but+parameter+%27prompt%3Dnone%27+specified+by+client%2C+so+interaction+is+not+possible.&uu_oidc_error_id=047a06f806d1b13-6f55e2af8c2ff99d&uu_oidc_error_code=UU.OIDC-SERVER%2FE000_UNEXPECTED_ERROR"
    let authResponse = {};
    aLoginCallbackResult.replace(/^[^#]*#?/, "").split(/&/).forEach(it => {
      let eqlIdx = it.indexOf("=");
      let key = decodeURIComponent((eqlIdx == -1 ? it.substr(0) : it.substr(0, eqlIdx)).replace(/\+/g, " "));
      let value = decodeURIComponent((eqlIdx == -1 ? "" : it.substr(eqlIdx + 1)).replace(/\+/g, " "));
      authResponse[key] = value;
    });
    return authResponse;
  }
  refreshSession(options, scope = null) {
    options = {
      prompt: "none",
      usePopup: false,
      ...options
    };
    return super.refreshSession(options, scope);
  }
  getEndSessionUri() {
    return this._oauthClient.getEndSessionUriSync();
  }

  // ======================== Protected methods ================================

  async _processAuthResponse(authResponse, state, nonce, scope, acrValues, maxAge, clientId) {
    // NOTE Used from Os8Flow too.
    let authResponseTime = Date.now();
    let claims = await this._validateAuthResponse(authResponse, state, nonce);
    let {
      id_token,
      access_token,
      session_expires_in,
      session_state
    } = authResponse;
    let globalSessionExpiresAt = session_expires_in ? authResponseTime + 1000 * session_expires_in : null;
    sessionStorage.removeItem("uu_app_oidc_auth_cb");
    let authenticationContext = sessionStorage.getItem("uu_app_oidc_auth_ctx");
    if (authenticationContext) {
      authenticationContext = JSON.parse(authenticationContext);
      sessionStorage.removeItem("uu_app_oidc_auth_ctx");
    }
    return {
      claims: claims,
      idToken: id_token,
      accessToken: access_token,
      authenticationContext: authenticationContext,
      globalSessionExpiresAt: globalSessionExpiresAt,
      globalSessionState: session_state,
      clientId: clientId,
      scope: scope,
      acrValues: acrValues,
      maxAge: maxAge
    };
  }

  // ======================== Private methods ================================

  async _validateAuthResponse(authResponse, state, nonce) {
    // ImplicitFlow response validation: http://openid.net/specs/openid-connect-core-1_0.html#ImplicitAuthResponseValidation
    // 1. process only recognized fields in response (id_token, expires_in, ...)
    // 2. validate implicit flow callback response ("state", expiration)
    // 3. validate id_token with nonce => http://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDTValidation
    //      i. validate as authorization code flow - http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation
    //     ii. validate signature
    //    iii. validate nonce
    // 4. validate access_token (if present)

    // 2.i. validate state
    if (state && authResponse.state !== state) {
      throw new AuthenticationError("Invalid 'state' in received authorization response. Expected " + state + " but got " + authResponse.state + ". Response: " + JSON.stringify(authResponse));
    }

    // 2.ii. validate expiration
    if (this._isAuthResponseExpired(authResponse)) {
      throw new AuthenticationError("Token expired " + JSON.stringify(authResponse));
    }

    // 3. validate id_token with nonce => http://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDTValidation
    //      i. validate as authorization code flow - http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation
    //         1. -Decrypt JWE - not supported.
    //         2. +REQUIRED validate 'iss'
    //         3. +REQUIRED validate 'aud'
    //         4. -SHOULD validate multiple 'aud' vs. 'azp'
    //         5. -SHOULD validate 'azp'
    //         6. -REQUIRED <applicable only for token_endpoint, not for implicit flow>
    //         7. -SHOULD validate 'alg' in header vs. 'alg' sent during client registration
    //         8. -REQUIRED <for MAC-based algos> - not supported (we use RSA)
    //         9. +REQUIRED current time < 'exp'
    //        10. +CAN check 'iat'
    //        11. +REQUIRED (for implicit flow) validate nonce
    //        12. -SHOULD check if 'acr' is appropriate
    //        13. -SHOULD check if 'auth_time' was requested.
    //     ii. validate signature
    //    iii. validate nonce

    // FIXME Verify audience 3.i.3.?
    // FIXME Validate iat claim 3.i.10. (send maxAge to Jwt.verify).
    // FIXME Turn on following 2 validations.
    // if (!jwtHeader.alg || !jwtHeader.alg.match(/^RS\d+$/)) throw new Error("Invalid token. Only RSA signature is supported, but token uses algorithm '" + jwtHeader.alg + "'. Token: " + token);
    // var keyType = "RSA";

    // // check algorithm in token (whether it's really supported by the server)
    // var supportedAlgs = metadata.id_token_signing_alg_values_supported || [];
    // if (supportedAlgs.indexOf(jwtHeader.alg) == -1) throw new Error("Invalid token. Token was signed using algorithm '" + jwtHeader.alg + "' but the OIDC server '" + serverUri + "' supports only " + JSON.stringify(supportedAlgs) + ". Token: " + token);

    let claims = await this._oauthClient.parseToken(authResponse.id_token, "idToken");

    // 3.i.11., 3.iii. validate nonce
    if (nonce && claims.nonce !== nonce) {
      throw new AuthenticationError("Invalid nonce in ID token claims. Expected " + nonce + " but got " + claims.nonce);
    }
    return claims;
  }
  _isAuthResponseExpired(authResponse) {
    var now = new Date().getTime() / 1000;
    var leeway = 60;
    var expired = false;
    if (!authResponse.issued_at) authResponse.issued_at = now;
    if (authResponse.expires_at) expired = expired || authResponse.expires_at < now - leeway;
    if (authResponse.expires_in && authResponse.issued_at) expired = expired || Number(authResponse.expires_in) + Number(authResponse.issued_at) < now - leeway;
    return expired;
  }
}
module.exports = ImplicitFlow;

/***/ }),

/***/ "./browser/internal/oidcg01-session-wrapper.js":
/***/ ((module) => {

// TODO Remove when compatibility with uu_oidcg01 is no longer needed.

class SessionWrapper {
  /**
   * Modifies Session class (API) to be compatible with uu_oidcg01's Session.
   * @param {*} session
   */
  static wrapClass(Session, AuthenticationService) {
    let oidcg01Session;
    Object.defineProperty(Session, "currentSession", {
      get() {
        if (!oidcg01Session) oidcg01Session = SessionWrapper.initG01Session(Session, AuthenticationService);
        return oidcg01Session;
      }
    });
    Object.defineProperty(Session, "initComplete", {
      get() {
        return AuthenticationService._onPageLoadFinished;
      }
    });
    Object.defineProperty(Session, "initPromise", {
      get() {
        return AuthenticationService._onPageLoad().then(session => {
          if (!oidcg01Session) oidcg01Session = SessionWrapper.initG01Session(Session, AuthenticationService);
          return oidcg01Session;
        });
      }
    });
    return Session;
  }
  static initG01Session(Session, AuthenticationService) {
    let session = Session._createEmptySession(); // in case user of legacy API uses "obj instanceof Session" expression

    Object.defineProperty(session, "initComplete", {
      get() {
        return AuthenticationService._onPageLoadFinished;
      }
    });
    Object.defineProperty(session, "initPromise", {
      get() {
        return AuthenticationService._onPageLoad().then(() => session);
      }
    });

    // NOTE In optimal case this wrapper would always use AuthenticationService.getCurrentSession().
    // However that's not possible if we're finishing session restore because the "sessionChanged" event
    // is triggerred sooner than AuthnService._primaryProvider gets updated. So if an app uses
    // e.g. getIdentity() inside of the sessionChanged event handler, we would forward it to AS.getCurrentSession()
    // which would return empty session / session from not-yet-updated _primaryProvider.
    // => during events use the g02 session instance which was sent to the event, otherwise use getCurrentSession()
    let runningG02Session = null;
    const getG02Session = () => runningG02Session || AuthenticationService.getCurrentSession();
    session.getIdentity = function () {
      let g02Session = getG02Session();
      let identity = g02Session.getIdentity();
      if (!identity) return identity;
      identity.id = g02Session.getAttribute("sub");
      identity.name = identity.getName();
      identity.email = g02Session.getAttribute("email");
      identity.uuIdentity = identity.getUuIdentity();
      identity.levelOfAssurance = identity.getLevelOfAssurance();
      identity.loginLevelOfAssurance = g02Session.getAuthenticationLevelOfAssurance();
      return identity;
    };
    session.getClaims = function () {
      return getG02Session()._attributes;
    };
    session.getCallToken = function (scope = null, opts = {}) {
      if (typeof scope === "string" || Array.isArray(scope)) {
        return getG02Session().getCallToken(scope, opts);
      } else {
        // If scope was not defined, return legacy value
        let session = getG02Session();
        return {
          token: session._idToken || session._accessToken,
          tokenType: session._idToken ? "Bearer" : null
        };
      }
    };
    session.getCallTokenScope = function (uri = null, opts = {}) {
      return getG02Session().getCallTokenScope(uri, opts);
    };
    session.isExpiring = function () {
      return AuthenticationService.isSessionExpiring();
    };
    session.isAuthenticated = function () {
      return getG02Session().isAuthenticated();
    };
    session.login = function (options) {
      let opts = {
        ...options
      };
      let authnSvcOpts = {};
      if (opts.access_token && opts.token_type_hint === "urn:ietf:params:oauth:token-type:jwt-uuos8") {
        authnSvcOpts = {
          os8Token: opts.access_token
        };
        delete opts.access_token;
        delete opts.token_type_hint;
      }
      Object.assign(authnSvcOpts, opts);
      return AuthenticationService.authenticate(authnSvcOpts).then(() => session);
    };
    session.logout = function () {
      return getG02Session().close();
    };
    let _legacyListeners = {};
    session.addListener = function (eventType, listenerFn) {
      if (eventType === "identityChange") eventType = "sessionChanged";
      let unregFn = AuthenticationService.addListener(eventType, ({
        type,
        data
      }) => {
        let origRunningG02Session = runningG02Session;
        if (data instanceof Session) runningG02Session = data;
        try {
          let g01Type = type;
          let g01Data = data instanceof Session ? session : data;
          if (type === "sessionChanged") {
            g01Type = "identityChange";
            g01Data = session.getIdentity();
          }
          let legacyEvent = {
            type: g01Type,
            data: g01Data
          };
          return listenerFn(legacyEvent);
        } finally {
          runningG02Session = origRunningG02Session;
        }
      });
      let map = _legacyListeners[eventType];
      if (!map) map = _legacyListeners[eventType] = new Map();
      map.set(listenerFn, unregFn);
      return unregFn;
    };
    session.removeListener = function (eventType, listenerFn) {
      if (eventType === "identityChange") eventType = "sessionChanged";
      let map = _legacyListeners[eventType];
      let unregFn = map ? map.get(listenerFn) : null;
      if (!unregFn) return false;
      map.delete(listenerFn);
      return unregFn();
    };
    let _legacyIdentityChangeListeners = new Map();
    session.addIdentityChangeListener = function (listenerFn) {
      let unregFn = session.addListener("identityChange", e => listenerFn(e.data));
      _legacyIdentityChangeListeners.set(listenerFn, unregFn);
      return unregFn;
    };
    session.removeIdentityChangeListener = function (listenerFn) {
      let unregFn = _legacyIdentityChangeListeners.get(listenerFn);
      if (!unregFn) return false;
      _legacyIdentityChangeListeners.delete(listenerFn);
      return unregFn();
    };
    session.getAuthenticationContext = function () {
      return getG02Session().getAuthenticationContext();
    };
    session._unwrap = function () {
      return getG02Session();
    };
    return session;
  }
}
module.exports = SessionWrapper;

/***/ }),

/***/ "./browser/internal/os8-flow.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  AuthenticationError
} = __webpack_require__("./browser/uu_appg01_core-authentication.js");
const ClientCredentialsProvider = __webpack_require__("./browser/internal/client-credentials-provider.js");
const ImplicitFlow = __webpack_require__("./browser/internal/implicit-flow.js");

/**
 * Requires os8Token when authenticating, the token is sent to special endpoint and otherwise it's
 * exactly the same as ImplicitFlow.
 */
class Os8Flow extends ImplicitFlow {
  constructor(oauthClient, serviceName, redirectUri) {
    super(oauthClient, serviceName, redirectUri, null);
  }
  async authenticate(options, scope = null) {
    let {
      os8Token
    } = options;
    if (!os8Token) throw new AuthenticationError("Authentication using Os8Flow requires option 'os8Token' passed to the authentication call.");
    let clientId = await ClientCredentialsProvider.getClientId(this._serviceName);
    let urlParams = {
      subject_token: os8Token,
      response_type: "id_token",
      client_id: clientId,
      redirect_uri: this._redirectUri
    };
    let urlParamsParts = Object.keys(urlParams).filter(k => urlParams[k] != null).map(k => encodeURIComponent(k) + "=" + encodeURIComponent(urlParams[k] + ""));
    let authUri = this._oauthClient.getServiceUri().replace(/\/*$/, "/") + "exchangeOs8Token" + "?" + urlParamsParts.join("&");
    let authResponse = await this.sendRequest(authUri);
    return await this._processAuthResponse(authResponse, null, null, scope, null, null, clientId);
  }
}
module.exports = Os8Flow;

/***/ }),

/***/ "./browser/internal/session-state-change-notifier.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  LoggerFactory
} = __webpack_require__("./browser/uu_appg01_core-logging.js");
class SessionStateChangeNotifier {
  constructor(authnFlow, sessionCheckInterval, clientId, getSessionStateFn) {
    this._authnFlow = authnFlow;
    this._enabled = true;
    this._sessionCheckInterval = sessionCheckInterval;
    this._clientId = clientId;
    this._getSessionStateFn = getSessionStateFn;
    this._listeners = [];
    this._unknownStateListeners = [];
    this._notifyUnknownState = true;
    this._logger = LoggerFactory.get("uuapp.oidc.internal.SessionStateChangeNotifier");
    // start checking
    this._stateCheckInterval = setInterval(this._checkState.bind(this), this._sessionCheckInterval * 1000);
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false;
  }
  onStateChange(listenerFn) {
    this._listeners.push(listenerFn);
    return () => {
      // return function for unregistering
      var idx = this._listeners.indexOf(listenerFn);
      if (idx != -1) this._listeners.splice(idx, 1);
      return idx != -1;
    };
  }
  onStateUnknown(listenerFn) {
    this._unknownStateListeners.push(listenerFn);
    return () => {
      // return function for unregistering
      var idx = this._unknownStateListeners.indexOf(listenerFn);
      if (idx != -1) this._unknownStateListeners.splice(idx, 1);
      return idx != -1;
    };
  }
  destroy() {
    if (this._destroyed) return;
    this._destroyed = true;
    if (this._stateCheckInterval) clearInterval(this._stateCheckInterval);
    delete this._stateCheckInterval;
    this._listeners = [];
    this._unknownStateListeners = [];
    this._notifyUnknownState = true;
  }
  async _checkState() {
    if (!this._enabled) {
      return;
    }
    let sessionState = this._getSessionStateFn();
    // skip if:
    // a) we have no session state (and we don't really need to get info that the user became logged in due to login in different tab)
    // b) unknown session state (e.g. current token was provided directly, instead of via login in browser tab)
    if (!sessionState) {
      return;
    }
    let query = this._clientId + " " + sessionState;
    this._logger.debug(`Checking session state.`);
    let sessionStateResult = await this._authnFlow.checkSession(query);
    if (sessionStateResult === "changed") {
      this._logger.debug(`Received session state change notification (message: '${sessionStateResult}').`);
      this._notifyUnknownState = true;
      this._listeners.forEach(fn => fn());
    } else if (sessionStateResult === "unknown") {
      this._logger.debug(`Received session state change notification (message: '${sessionStateResult}').`);
      if (this._notifyUnknownState) {
        this._logger.debug(`Propagating info about '${sessionStateResult}' session state.`);
        this._unknownStateListeners.forEach(fn => fn());
        this._notifyUnknownState = false;
      }
    } else {
      this._notifyUnknownState = true;
    }
  }
}
module.exports = SessionStateChangeNotifier;

/***/ }),

/***/ "./browser/ui/callback-handler.js":
/***/ ((module) => {

// login callback handling
var VC_CALLBACK_FN_NAME = "uuOidcCallbackFn"; // !!! Must be in sync with the one in callbacks/oidc-callback.html.

// make sure that callback works correctly even if multiple invocations using visual component below were
// done (e.g. user clicked 2 different buttons for command invocations which each opened a login popup
// and are now displayed both)
if (typeof window != "undefined" && !window[VC_CALLBACK_FN_NAME]) {
  window[VC_CALLBACK_FN_NAME] = function (aLoginResult, aSourceWindow, aAuthCtx) {
    var loginWindows = window[VC_CALLBACK_FN_NAME].loginWindows;
    // received callback from a popup => find out which component is using the source window and notify it
    for (var i = 0; i < loginWindows.length; ++i) {
      var p = loginWindows[i];
      if (p.state.loginWindow == aSourceWindow) {
        if (aAuthCtx) {
          sessionStorage.setItem("uu_app_oidc_auth_ctx", typeof aAuthCtx === "object" ? JSON.stringify(aAuthCtx) : aAuthCtx);
        }
        p.component.finalize(aLoginResult);
        return;
      }
    }
    console.warn("[" + new Date().toISOString() + "]  WARN uuapp.oidc.CallbackHandler: Received unexpected callback from window", aSourceWindow, "Passed result was:", aLoginResult, "Ignoring the callback.");
  };
  window[VC_CALLBACK_FN_NAME].loginWindows = [];
}
module.exports = {
  registerForCallback(component, state) {
    window[VC_CALLBACK_FN_NAME].loginWindows.push({
      component: component,
      state: state
    });
  },
  unregisterForCallback(component) {
    var loginWindows = window[VC_CALLBACK_FN_NAME].loginWindows;
    for (var i = 0; i < loginWindows.length; ++i) {
      // remove self from opened loginWindows
      if (loginWindows[i].component === component) {
        loginWindows.splice(i, 1);
        break;
      }
    }
  }
};

/***/ }),

/***/ "./browser/ui/dom.js":
/***/ ((module) => {

let isBrowser = new Function("try {return this===window;}catch(e){ return false;}")();
let domReadyPromise = isBrowser ? document.readyState === "interactive" || document.readyState === "complete" ? Promise.resolve() : new Promise(resolve => {
  document.addEventListener("DOMContentLoaded", resolve, false);
}) : Promise.resolve();
const WINDOW = location.href.startsWith("about:") && window.frameElement ? parent : window;
const BASE_ELEMENT = WINDOW.document.querySelector("base");
const APP_BASE_URI = WINDOW.location.protocol + "//" + WINDOW.location.host + (BASE_ELEMENT && BASE_ELEMENT.getAttribute("data-uu-app-base") || "" || "/");
const CANONICAL_APP_BASE_URI = (new RegExp("uu.app.cbu=([^;]+)").exec(WINDOW.document.cookie) || [])[1];
module.exports = {
  domReady: domReadyPromise,
  window: WINDOW,
  baseElement: BASE_ELEMENT,
  appBaseUri: APP_BASE_URI,
  canonicalAppBaseUri: CANONICAL_APP_BASE_URI,
  toFullAppUrl: function (path) {
    // relative & absolute paths are relative to app base
    let a = WINDOW.document.createElement("a");
    a.href = path && path.match(/^[a-z]+:/i) ? path : APP_BASE_URI + (path ? path.replace(/^\/+/, "") : "");
    return a.href.toString(); // browser-normalized URL (removed "../" sequences, ...)
  }
};

/***/ }),

/***/ "./browser/ui/iframe-component.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const CallbackHandler = __webpack_require__("./browser/ui/callback-handler.js");

/**
 * Visual component for attempting user login/logout on a background in an iframe. Usable only for prompt="none" cases.
 * After login/logout initAttrs.onResult(authResultUrl) is called as callback. In case of an error, an error instance
 * is passed to the callback.
 *
 * @param initAttrs.url The URL to be called on OpenID Connect Server for user authentication.
 * @param initAttrs.onResult The callback to call after login/logout finishes.
 * @param initAttrs.timeout Seconds to wait after which consider the attempt unsuccessful, resulting in an error result.
 */
var IframeComponent = function (initAttrs) {
  var attrs = Object.assign({}, initAttrs);
  var state = {
    iframe: null
  };
  Object.defineProperty(state, "loginWindow", {
    get: function () {
      try {
        // needs try-catch depending on which phase we're being asked (might be during redirect, ..., which can be cross-domain)
        return state.iframe != null ? state.iframe.contentWindow : null;
      } catch (e) {
        // ignore
      }
      return null;
    }
  });

  // add self to the list of openend loginWindows
  CallbackHandler.registerForCallback(this, state);

  // finalization callback (for this component instance) called after login from redirect_uri page
  this.finalize = function (aLoginResult) {
    // cleanup & do the callback
    this.finalize = function () {};
    this.destroy();
    if (attrs.onResult) attrs.onResult(aLoginResult);
  }.bind(this);
  this.render = function () {
    if (!state.iframe) {
      let callbackError = new Error("Server did not provide expected callback HTML page. Check if requested URL " + attrs.url + " contains proper redirect parameter. If so, look also into network console for possible callback response error.");
      state.iframe = document.createElement("iframe");
      state.iframe.style.cssText = "position: absolute;top: -300px; left: -300px; width: 200px; height: 200px; opacity: 0;";
      state.iframe.src = attrs.url;
      state.iframe.onload = () => this.finalize(callbackError); // proper callback page will perform callback prior to onload event
      state.iframe.onerror = () => this.finalize(callbackError);
      document.body.appendChild(state.iframe);
      if (attrs.timeout) this._timeout = setTimeout(() => {
        this.finalize(new Error("OIDC iframe didn't receive callback within " + attrs.timeout + "s."));
      }, attrs.timeout * 1000);
    }
  };
  this.destroy = function () {
    if (state.iframe && state.iframe.parentNode) state.iframe.parentNode.removeChild(state.iframe);
    this.destroy = function () {};
    if (this._timeout) clearTimeout(this._timeout);
    CallbackHandler.unregisterForCallback(this);
  };
};
module.exports = IframeComponent;

/***/ }),

/***/ "./browser/ui/main-window-component.js":
/***/ ((module) => {

/**
 * Visual component for presenting login/logout prompt to the user in main application window.
 *
 * @param initAttrs.url The URL to be called on OpenID Connect Server for user authentication.
 * @param initAttrs.onResult The callback to call in case login attempt was aborted.
 */
var MainWindowComponent = function (initAttrs) {
  var attrs = Object.assign({}, initAttrs);
  this.render = function () {
    location.href = attrs.url;
    setTimeout(() => {
      attrs.onResult(new Error("Login aborted"));
    }, 10000);
  };
};
module.exports = MainWindowComponent;

/***/ }),

/***/ "./browser/ui/popup-component.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const CallbackHandler = __webpack_require__("./browser/ui/callback-handler.js");
const DEFAULT_POPUP_WIDTH = 599;
const DEFAULT_POPUP_HEIGHT = 600;

/**
 * Default visual component for presenting login/logout prompt to the user. It displays the
 * URL in a popup window and waits until the user logs in / closes the window. After that
 * initAttrs.onResult(authResultUrl) is called as callback.
 *
 * @param initAttrs.url The URL to be called on OpenID Connect Server for user authentication.
 * @param initAttrs.onResult The callback to call after login finishes. If the login finished
 *   by user closing the window (e.g. via close button), the passed value is <code>false</code>.
 *   Otherwise it's the URL that was deemed as final response from OpenID Connect server (which
 *   contains the authentication response in fragment).
 */
const PopupComponent = function (initAttrs) {
  var attrs = Object.assign({}, initAttrs);
  var state = {
    loginWindow: null,
    closeCheckInterval: null
  };

  // add self to the list of opened loginWindows
  CallbackHandler.registerForCallback(this, state);
  this.finalize = function (result) {
    // cleanup & do the callback
    this.finalize = function () {};
    this.destroy();
    if (attrs.onResult) attrs.onResult(result);
  }.bind(this);
  var closeCheck = function () {
    if (!state.loginWindow || !state.loginWindow.closed) return;
    this.finalize(false); // closed without calling callback (i.e. refused to login or some other reason) => notify with special value "false"
  }.bind(this);
  this.render = function () {
    // open popup window centered on screen and wait until global callback is called (or window is closed in other way)
    if (!state.loginWindow) {
      var rect = {
        width: attrs.width || DEFAULT_POPUP_WIDTH,
        height: attrs.height || DEFAULT_POPUP_HEIGHT
      };
      rect.left = (screen.availWidth - rect.width) / 2 + (screen.availLeft || 0);
      rect.top = (screen.availHeight - rect.height) / 2 + (screen.availTop || 0);
      state.loginWindow = window.open(attrs.url, "_blank", `toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=yes,resizable=yes,copyhistory=no,width=${rect.width},height=${rect.height},top=${rect.top},left=${rect.left}`);
      if (!state.loginWindow) {
        // popup blocked or not yet allowed (which means we won't be able to detect window closing) => handle as if user refused to log in
        Promise.resolve().then(() => this.finalize(PopupComponent.ERROR_POPUP_BLOCKED)); // finalize in async way
      } else {
        state.closeCheckInterval = setInterval(closeCheck.bind(this), 200);
      }
    }
  };
  this.focus = function () {
    if (state.loginWindow) state.loginWindow.focus();
  };
  this.destroy = function () {
    if (state.loginWindow && !state.loginWindow.closed) state.loginWindow.close();
    if (state.closeCheckInterval) clearInterval(state.closeCheckInterval);
    this.destroy = function () {};
    CallbackHandler.unregisterForCallback(this);
  };
};
PopupComponent.ERROR_POPUP_BLOCKED = "POPUP_BLOCKED";
module.exports = PopupComponent;

/***/ }),

/***/ "./browser/uu_appg01_core-appclient.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__("uu_appg01_core").AppClient;

/***/ }),

/***/ "./browser/uu_appg01_core-authentication.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__("uu_appg01_core").Authentication;

/***/ }),

/***/ "./browser/uu_appg01_core-logging.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__("uu_appg01_core").Logging;

/***/ }),

/***/ "./browser/uu_appg01_core-uri.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__("uu_appg01_core").Uri;

/***/ }),

/***/ "./browser/uu_appg01_core-utils.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__("uu_appg01_core").Util;

/***/ }),

/***/ "./internal/default-service-loader.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  Config,
  BaseError
} = __webpack_require__("./browser/uu_appg01_core-utils.js");
const {
  AuthenticationService
} = __webpack_require__("./browser/uu_appg01_core-authentication.js");
const BASE_CONFIG_PREFIX = "uu_app_oidc_providers_";
const PRIMARY_PROVIDER_CFG = "uu_app_oidc_primary_provider";
const ALLOW_AUDIENCE_ALIAS_CFG = "uu_app_oidc_allow_audience_alias";
const DISABLE_WEBCRYPTO_API = "uu_app_oidc_disable_webcrypto_api";
const OIDCG01_SERVICE_NAME = "oidcg01";
const OIDCG01_SERVICE_ENABLED = false;
const OIDCG01_SERVICE_URI = "https://oidc.plus4u.net/uu-oidcg01-main/99923616732452117-4f06dafc03cb4c7f8c155aa53f0e86be";
const OIDCG01_VERIFY_AUDIENCE = false;
const OIDCG01_ACCESS_TOKEN_PATTERN = "^UUOIDCAT-.*";
const OIDCG01_REFRESH_TOKEN_PATTERN = "^UUOIDCRT-.*";
const OIDCG02_SERVICE_NAME = "oidcg02";
const OIDCG02_SERVICE_ENABLED = true;
const OIDCG02_SERVICE_URI = "https://uuidentity.plus4u.net/uu-oidc-maing02/bb977a99f4cc4c37a2afce3fd599d0a7/oidc";
const OIDCG02_VERIFY_AUDIENCE = true;
const OIDCG02_ACCESS_TOKEN_PATTERN = "^at.*";
const OIDCG02_REFRESH_TOKEN_PATTERN = "^rt.*";
class DefaultServiceLoader {
  static load(serviceClass, reconfigure = true) {
    if (reconfigure) {
      Object.keys(serviceClass._providers).forEach(name => {
        delete AuthenticationService._realizations[name];
      });
      serviceClass._providers = {};
      serviceClass._primaryProvider = null;
    }
    // Declare default services (which will be also first to try)
    // Defaults to implicit configuration of uuOidcg02 and uuOidcg01
    this.loadOidcg02(serviceClass, reconfigure);
    this.loadOidcg01(serviceClass, reconfigure);
    // Register additional services based on configuration
    let configObject = null;
    if (typeof window == "undefined") {
      configObject = Config.toJSON();
    } else {
      // Workaround for IE where it is not possible to serialize UU5.Environment
      // into JSON (which is internally used for deep copy of configuration)
      // due to incompatible types (like regular expression) in configuration.
      // Since on browser the only configuration source is UUE.Environment
      // we can directly use its config source.
      let uu5EnvSource = Config.chain._sources[0];
      configObject = Object.assign(uu5EnvSource ? uu5EnvSource._data : {}, Config.chain._custom);
    }
    let keys = Object.keys(configObject);
    for (let i = 0; i < keys.length; i += 1) {
      let key = keys[i];
      let value = configObject[key];
      let matchResult = new RegExp(`^${BASE_CONFIG_PREFIX}(.*)_uri$`).exec(key);
      if (!matchResult) {
        continue;
      }
      let serviceName = matchResult[1];
      let configPrefix = `${BASE_CONFIG_PREFIX}${serviceName}`;
      if (serviceName === OIDCG01_SERVICE_NAME || serviceName === OIDCG02_SERVICE_NAME) {
        continue;
      }
      let enabled = Config.getBoolean(`${configPrefix}_enabled`, false);
      if (typeof enabled === "boolean" && !enabled) {
        continue;
      }
      serviceName = Config.getString(`${configPrefix}_name`, false) || serviceName;
      let opts = {
        serviceUri: value,
        verifySsl: Config.getBoolean(`${configPrefix}_verify_ssl`, false),
        accessTokenPattern: Config.getString(`${configPrefix}_access_token_pattern`, false),
        refreshTokenPattern: Config.getString(`${configPrefix}_refresh_token_pattern`, false),
        verifyAudience: Config.getBoolean(`${configPrefix}_verify_audience`, false),
        allowAudienceAlias: Config.getBoolean(ALLOW_AUDIENCE_ALIAS_CFG, false),
        tokenCacheSize: Config.getNumber(`${configPrefix}_token_cache_size`, false),
        tokenTimeLeeway: Config.getNumber(`${configPrefix}_token_time_leeway`, false),
        discoveryPath: Config.getNumber(`${configPrefix}_discovery_path`, false),
        discoveryCacheTtl: Config.getNumber(`${configPrefix}_discovery_cache_ttl`, false),
        jwksCacheTtl: Config.getNumber(`${configPrefix}_jwks_cache_ttl`, false),
        defaultScope: Config.getString(`${configPrefix}_default_scope`, false),
        perflogEnabled: Config.getBoolean(`${configPrefix}_perflog_enabled`, false),
        callTokenType: Config.getString(`${configPrefix}_call_token_type`),
        callTokenIntrospectAge: Config.getNumber(`${configPrefix}_call_token_introspect_age`),
        issuer: Config.getString(`${configPrefix}_issuer`),
        oauthRealization: Config.getString(`${configPrefix}_oauth_realization`),
        disableWebcryptoApi: Config.getBoolean(DISABLE_WEBCRYPTO_API, false),
        force: reconfigure
      };
      serviceClass.create(serviceName, opts);
    }
    let primaryProvider = Config.getString(PRIMARY_PROVIDER_CFG, false);
    if (primaryProvider) {
      if (!serviceClass._providers[primaryProvider]) {
        throw new BaseError(`Cannot set primary provider to ${primaryProvider}. Service does not exits or is not enabled.`);
      }
      serviceClass._primaryProvider = primaryProvider;
    }
  }

  /**
   * Loads uuOIDCg02
   */
  static loadOidcg02(serviceClass, force = false) {
    let configPrefix = `${BASE_CONFIG_PREFIX}${OIDCG02_SERVICE_NAME}`;
    let enabled = Config.getBoolean(`${configPrefix}_enabled`, false);
    if (typeof enabled !== "boolean") {
      enabled = OIDCG02_SERVICE_ENABLED;
    }
    if (!enabled) {
      return;
    }
    let serviceUri = Config.getString(`${configPrefix}_uri`, false);
    let verifyAudience = Config.getBoolean(`${configPrefix}_verify_audience`, false);
    if (verifyAudience === null || verifyAudience === undefined) {
      verifyAudience = OIDCG02_VERIFY_AUDIENCE;
    }
    let opts = {
      force,
      serviceUri: serviceUri || OIDCG02_SERVICE_URI,
      verifySsl: Config.getBoolean(`${configPrefix}_verify_ssl`, false),
      accessTokenPattern: Config.getString(`${configPrefix}_access_token_pattern`, false) || OIDCG02_ACCESS_TOKEN_PATTERN,
      refreshTokenPattern: Config.getString(`${configPrefix}_refresh_token_pattern`, false) || OIDCG02_REFRESH_TOKEN_PATTERN,
      verifyAudience: verifyAudience,
      allowAudienceAlias: Config.getBoolean(ALLOW_AUDIENCE_ALIAS_CFG, false),
      tokenCacheSize: Config.getNumber(`${configPrefix}_token_cache_size`, false),
      tokenTimeLeeway: Config.getNumber(`${configPrefix}_token_time_leeway`, false),
      discoveryCacheTtl: Config.getNumber(`${configPrefix}_discovery_cache_ttl`, false),
      jwksCacheTtl: Config.getNumber(`${configPrefix}_jwks_cache_ttl`, false),
      defaultScope: Config.getString(`${configPrefix}_default_scope`, false),
      perflogEnabled: Config.getBoolean(`${configPrefix}_perflog_enabled`, false),
      callTokenType: Config.getString(`${configPrefix}_call_token_type`),
      callTokenIntrospectAge: Config.getNumber(`${configPrefix}_call_token_introspect_age`),
      issuer: Config.getString(`${configPrefix}_issuer`),
      oauthRealization: Config.getString(`${configPrefix}_oauth_realization`),
      disableWebcryptoApi: Config.getBoolean(DISABLE_WEBCRYPTO_API, false)
    };
    serviceClass.create(OIDCG02_SERVICE_NAME, opts);
  }

  /**
   * Loads uuOIDCg01
   */
  static loadOidcg01(serviceClass, force = false) {
    let configPrefix = `${BASE_CONFIG_PREFIX}${OIDCG01_SERVICE_NAME}`;
    let enabled = Config.getBoolean(`${configPrefix}_enabled`, false);
    if (typeof enabled !== "boolean") {
      enabled = OIDCG01_SERVICE_ENABLED;
    }
    if (!enabled) {
      return;
    }
    let serviceUri = Config.getString(`${configPrefix}_uri`, false);
    let verifyAudience = Config.getBoolean(`${configPrefix}_verify_audience`, false);
    if (verifyAudience === null || verifyAudience === undefined) {
      verifyAudience = OIDCG01_VERIFY_AUDIENCE;
    }
    let opts = {
      force,
      serviceUri: serviceUri || OIDCG01_SERVICE_URI,
      verifySsl: Config.getBoolean(`${configPrefix}_verify_ssl`, false),
      accessTokenPattern: Config.getString(`${configPrefix}_access_token_pattern`, false) || OIDCG01_ACCESS_TOKEN_PATTERN,
      refreshTokenPattern: Config.getString(`${configPrefix}_refresh_token_pattern`, false) || OIDCG01_REFRESH_TOKEN_PATTERN,
      verifyAudience: verifyAudience,
      allowAudienceAlias: Config.getBoolean(ALLOW_AUDIENCE_ALIAS_CFG, false),
      tokenCacheSize: Config.getNumber(`${configPrefix}_token_cache_size`, false),
      tokenTimeLeeway: Config.getNumber(`${configPrefix}_token_time_leeway`, false),
      discoveryCacheTtl: Config.getNumber(`${configPrefix}_discovery_cache_ttl`, false),
      jwksCacheTtl: Config.getNumber(`${configPrefix}_jwks_cache_ttl`, false),
      defaultScope: Config.getString(`${configPrefix}_default_scope`, false),
      perflogEnabled: Config.getBoolean(`${configPrefix}_perflog_enabled`, false),
      callTokenType: Config.getString(`${configPrefix}_call_token_type`),
      callTokenIntrospectAge: Config.getNumber(`${configPrefix}_call_token_introspect_age`),
      issuer: Config.getString(`${configPrefix}_issuer`),
      oauthRealization: Config.getString(`${configPrefix}_oauth_realization`),
      disableWebcryptoApi: Config.getBoolean(DISABLE_WEBCRYPTO_API, false)
    };
    serviceClass.create(OIDCG01_SERVICE_NAME, opts);
  }
}
module.exports = DefaultServiceLoader;

/***/ }),

/***/ "./internal/discovery.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  AppClient
} = __webpack_require__("./browser/uu_appg01_core-appclient.js");
const {
  BaseError,
  LruCache
} = __webpack_require__("./browser/uu_appg01_core-utils.js");
const {
  PerflogHandler,
  RemoteErrorHandler,
  RetryHandler,
  TransformParametersHandler
} = __webpack_require__("./browser/uu_appg01_core-appclient.js");
const APP_CLIENT_INTERCEPTORS = [PerflogHandler, RemoteErrorHandler, RetryHandler, TransformParametersHandler];
const APP_CLIENT_INTERCEPTORS_NO_PERFLOG = [RemoteErrorHandler, RetryHandler, TransformParametersHandler];
const APP_CLIENT_RETRY_POLICY = {
  maxAttempts: 3,
  maxTimeInterval: 30000,
  baseTimeInterval: 100,
  retryCondition: {
    httpMethods: ["GET", "POST"],
    httpStatusCodes: ["5xx"]
  }
};
const OIDC_WELL_KNOWN_DISCOVERY_PATH = ".well-known/openid-configuration";
const DISCOVERY_CACHE_SIZE = 16;
const DEFAULT_DISCOVERY_CACHE_TTL = 60 * 60;
const DISCOVERY_CACHE_STORAGE_KEY = "uu_app_oidc_cache_discovery";
const DISCOVERY_CACHE = new LruCache({
  maxSize: DISCOVERY_CACHE_SIZE,
  localStorageKey: DISCOVERY_CACHE_STORAGE_KEY
});
class Discovery {
  constructor(serviceUri, opts = {}) {
    if (!serviceUri) {
      throw new BaseError("Service URI must be defined");
    }
    let discoveryPath = opts.discoveryPath || OIDC_WELL_KNOWN_DISCOVERY_PATH;
    this._discoveryUri = `${serviceUri}/${discoveryPath.replace(/^\//, "")}`;
    this._discoveryCacheTtl = (opts.discoveryCacheTtl ? Number(opts.discoveryCacheTtl) : DEFAULT_DISCOVERY_CACHE_TTL) * 1000;
    let perflogEnabled = typeof opts.perflogEnabled === "boolean" ? opts.perflogEnabled : true;
    let interceptors = perflogEnabled ? APP_CLIENT_INTERCEPTORS : APP_CLIENT_INTERCEPTORS_NO_PERFLOG;
    this._client = new AppClient(Object.assign(opts, {
      interceptors,
      retryPolicy: APP_CLIENT_RETRY_POLICY
    }));
  }
  async getMetadata(refresh = false) {
    let metadata = DISCOVERY_CACHE.get(this._discoveryUri);
    if (!metadata || refresh) {
      let result = await this._client.get(this._discoveryUri);
      metadata = result.data;
      DISCOVERY_CACHE.set(this._discoveryUri, metadata, this._discoveryCacheTtl);
    }
    return metadata;
  }
}
module.exports = Discovery;

/***/ }),

/***/ "./internal/empty-session.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const CoreSession = (__webpack_require__("./browser/uu_appg01_core-authentication.js").Session);
const Identity = (__webpack_require__("./browser/uu_appg01_core-authentication.js").Identity);
const ClientIdentity = (__webpack_require__("./browser/uu_appg01_core-authentication.js").ClientIdentity);
const ApplicationIdentity = (__webpack_require__("./browser/uu_appg01_core-authentication.js").ApplicationIdentity);
class EmptySession extends CoreSession {
  constructor() {
    super({
      authenticationTime: new Date(Date.now()),
      authenticationLevelOfAssurance: 0,
      identity: new Identity(null),
      clientIdentity: new ClientIdentity(null),
      applicationIdentity: new ApplicationIdentity(null),
      attributes: {}
    });
  }
  getServiceName() {
    return null;
  }
  async getServiceUri() {
    return null;
  }
  getProviderUri() {
    return null;
  }
  async getCallToken(scope, opts = {}) {
    return null;
  }
}
module.exports = EmptySession;

/***/ }),

/***/ "./internal/jwks.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  BaseError,
  LruCache
} = __webpack_require__("./browser/uu_appg01_core-utils.js");
const {
  AppClient
} = __webpack_require__("./browser/uu_appg01_core-appclient.js");
const {
  InvalidCredentials
} = __webpack_require__("./browser/uu_appg01_core-authentication.js");
const {
  PerflogHandler,
  RemoteErrorHandler,
  RetryHandler,
  TransformParametersHandler
} = __webpack_require__("./browser/uu_appg01_core-appclient.js");
const APP_CLIENT_INTERCEPTORS = [PerflogHandler, RemoteErrorHandler, RetryHandler, TransformParametersHandler];
const APP_CLIENT_INTERCEPTORS_NO_PERFLOG = [RemoteErrorHandler, RetryHandler, TransformParametersHandler];
const APP_CLIENT_RETRY_POLICY = {
  maxAttempts: 3,
  maxTimeInterval: 30000,
  baseTimeInterval: 100,
  retryCondition: {
    httpMethods: ["GET", "POST"],
    httpStatusCodes: ["5xx"]
  }
};
const JWKS_CACHE_SIZE = 16;
const DEFAULT_JWKS_CACHE_TTL = 60 * 60;
const JWKS_CACHE_STORAGE_KEY = "uu_app_oidc_cache_jwks";
const JWKS_CACHE = new LruCache({
  maxSize: JWKS_CACHE_SIZE,
  localStorageKey: JWKS_CACHE_STORAGE_KEY
});
class Jwks {
  constructor(discovery, opts = {}) {
    if (!discovery) {
      throw new BaseError("Instance of discovery must be provided");
    }
    this._discovery = discovery;
    this._jwksCacheTtl = (opts.jwksCacheTtl ? Number(opts.jwksCacheTtl) : DEFAULT_JWKS_CACHE_TTL) * 1000;
    let perflogEnabled = typeof opts.perflogEnabled === "boolean" ? opts.perflogEnabled : true;
    let interceptors = perflogEnabled ? APP_CLIENT_INTERCEPTORS : APP_CLIENT_INTERCEPTORS_NO_PERFLOG;
    this._client = new AppClient(Object.assign(opts, {
      interceptors,
      retryPolicy: APP_CLIENT_RETRY_POLICY
    }));
  }
  async getPublicKeyData(kid) {
    let jwks = await this.getPublicKeySet();
    let publicKeyData = jwks && jwks.keys.find(pk => pk.kid === kid);
    if (!publicKeyData) {
      jwks = await this.getPublicKeySet(true);
      publicKeyData = jwks && jwks.keys.find(pk => pk.kid === kid);
      if (!publicKeyData) {
        let issuer = (await this._discovery.getMetadata()).issuer;
        throw new InvalidCredentials(`Unable to obtain public JWK key with jwk_id=${kid} from ${issuer}.`);
      }
    }
    return publicKeyData;
  }
  async getPublicKeySet(refresh = false) {
    let metadata = await this._discovery.getMetadata();
    let issuerUri = metadata.issuer;
    let jwks = JWKS_CACHE.get(issuerUri);
    if (!jwks || refresh) {
      jwks = (await this._client.get(metadata.jwks_uri)).data;
      JWKS_CACHE.set(issuerUri, jwks, this._jwksCacheTtl);
    }
    return jwks;
  }
}
module.exports = Jwks;

/***/ }),

/***/ "./internal/jwt.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Crypto = typeof window === "undefined" ? __webpack_require__("?ec77") : window.crypto;
// With Node.js 15-18 webcrypto is experimental and available via different module than on 19+
const SubtleCrypto = Crypto && Crypto.subtle || Crypto && Crypto.webcrypto && Crypto.webcrypto.subtle;
const {
  InvalidCredentials
} = __webpack_require__("./browser/uu_appg01_core-authentication.js");
const {
  Base64,
  Json
} = __webpack_require__("./browser/uu_appg01_core-utils.js");
const Jwks = __webpack_require__("./internal/jwks.js");
const JWT_TOKEN_REGEX = /^[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+$/;
const DEFAULT_TOKEN_TIME_LEEWAY = 5 * 60;
const DEFAULT_TOKEN_TYPE = "JWT";
const DEFAULT_TOKEN_SIGN_ALG = "RS256";
const DEFAULT_PUBLIC_KEY_FORMAT = "jwk";
const DEFAULT_PRIVATE_KEY_FORMAT = "pkcs8";
const DEFAULT_KEY_ALGORITHM = "RSASSA-PKCS1-v1_5";
const DEFAULT_KEY_DIGEST = "SHA-256";
const DEFAULT_KEY_PARAMS = {
  name: DEFAULT_KEY_ALGORITHM,
  hash: {
    name: DEFAULT_KEY_DIGEST
  }
};
class Jwt {
  constructor(discovery, opts = {}) {
    if (!discovery) {
      throw new BaseError("Instance of discovery must be provided");
    }
    this._discovery = discovery;
    this._jwks = new Jwks(this._discovery, opts);
    this._customIssuer = opts.issuer;
    this._tokenTimeLeeway = opts.tokenTimeLeeway ? Number(opts.tokenTimeLeeway) : DEFAULT_TOKEN_TIME_LEEWAY;
    this._disableWebcryptoApi = typeof opts.disableWebcryptoApi === "boolean" ? opts.disableWebcryptoApi : false;
    this._textEncoder = new TextEncoder();
  }
  async parseToken(token, verify = true, verifyOpts = {}) {
    if (!token || !token.match(JWT_TOKEN_REGEX)) {
      throw new InvalidCredentials("Unsupported token format.");
    }
    let tokenParts = token.split(".");
    let headers, claims;
    try {
      headers = Json.parse(Base64.urlSafeDecode(tokenParts[0]));
      claims = Json.parse(Base64.urlSafeDecode(tokenParts[1]));
    } catch (e) {
      throw new InvalidCredentials("Parsing of token failed.", e);
    }
    if (verify) {
      await this._verifyToken(headers, claims, tokenParts, verifyOpts);
    }
    return claims;
  }
  async createToken(claims, privateKey) {
    let headers = {
      alg: DEFAULT_TOKEN_SIGN_ALG,
      typ: DEFAULT_TOKEN_TYPE
    };
    let signedData = Base64.urlSafeEncode(Json.stringify(headers)) + "." + Base64.urlSafeEncode(Json.stringify(claims));
    let signature;
    if (SubtleCrypto && !this._disableWebcryptoApi) {
      if (privateKey.includes("RSA PRIVATE KEY")) {
        // This is for backward compatibility with applications which were initialized
        // using "node-rsa" library generating private key in PKCS#1 format, as native
        // SubtleCrypto API supports only PKCS#8 format.
        privateKey = Crypto.createPrivateKey(privateKey);
        privateKey = privateKey.export({
          format: "pem",
          type: "pkcs8"
        });
      }
      privateKey = Base64.decode(privateKey.split("\n").slice(1, -1).join(), "binary");
      let cryptoKey = await SubtleCrypto.importKey(DEFAULT_PRIVATE_KEY_FORMAT, privateKey, DEFAULT_KEY_PARAMS, true, ["sign"]);
      signature = await SubtleCrypto.sign(DEFAULT_KEY_PARAMS, cryptoKey, this._textEncoder.encode(signedData));
    } else {
      // Fallback for environments where SubtleCrypto is not available
      // (older brosers, browsers without SSL context, and older versions of Node.js)
      let JSRSASIGN;
      if (typeof window === "undefined") {
        // TODO Workaround mainly for jest which cannot handle import.
        // Require must be done via variable, else webpack will bundle
        // jsrasing into library instead of using external chunk.
        let requireName = "jsrsasign";
        JSRSASIGN = __webpack_require__("./internal sync recursive")(requireName);
      } else {
        JSRSASIGN = await __webpack_require__.e(/* import() */ "node_modules_jsrsasign_lib_jsrsasign_js").then(__webpack_require__.t.bind(__webpack_require__, "../../node_modules/jsrsasign/lib/jsrsasign.js", 19));
      }
      let sig = new JSRSASIGN.KJUR.crypto.Signature({
        alg: "SHA256withRSA"
      });
      sig.init(privateKey);
      sig.updateString(signedData);
      signature = Uint8Array.from(sig.sign().match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
    }
    return signedData + "." + Base64.urlSafeEncode(signature);
  }
  isExpired(claims, leeway = null) {
    leeway = leeway != null ? leeway : this._tokenTimeLeeway;
    return claims.exp && claims.exp < Date.now() / 1000 - leeway;
  }
  verifyExpiration(claims, leeway = null) {
    if (this.isExpired(claims, leeway)) {
      throw new InvalidCredentials("Token is expired.");
    }
  }
  async _verifyToken(headers, claims, tokenParts, verifyOpts = {}) {
    this.verifyExpiration(claims, verifyOpts && verifyOpts.leeway);
    let expectedIssuer = verifyOpts && verifyOpts.issuer;
    if (!expectedIssuer) {
      let metadata = await this._discovery.getMetadata();
      expectedIssuer = [metadata.issuer];
      if (metadata.access_token_issuer) {
        expectedIssuer.push[metadata.access_token_issuer];
      }
      if (this._customIssuer) {
        expectedIssuer.push[this._customIssuer];
      }
    } else if (!Array.isArray(expectedIssuer)) {
      expectedIssuer = [expectedIssuer];
    }
    if (!expectedIssuer.includes(claims.iss)) {
      throw new InvalidCredentials("Unsupported issuer.");
    }
    let publicKey = verifyOpts && verifyOpts.publicKey;
    if (!publicKey) {
      publicKey = await this._jwks.getPublicKeyData(headers.kid);
    }
    let expectedAlgorithm = publicKey.alg;
    if (!expectedAlgorithm) {
      let metadata = await this._discovery.getMetadata();
      expectedAlgorithm = (metadata.id_token_signing_alg_values_supported || [])[0];
      if (!expectedAlgorithm) {
        expectedAlgorithm = DEFAULT_TOKEN_SIGN_ALG;
      }
    }
    if (headers.alg != DEFAULT_TOKEN_SIGN_ALG) {
      throw new InvalidCredentials("Unexpected signature algorithm.");
    }
    let signedData = tokenParts[0] + "." + tokenParts[1];
    let signature = Base64.decode(tokenParts[2], "binary");
    let isValid;
    if (SubtleCrypto && !this._disableWebcryptoApi) {
      try {
        let cryptoKey = await SubtleCrypto.importKey(DEFAULT_PUBLIC_KEY_FORMAT, publicKey, DEFAULT_KEY_PARAMS, false, ['verify']);
        signedData = this._textEncoder.encode(signedData);
        isValid = await SubtleCrypto.verify(DEFAULT_KEY_PARAMS, cryptoKey, signature, signedData);
      } catch (e) {
        throw new InvalidCredentials("Unable to verify signature.", e);
      }
    } else {
      // Fallback for environments where SubtleCrypto is not available
      // (older brosers, browsers without SSL context, and older versions of Node.js)
      let JSRSASIGN;
      if (typeof window === "undefined") {
        // TODO Workaround mainly for jest which cannot handle import.
        // Require must be done via variable, else webpack will bundle
        // jsrasing into library instead of using external chunk.
        let requireName = "jsrsasign";
        JSRSASIGN = __webpack_require__("./internal sync recursive")(requireName);
      } else {
        JSRSASIGN = await __webpack_require__.e(/* import() */ "node_modules_jsrsasign_lib_jsrsasign_js").then(__webpack_require__.t.bind(__webpack_require__, "../../node_modules/jsrsasign/lib/jsrsasign.js", 19));
      }
      try {
        signature = signature.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');
        publicKey = JSRSASIGN.KEYUTIL.getKey(publicKey);
        let sig = new JSRSASIGN.KJUR.crypto.Signature({
          alg: "SHA256withRSA"
        });
        sig.init(publicKey);
        sig.updateString(signedData);
        isValid = sig.verify(signature);
      } catch (e) {
        throw new InvalidCredentials("Unable to verify signature.", e);
      }
    }
    if (!isValid) {
      throw new InvalidCredentials("Invalid token signature.");
    }
  }
}
module.exports = Jwt;

/***/ }),

/***/ "./internal/local-domain-scope-handler.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  Config
} = __webpack_require__("./browser/uu_appg01_core-utils.js");
const LOCAL_DOMAIN_SCOPE_REPLACE_ENABLED = "uu_app_oidc_local_domain_scope_replace_enabled";
const LOCAL_DOMAIN_LIST = "uu_app_oidc_local_domain_list";
const DEFAULT_LOCAL_DOMAIN_LIST = "localhost,127.0.0.1";
const LOCAL_DOMAIN_SCOPE = "uu_app_oidc_local_domain_call_token_scope";
const DEFAULT_LOCAL_DOMAIN_SCOPE = "https:// http://";
const CALL_SCOPE = new RegExp("^https?://.*");

/**
 * Component for transforming scope so that localhost URIs are replaced
 * by broad scope allowing applications to do any token exchange without
 * requiring registered oidc client.
 */
class LocalDomainScopeHandler {
  constructor() {
    this._localDomainReplaceEnabled = Config.getBoolean(LOCAL_DOMAIN_SCOPE_REPLACE_ENABLED);
    if (this._localDomainReplaceEnabled == null) {
      this._localDomainReplaceEnabled = Config.isProfileActive("development", "test");
    }
    if (this._localDomainReplaceEnabled) {
      this._localDomainList = (Config.getString(LOCAL_DOMAIN_LIST) || DEFAULT_LOCAL_DOMAIN_LIST).split(",").map(domain => new RegExp(`^https?://${domain.trim()}(:\\d{1,5})?($|/)`));
      this._localDomainScope = Config.getString(LOCAL_DOMAIN_SCOPE) || DEFAULT_LOCAL_DOMAIN_SCOPE;
    }
  }
  transformScope(scope) {
    if (!this._localDomainReplaceEnabled) {
      return scope;
    }
    let specialScopes = [];
    let externalCallScopes = [];
    let scopeParts = scope.split(" ");
    for (let scopePart of scopeParts) {
      if (scopePart.match(CALL_SCOPE)) {
        if (!this._localDomainList.find(domain => scopePart.match(domain))) {
          externalCallScopes.push(scopePart);
        }
      } else {
        specialScopes.push(scopePart);
      }
    }
    if (externalCallScopes.length > 0) {
      // In case there is any external scope, we cannot use generic scope
      return scope;
    } else {
      // Provide scope with all localhost scopes replaced by generic scope
      return `${specialScopes.join(" ")} ${this._localDomainScope}`;
    }
  }
}
module.exports = new LocalDomainScopeHandler();

/***/ }),

/***/ "./internal/oauth-client.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  BaseError,
  LruCache,
  Base64
} = __webpack_require__("./browser/uu_appg01_core-utils.js");
const {
  AppClient,
  ApplicationError
} = __webpack_require__("./browser/uu_appg01_core-appclient.js");
const {
  InvalidCredentials,
  AuthenticationError
} = __webpack_require__("./browser/uu_appg01_core-authentication.js");
const {
  PerflogHandler,
  RemoteErrorHandler,
  RetryHandler,
  TransformParametersHandler
} = __webpack_require__("./browser/uu_appg01_core-appclient.js");
const {
  UriBuilder
} = __webpack_require__("./browser/uu_appg01_core-uri.js");
const SyncCallNotPossible = __webpack_require__("./internal/sync-call-not-possible.js");
const Discovery = __webpack_require__("./internal/discovery.js");
const Jwt = __webpack_require__("./internal/jwt.js");
const LocalDomainScopeHandler = __webpack_require__("./internal/local-domain-scope-handler.js");
const APP_CLIENT_INTERCEPTORS = [PerflogHandler, RemoteErrorHandler, RetryHandler, TransformParametersHandler];
const APP_CLIENT_INTERCEPTORS_NO_PERFLOG = [RemoteErrorHandler, RetryHandler, TransformParametersHandler];
const APP_CLIENT_RETRY_POLICY = {
  maxAttempts: 3,
  maxTimeInterval: 30000,
  baseTimeInterval: 100,
  retryCondition: {
    httpMethods: ["GET", "POST"],
    httpStatusCodes: ["5xx"]
  }
};
const OAUTH_CLIENT_ID = "client_id";
const OAUTH_CLIENT_SECRET = "client_secret";
const MEDIA_FORM_ENCODED = "application/x-www-form-urlencoded";
const MEDIA_JSON = "application/json";
const OAUTH_CODE = "code";
const OAUTH_SCOPE = "scope";
const OAUTH_SCOPE_OPENID = "openid";
const OAUTH_GRANT_TYPE = "grant_type";
const OAUTH_GRANT_TYPE_CODE = "authorization_code";
const OAUTH_PARAM_TOKEN = "token";
const OAUTH_PARAM_TOKEN_TYPE_HINT = "token_type_hint";
const OAUTH_PARAM_REDIRECT_URI = "redirect_uri";
const OAUTH_GRANT_TYPE_RESOURCE_OWNER_PASSWORD = "password";
const OAUTH_USERNAME = "username";
const OAUTH_PASSWORD = "password";
const OAUTH_GRANT_TYPE_CLIENT_CREDENTIALS = "client_credentials";
const OAUTH_GRANT_TYPE_REFRESH_TOKEN = "refresh_token";
const OAUTH_REFRESH_TOKEN = "refresh_token";
const OAUTH_SUBJECT_TOKEN = "subject_token";
const OAUTH_SUBJECT_TOKEN_TYPE = "subject_token_type";
const OAUTH_ACTOR_TOKEN = "actor_token";
const OAUTH_ACTOR_TOKEN_TYPE = "actor_token_type";
const OAUTH_TOKEN_TYPE_ID_TOKEN = "id_token";
const OAUTH_TOKEN_TYPE_ACCESS_TOKEN = "access_token";
const OAUTH_TOKEN_TYPE_REFRESH_TOKEN = "refresh_token";
const OAUTH_TOKEN_TYPE_QUALIFIED_ID_TOKEN = `urn:ietf:params:oauth:token-type:${OAUTH_TOKEN_TYPE_ID_TOKEN}`;
const OAUTH_TOKEN_TYPE_QUALIFIED_ACCESS_TOKEN = `urn:ietf:params:oauth:token-type:${OAUTH_TOKEN_TYPE_ACCESS_TOKEN}`;
const OAUTH_TOKEN_TYPE_QUALIFIED_REFRESH_TOKEN = `urn:ietf:params:oauth:token-type:${OAUTH_TOKEN_TYPE_REFRESH_TOKEN}`;
const OAUTH_GRANT_TYPE_QUALIFIED_EXCHANGE = "urn:ietf:params:oauth:grant-type:token-exchange";
const CLIENT_PRIVATE_KEY = "client_private_key";
const CLIENT_TOKEN_TTL = 10 * 60;
const OAUTH_CLIENT_ASSERTION = "client_assertion";
const OAUTH_CLIENT_ASSERTION_TYPE = "client_assertion_type";
const OAUTH_CLIENT_ASSERTION_BEARER = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer";
const DEFAULT_TOKEN_CACHE_SIZE = 2048;
const DEFAULT_TOKEN_TIME_LEEWAY = 5 * 60;
const JWT_TOKEN_REGEX = /^[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+$/;
const DEFAULT_ACCESS_TOKEN_PATTERN = ".^";
const DEFAULT_REFRESH_TOKEN_PATTERN = ".^";

// TODO Constant for workaround to allow sending of word values to G01
const G02_ACR_VALUES_OLD = ["none", "low", "medium", "high", "veryHigh"];
const G02_ACR_VALUES = ["none", "low", "standard", "high", "veryHigh"];
class OAuthClient {
  constructor(serviceUri, opts = {}) {
    if (!serviceUri) {
      throw new BaseError("Service URI must be defined");
    }
    let tokenCacheSize = opts.tokenCacheSize ? Number(opts.tokenCacheSize) : DEFAULT_TOKEN_CACHE_SIZE;
    this._tokenCache = new LruCache({
      maxSize: tokenCacheSize
    });
    this._tokenTimeLeeway = opts.tokenTimeLeeway ? Number(opts.tokenTimeLeeway) : DEFAULT_TOKEN_TIME_LEEWAY;
    this._discovery = new Discovery(serviceUri, opts);
    this._jwt = new Jwt(this._discovery, opts);
    let perflogEnabled = typeof opts.perflogEnabled === "boolean" ? opts.perflogEnabled : true;
    let interceptors = perflogEnabled ? APP_CLIENT_INTERCEPTORS : APP_CLIENT_INTERCEPTORS_NO_PERFLOG;
    this._client = new AppClient(Object.assign(opts, {
      interceptors,
      retryPolicy: APP_CLIENT_RETRY_POLICY
    }));
    this._metadata = null;
    this._serviceUri = serviceUri;
    this._customIssuer = opts.issuer;
    this._defaultScope = opts.defaultScope != null ? opts.defaultScope : OAUTH_SCOPE_OPENID;
    this._accessTokenPattern = new RegExp(opts.accessTokenPattern || DEFAULT_ACCESS_TOKEN_PATTERN);
    this._refreshTokenPattern = new RegExp(opts.refreshTokenPattern || DEFAULT_REFRESH_TOKEN_PATTERN);
    this._mtlsGateway = opts.mtlsGateway;
  }
  getServiceUri() {
    return this._serviceUri;
  }
  async getMetadata() {
    this._metadata = await this._discovery.getMetadata();
    return this._metadata;
  }
  getMetadataSync() {
    if (!this._metadata) {
      throw new SyncCallNotPossible("Asynchronous method getMetadata must be invoked prior to synchronous invocation");
    }
    return this._metadata;
  }
  async getIssuerList() {
    let metadata = await this.getMetadata();
    let issuerList = [metadata.issuer];
    if (metadata.access_token_issuer) {
      issuerList.push(metadata.access_token_issuer);
    }
    if (this._customIssuer) {
      issuerList.push(this._customIssuer);
    }
    return issuerList;
  }
  async getSupportedAcrValues() {
    return (await this.getMetadata()).acr_values_supported || [];
  }
  getSupportedAcrValuesSync() {
    return this.getMetadataSync().acr_values_supported || [];
  }
  async getUserInfoUri() {
    return (await this.getMetadata()).userinfo_endpoint;
  }
  async getEndSessionUri() {
    return (await this.getMetadata()).end_session_endpoint;
  }
  getEndSessionUriSync() {
    return this.getMetadataSync().end_session_endpoint;
  }
  async getCheckSessionIframeUri() {
    let uri = (await this.getMetadata()).check_session_iframe;
    return this._replaceMtlsGatewayIfNeeded(uri);
  }
  async getAuthorizationUri(reponseType, redirectUri, clientId, acrValues, scope = null) {
    // Initialize metadata
    await this.getMetadata();
    // And delegate to synchronous function (which now has access to freshly loaded metadata)
    return this.getAuthorizationUriSync(reponseType, redirectUri, clientId, acrValues, scope);
  }
  getAuthorizationUriSync(reponseType, redirectUri, clientId, acrValues, scope = null) {
    if (clientId && clientId.client_id) {
      // TODO Workaround for backward compatibility where clientCredentials object was passed instead of plain clientId
      clientId = clientId.client_id;
    }
    let endpoint = this._replaceMtlsGatewayIfNeeded(this.getMetadataSync().authorization_endpoint);
    let authzUri = `${endpoint}?`;
    authzUri += `response_type=${encodeURIComponent(reponseType)}&`;
    authzUri += `redirect_uri=${encodeURIComponent(redirectUri)}&`;
    authzUri += `client_id=${encodeURIComponent(clientId)}&`;
    authzUri += `scope=${encodeURIComponent(this._getOidcScope(scope))}`;
    if (acrValues) {
      let supportedAcrValues = this.getSupportedAcrValuesSync();
      if (supportedAcrValues && supportedAcrValues.length > 0) {
        // TODO Workaround for renaming of "medium" acrValue on G02 server
        let requestedValuesStr = acrValues.toString();
        if (supportedAcrValues.includes("medium")) {
          requestedValuesStr = requestedValuesStr.replace("standard", "medium");
        } else if (supportedAcrValues.includes("standard")) {
          requestedValuesStr = requestedValuesStr.replace("medium", "standard");
        }
        // ...end of workaround
        let requestedValues = requestedValuesStr.split(" ");
        let transformedValues = [];
        requestedValues.forEach(requestedValue => {
          if (supportedAcrValues.includes(requestedValue)) {
            transformedValues.push(requestedValue);
          } else {
            let requestedValueOrd = Number(requestedValue);
            if (supportedAcrValues.includes(requestedValueOrd)) {
              transformedValues.push(requestedValueOrd);
            } else if (supportedAcrValues[requestedValueOrd]) {
              transformedValues.push(supportedAcrValues[requestedValueOrd]);
              // TODO Workaround to allow sending of word values to G01
            } else if ((requestedValueOrd = G02_ACR_VALUES_OLD.indexOf(requestedValue)) > -1 || (requestedValueOrd = G02_ACR_VALUES.indexOf(requestedValue)) > -1) {
              transformedValues.push(requestedValueOrd);
            }
            // ...end of workaround
          }
        });

        transformedValues = transformedValues.filter(p => p == null ? false : true);
        // TODO Workaround for G01 which accepts only single acr value
        // and uses acr value ordering (thus lowest number is selected)
        if (transformedValues.length > 1 && !isNaN(transformedValues[0])) {
          transformedValues = [Math.min(...transformedValues)];
        }
        // ...end of workaround
        if (transformedValues.length > 0) {
          authzUri += `&acr_values=${encodeURIComponent(transformedValues.join(" "))}`;
        }
      }
    }
    return authzUri;
  }
  async grantAuthorizationCodeToken(authorizationCode, clientCredentials, redirectUri, scope = null) {
    let params = {};
    params[OAUTH_GRANT_TYPE] = OAUTH_GRANT_TYPE_CODE;
    params[OAUTH_CODE] = authorizationCode;
    params[OAUTH_CLIENT_ID] = clientCredentials[OAUTH_CLIENT_ID];
    params[OAUTH_SCOPE] = this._getOidcScope(scope);
    if (redirectUri) {
      params[OAUTH_PARAM_REDIRECT_URI] = redirectUri;
    }
    return await this._grantToken(params, clientCredentials);
  }
  async grantResourceOwnerPasswordCredentialsToken(username, password, clientCredentials, scope = null) {
    let params = {};
    params[OAUTH_GRANT_TYPE] = OAUTH_GRANT_TYPE_RESOURCE_OWNER_PASSWORD;
    params[OAUTH_USERNAME] = username;
    params[OAUTH_PASSWORD] = password;
    params[OAUTH_SCOPE] = this._getOidcScope(scope);
    return await this._grantToken(params, clientCredentials);
  }
  async grantImplicitFlowToken() {
    throw new BaseError("Method not implemented.");
  }
  async grantHybridFlowToken() {
    throw new BaseError("Method not implemented.");
  }
  async grantClientCredentialsToken(clientCredentials, scope = null) {
    let params = {};
    params[OAUTH_GRANT_TYPE] = OAUTH_GRANT_TYPE_CLIENT_CREDENTIALS;
    params[OAUTH_SCOPE] = this._getOidcScope(scope);
    return await this._grantToken(params, clientCredentials);
  }
  async refreshToken(refreshToken, clientCredentials, scope = null) {
    let params = {};
    params[OAUTH_GRANT_TYPE] = OAUTH_GRANT_TYPE_REFRESH_TOKEN;
    params[OAUTH_REFRESH_TOKEN] = refreshToken;
    params[OAUTH_SCOPE] = this._getOidcScope(scope);
    return await this._grantToken(params, clientCredentials);
  }
  async exchangeToken(token, tokenType = null, clientCredentials, scope = null) {
    if (tokenType != null && typeof tokenType === "object") {
      scope = clientCredentials;
      clientCredentials = tokenType;
      tokenType = null;
    }
    let params = {};
    params[OAUTH_GRANT_TYPE] = OAUTH_GRANT_TYPE_QUALIFIED_EXCHANGE;
    params[OAUTH_SUBJECT_TOKEN] = token;
    if (tokenType === "idToken") {
      params[OAUTH_SUBJECT_TOKEN_TYPE] = OAUTH_TOKEN_TYPE_QUALIFIED_ID_TOKEN;
    } else if (tokenType === "accessToken") {
      params[OAUTH_SUBJECT_TOKEN_TYPE] = OAUTH_TOKEN_TYPE_QUALIFIED_ACCESS_TOKEN;
    } else if (token.match(JWT_TOKEN_REGEX)) {
      // uuOidc by default uses JWT format only for idToken
      params[OAUTH_SUBJECT_TOKEN_TYPE] = OAUTH_TOKEN_TYPE_QUALIFIED_ID_TOKEN;
    } else {
      params[OAUTH_SUBJECT_TOKEN_TYPE] = OAUTH_TOKEN_TYPE_QUALIFIED_ACCESS_TOKEN;
    }
    params[OAUTH_SCOPE] = this._getOidcScope(scope);
    return await this._grantToken(params, clientCredentials);
  }
  async delegateToken(actorToken, actorTokenType = null, subjectToken, subjectTokenType = null, clientCredentials, scope = null) {
    if (actorTokenType != null && actorTokenType !== "idToken" && actorTokenType !== "accessToken") {
      scope = clientCredentials;
      clientCredentials = subjectTokenType;
      subjectToken = actorTokenType;
      actorTokenType = null;
    }
    if (subjectTokenType != null && typeof subjectTokenType === "object") {
      scope = clientCredentials;
      clientCredentials = subjectTokenType;
      subjectTokenType = null;
    }
    let params = {};
    params[OAUTH_GRANT_TYPE] = OAUTH_GRANT_TYPE_QUALIFIED_EXCHANGE;
    params[OAUTH_ACTOR_TOKEN] = actorToken;
    params[OAUTH_SUBJECT_TOKEN] = subjectToken;
    if (actorTokenType === "idToken") {
      params[OAUTH_ACTOR_TOKEN_TYPE] = OAUTH_TOKEN_TYPE_QUALIFIED_ID_TOKEN;
    } else if (actorTokenType === "accessToken") {
      params[OAUTH_ACTOR_TOKEN_TYPE] = OAUTH_TOKEN_TYPE_QUALIFIED_ACCESS_TOKEN;
    } else if (actorToken.match(JWT_TOKEN_REGEX)) {
      // uuOidc by default uses JWT format only for idToken
      params[OAUTH_ACTOR_TOKEN_TYPE] = OAUTH_TOKEN_TYPE_QUALIFIED_ID_TOKEN;
    }
    if (subjectTokenType === "idToken") {
      params[OAUTH_SUBJECT_TOKEN_TYPE] = OAUTH_TOKEN_TYPE_QUALIFIED_ID_TOKEN;
    } else if (subjectTokenType === "accessToken") {
      params[OAUTH_SUBJECT_TOKEN_TYPE] = OAUTH_TOKEN_TYPE_QUALIFIED_ACCESS_TOKEN;
    } else if (subjectToken.match(JWT_TOKEN_REGEX)) {
      // uuOidc by default uses JWT format only for idToken
      params[OAUTH_SUBJECT_TOKEN_TYPE] = OAUTH_TOKEN_TYPE_QUALIFIED_ID_TOKEN;
    }
    params[OAUTH_SCOPE] = this._getOidcScope(scope);
    return await this._grantToken(params, clientCredentials);
  }
  async introspectToken(token, tokenType = null, clientCredentials = null) {
    if (tokenType != null && typeof tokenType === "object") {
      clientCredentials = tokenType;
      tokenType = null;
    }
    let metadata = await this.getMetadata();
    let introspectTokenUri = metadata.token_introspection_endpoint || metadata.introspection_endpoint;
    let params = {};
    params[OAUTH_PARAM_TOKEN] = token;
    let tokenTypeHint = this._getTokenTypeHint(token, tokenType);
    if (tokenTypeHint) {
      params[OAUTH_PARAM_TOKEN_TYPE_HINT] = tokenTypeHint;
    }
    let headers = {};
    headers["Content-Type"] = MEDIA_FORM_ENCODED;
    headers["Accept"] = MEDIA_JSON;
    if (clientCredentials) {
      let authnHeader = await this._createClientAuthnHeader(clientCredentials);
      let tokenMatch;
      // TODO Temporary workaround until server accepts client token in header
      if (tokenMatch = authnHeader.match(/^Bearer (.*)/)) {
        params[OAUTH_CLIENT_ID] = clientCredentials[OAUTH_CLIENT_ID];
        params[OAUTH_CLIENT_ASSERTION] = tokenMatch[1];
        params[OAUTH_CLIENT_ASSERTION_TYPE] = OAUTH_CLIENT_ASSERTION_BEARER;
      } else {
        headers["Authorization"] = authnHeader;
      }
    }
    let result = null;
    try {
      result = await this._client.post(introspectTokenUri, params, {
        headers
      });
    } catch (e) {
      if (e instanceof ApplicationError) {
        throw new InvalidCredentials("Invalid credentials.", e);
      } else {
        throw new AuthenticationError("Authentication failed.", e);
      }
    }
    if (!result.active) {
      throw new InvalidCredentials("Invalid credentials.");
    }
    return result.data;
  }
  async revokeToken(token, clientCredentials = null) {
    let metadata = await this.getMetadata();
    let revokeTokenUri = metadata.token_revocation_endpoint || metadata.revocation_endpoint;
    let params = {};
    params[OAUTH_PARAM_TOKEN] = token;
    let tokenTypeHint = this._getTokenTypeHint(token);
    if (tokenTypeHint) {
      params[OAUTH_PARAM_TOKEN_TYPE_HINT] = tokenTypeHint;
    }
    let headers = {};
    headers["Content-Type"] = MEDIA_FORM_ENCODED;
    headers["Accept"] = MEDIA_JSON;
    if (clientCredentials) {
      let authnHeader = await this._createClientAuthnHeader(clientCredentials);
      let tokenMatch;
      // TODO Temporary workaround until server accepts client token in header
      if (tokenMatch = authnHeader.match(/^Bearer (.*)/)) {
        params[OAUTH_CLIENT_ID] = clientCredentials[OAUTH_CLIENT_ID];
        params[OAUTH_CLIENT_ASSERTION] = tokenMatch[1];
        params[OAUTH_CLIENT_ASSERTION_TYPE] = OAUTH_CLIENT_ASSERTION_BEARER;
      } else {
        headers["Authorization"] = authnHeader;
      }
    }
    let result = null;
    try {
      result = await this._client.post(revokeTokenUri, params, {
        headers
      });
    } catch (e) {
      if (e instanceof ApplicationError) {
        throw new InvalidCredentials("Invalid credentials.", e);
      } else {
        throw new AuthenticationError("Authentication failed.", e);
      }
    }
    return result.data;
  }
  async parseToken(token, tokenType = null, verify = true, clientCredentials = null) {
    if (tokenType != null && typeof tokenType === "object") {
      clientCredentials = tokenType;
      verify = true;
      tokenType = null;
    } else if (typeof tokenType === "boolean") {
      clientCredentials = typeof verify === "object" ? verify : null;
      verify = tokenType;
      tokenType = null;
    } else if (typeof verify === "object") {
      clientCredentials = verify;
      verify = true;
    }
    let claims;
    if (token.match(JWT_TOKEN_REGEX)) {
      claims = await this._jwt.parseToken(token, verify);
    } else {
      claims = await this.introspectToken(token, tokenType, clientCredentials);
      if (verify) {
        this._jwt.verifyExpiration(claims);
      }
    }
    return claims;
  }
  cacheToken(tokenKey, expireAt, token) {
    expireAt = expireAt - this._tokenTimeLeeway * 2;
    let ttl = expireAt * 1000 - Date.now();
    if (ttl > 0) {
      this._tokenCache.set(tokenKey, token, ttl);
    }
  }
  getToken(tokenKey) {
    return this._tokenCache.get(tokenKey);
  }
  deleteToken(tokenKey) {
    return this._tokenCache.delete(tokenKey);
  }
  listTokens(callback) {
    this._tokenCache.forEach(callback);
  }

  // ======================== Private methods ================================

  async _grantToken(params, credentials = null) {
    let metadata = await this.getMetadata();
    let grantTokenUri = metadata.token_endpoint;
    let headers = {};
    headers["Content-Type"] = MEDIA_FORM_ENCODED;
    headers["Accept"] = MEDIA_JSON;
    if (credentials) {
      let authnHeader = await this._createClientAuthnHeader(credentials);
      let tokenMatch;
      // TODO Temporary workaround until server accepts client token in header
      if (tokenMatch = authnHeader.match(/^Bearer (.*)/)) {
        params[OAUTH_CLIENT_ID] = credentials[OAUTH_CLIENT_ID];
        params[OAUTH_CLIENT_ASSERTION] = tokenMatch[1];
        params[OAUTH_CLIENT_ASSERTION_TYPE] = OAUTH_CLIENT_ASSERTION_BEARER;
      } else {
        headers["Authorization"] = authnHeader;
      }
    }
    let result = null;
    try {
      result = await this._client.post(grantTokenUri, params, {
        headers
      });
    } catch (e) {
      if (e instanceof ApplicationError) {
        throw new InvalidCredentials("Invalid credentials.", e);
      } else {
        throw new AuthenticationError("Authentication failed.", e);
      }
    }
    return result.data;
  }
  async _createClientAuthnHeader(credentials) {
    let authnHeader = null;
    if (credentials[CLIENT_PRIVATE_KEY]) {
      let metadata = await this.getMetadata();
      let issuedAt = Math.round(Date.now() / 1000);
      let claims = {
        jti: Math.random().toString(16).substring(2, 10),
        iat: issuedAt,
        exp: issuedAt + CLIENT_TOKEN_TTL,
        aud: metadata.token_endpoint,
        iss: credentials[OAUTH_CLIENT_ID],
        sub: credentials[OAUTH_CLIENT_ID]
      };
      let token = await this._jwt.createToken(claims, credentials[CLIENT_PRIVATE_KEY]);
      authnHeader = `Bearer ${token}`;
    } else {
      let username = credentials[OAUTH_CLIENT_ID];
      let password = credentials[OAUTH_CLIENT_SECRET];
      // avoid/encode ':' -  is reserved for basic authentication
      username = encodeURIComponent(username);
      authnHeader = `Basic ${Base64.encode(`${username}:${password}`)}`;
    }
    return authnHeader;
  }
  _getOidcScope(scope) {
    let oidcScope = null;
    if (Array.isArray(scope)) {
      oidcScope = `${this._defaultScope} ${scope.join(" ")}`.trim();
    } else if (scope) {
      oidcScope = `${this._defaultScope} ${scope}`;
    } else {
      oidcScope = this._defaultScope;
    }
    oidcScope = LocalDomainScopeHandler.transformScope(oidcScope);
    return oidcScope;
  }
  _getTokenTypeHint(token, tokenType = null) {
    if (tokenType) {
      if (tokenType === "idToken") {
        return OAUTH_TOKEN_TYPE_QUALIFIED_ID_TOKEN;
      } else if (tokenType === "accessToken") {
        return OAUTH_TOKEN_TYPE_QUALIFIED_ACCESS_TOKEN;
      } else if (tokenType === "refreshToken") {
        return OAUTH_TOKEN_TYPE_REFRESH_TOKEN;
      } else {
        return tokenType;
      }
    } else if (this._accessTokenPattern.test(token)) {
      return OAUTH_TOKEN_TYPE_QUALIFIED_ACCESS_TOKEN;
    } else if (this._refreshTokenPattern.test(token)) {
      return OAUTH_TOKEN_TYPE_QUALIFIED_REFRESH_TOKEN;
    } else if (JWT_TOKEN_REGEX.test(token)) {
      // uuOidc by default uses JWT format only for idToken
      return OAUTH_TOKEN_TYPE_QUALIFIED_ID_TOKEN;
    } else {
      return null;
    }
  }
  _replaceMtlsGatewayIfNeeded(uri) {
    if (this._mtlsGateway) {
      const uriBuilder = new UriBuilder().parse(uri);
      const newGateway = this._mtlsGateway;
      return uriBuilder.setGateway(newGateway).toString();
    }
    return uri;
  }
}
module.exports = OAuthClient;

/***/ }),

/***/ "./internal/sync-call-not-possible.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  BaseError
} = __webpack_require__("./browser/uu_appg01_core-utils.js");
class SyncCallNotPossible extends BaseError {
  constructor(message, cause = null) {
    super(message, cause);
  }
}
module.exports = SyncCallNotPossible;

/***/ }),

/***/ "./session.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  Config,
  Base64,
  BaseError,
  Digest,
  Json
} = __webpack_require__("./browser/uu_appg01_core-utils.js");
const {
  UriBuilder
} = __webpack_require__("./browser/uu_appg01_core-uri.js");
const {
  LoggerFactory
} = __webpack_require__("./browser/uu_appg01_core-logging.js");
const CoreAuthenticationService = (__webpack_require__("./browser/uu_appg01_core-authentication.js").AuthenticationService);
const CoreSession = (__webpack_require__("./browser/uu_appg01_core-authentication.js").Session);
const {
  Identity,
  ClientIdentity,
  ApplicationIdentity,
  UuAppKey
} = __webpack_require__("./browser/uu_appg01_core-authentication.js");
const EmptySession = __webpack_require__("./internal/empty-session.js");
const ClientCredentialsProvider = __webpack_require__("./browser/internal/client-credentials-provider.js");
const JWT_CLAIM_UU_IDENTITY = "uuidentity";
const JWT_CLAIM_UU_IDENTITY_G01 = "uu_identity";
const JWT_CLAIM_NAME = "name";
const JWT_CLAIM_TOKEN_ID = "jti";
const JWT_CLAIM_SESSION_ID = "auth_id";
const JWT_CLAIM_SESSION_ID_G01 = "sid";
const JWT_CLAIM_AUTH_TIME = "auth_time";
const JWT_CLAIM_ISSUED_AT = "iat";
const JWT_CLAIM_AUTH_LEVEL_OF_ASSURANCE = "acr";
const JWT_CLAIM_UU_APP_KEY = "uuappkey";
const JWT_CLAIM_UU_APP_KEY_OLD = "appkey";
const JWT_CLAIM_LEVEL_OF_ASSURANCE = "loa";
const JWT_CLAIM_CLIENT_APP_ID = "client_app_id";
const JWT_CLAIM_CLIENT_APP_CODE = "client_app_code";
const JWT_CLAIM_CLIENT_UU_IDENTITY = "client_uuidentity";
const JWT_CLAIM_CLIENT_APP_NAME = "client_app_name";
const JWT_CLAIM_CLIENT_UU_APP_KEY = "client_uuappkey";
const JWT_CLAIM_CLIENT_UU_APP_KEY_OLD = "client_appkey";
const JWT_CLAIM_CLIENT_AUTH_LEVEL_OF_ASSURANCE = "client_acr";
const JWT_CLAIM_CLIENT_type = "client_uuidentity_type";
const JWT_CLAIM_CLIENT_URI = "client_uri";
const JWT_CLAIM_IDENTITY_TYPE = "uuidentity_type";
const JWT_CLAIM_IDENTITY_TYPE_G01 = "identity_type";
const JWT_CLAIM_ACCOUNT_TYPE = "uuidentity_account_type";
const JWT_CLAIM_ACTOR_IDENTITY = "act";
const OAUTH_TOKEN_TYPE_ID_TOKEN = "id_token";
const CLIENT_URI_URN = "urn:uuoidcclient:";
const ANONYMOUS_UUIDENTITY = "0-0";
const CONFIG_PREFIX = "uu_app_oidc_providers_";
const DEFAULT_SCOPE_MODE = "baseUri";
const DEFAULT_USE_TOKEN_EXCHANGE = true;
const DEFAULT_AUTH_LEVEL_OF_ASSURANCE = 1;
const DEFAULT_ACCOUNT_TYPE = "standard";
class Session extends CoreSession {
  constructor(serviceName, oauthClient, supportedAcrValues, claims = null, idToken = null, accessToken = null) {
    let id = null;
    let authenticationId = null;
    let authenticationTime = null;
    let authenticationLevelOfAssurance = null;
    let identity = null;
    let actorIdentity = null;
    let clientIdentity = null;
    let applicationIdentity = null;
    let attributes = claims;
    let configPrefix = `${CONFIG_PREFIX}${serviceName}_`;
    if (attributes) {
      id = attributes[JWT_CLAIM_TOKEN_ID];
      authenticationId = attributes[JWT_CLAIM_SESSION_ID] || attributes[JWT_CLAIM_SESSION_ID_G01];
      let epochAuthTime = attributes[JWT_CLAIM_AUTH_TIME] || attributes[JWT_CLAIM_ISSUED_AT];
      if (epochAuthTime) {
        authenticationTime = new Date(epochAuthTime * 1000);
      }
      let loa = attributes[JWT_CLAIM_AUTH_LEVEL_OF_ASSURANCE];
      if (loa == null) {
        authenticationLevelOfAssurance = DEFAULT_AUTH_LEVEL_OF_ASSURANCE;
      } else {
        if (supportedAcrValues.indexOf(loa) > -1) {
          authenticationLevelOfAssurance = supportedAcrValues.indexOf(loa);
        } else if (supportedAcrValues.indexOf(loa.toString()) > -1) {
          authenticationLevelOfAssurance = supportedAcrValues.indexOf(loa.toString());
        } else if (supportedAcrValues.indexOf(Number(loa.toString())) > -1) {
          authenticationLevelOfAssurance = supportedAcrValues.indexOf(Number(loa.toString()));
        } else {
          // TODO Fallback because oidcg02 now returns supported values as word but acr_value as number
          authenticationLevelOfAssurance = Number(loa.toString());
        }
      }
      let uuIdentity;
      let uuIdentityClaim = Config.getString(`${configPrefix}uu_identity_claim`);
      if (uuIdentityClaim) {
        uuIdentity = attributes[uuIdentityClaim];
      } else {
        uuIdentity = attributes[JWT_CLAIM_UU_IDENTITY] || attributes[JWT_CLAIM_UU_IDENTITY_G01];
      }
      if (uuIdentity) {
        let levelOfAssurance = attributes[JWT_CLAIM_LEVEL_OF_ASSURANCE];
        let identityAcr = attributes[JWT_CLAIM_AUTH_LEVEL_OF_ASSURANCE];
        let uuAppKey = attributes[JWT_CLAIM_UU_APP_KEY] || attributes[JWT_CLAIM_UU_APP_KEY_OLD];
        if (uuAppKey) {
          uuAppKey = UuAppKey.parse(uuAppKey);
        }
        let name = attributes[JWT_CLAIM_NAME];
        if (uuIdentity === ANONYMOUS_UUIDENTITY) {
          authenticationLevelOfAssurance = 0;
        }
        let type = attributes[JWT_CLAIM_IDENTITY_TYPE] || attributes[JWT_CLAIM_IDENTITY_TYPE_G01];
        let accountType = attributes[JWT_CLAIM_ACCOUNT_TYPE] || DEFAULT_ACCOUNT_TYPE;
        let identityData = {
          name,
          levelOfAssurance,
          type,
          authenticationLevelOfAssurance: identityAcr,
          uuAppKey,
          accountType
        };
        identity = new Identity(uuIdentity, identityData);
        // TODO Remove after upgrade to uu_appg01_core-authentication 5.12
        identity.getAccountType = () => {
          return accountType;
        };
      }
      let appCode = attributes[JWT_CLAIM_CLIENT_APP_CODE];
      let appIdentity = attributes[JWT_CLAIM_CLIENT_UU_IDENTITY];
      if (appCode || appIdentity) {
        let appData = {};
        appData.id = attributes[JWT_CLAIM_CLIENT_APP_ID];
        appData.code = appCode;
        appData.name = attributes[JWT_CLAIM_CLIENT_APP_NAME];
        let uuAppKey = attributes[JWT_CLAIM_CLIENT_UU_APP_KEY] || attributes[JWT_CLAIM_CLIENT_UU_APP_KEY_OLD];
        if (uuAppKey) {
          appData.uuAppKey = UuAppKey.parse(uuAppKey);
        }
        appData.authenticationLevelOfAssurance = attributes[JWT_CLAIM_CLIENT_AUTH_LEVEL_OF_ASSURANCE];
        appData.type = attributes[JWT_CLAIM_CLIENT_type];
        let clientUri = attributes[JWT_CLAIM_CLIENT_URI];
        if (clientUri) {
          appData.uri = clientUri;
          if (appData.uri && appData.uri.startsWith(CLIENT_URI_URN)) {
            let [product, asidawid] = appData.uri.replace(CLIENT_URI_URN, "").split(/[:\/](.*)/);
            let [asid, awid] = asidawid.split(/[:\-]/);
            if (!appData.code) {
              appData.code = product.toUpperCase().replace(/-/g, ".");
            }
            if (!appData.name) {
              appData.name = product.replace(/(-\w)/g, function (match) {
                return match[1].toUpperCase();
              });
            }
            let [vendor, app, subApp] = product.split("-");
            appData.product = product;
            appData.vendor = vendor;
            appData.app = app;
            appData.subApp = subApp;
            appData.asid = asid;
            appData.awid = awid;
          }
        } else if (appData.code) {
          let [vendor, app, subApp] = appData.code.toLowerCase().split(/[\.\-_]/);
          let product = `${vendor}-${app}-${subApp}`;
          appData.vendor = vendor;
          appData.app = app;
          appData.subApp = subApp;
          appData.product = product;
          appData.uri = `${CLIENT_URI_URN}${product}`;
        }
        clientIdentity = new ClientIdentity(appIdentity, appData);
        applicationIdentity = new ApplicationIdentity(appIdentity, appData);
      }
      let actorIdentityClaim = attributes[JWT_CLAIM_ACTOR_IDENTITY];
      if (actorIdentityClaim) {
        let actorUuIdentity;
        let uuIdentityClaim = Config.getString(`${configPrefix}uu_identity_claim`);
        if (uuIdentityClaim) {
          actorUuIdentity = actorIdentityClaim[uuIdentityClaim];
        } else {
          actorUuIdentity = actorIdentityClaim[JWT_CLAIM_UU_IDENTITY] || attributes[JWT_CLAIM_UU_IDENTITY_G01];
        }
        let actorName = actorIdentityClaim[JWT_CLAIM_NAME];
        let actorType = actorIdentityClaim[JWT_CLAIM_IDENTITY_TYPE] || actorIdentityClaim[JWT_CLAIM_IDENTITY_TYPE_G01];
        let actorLoa = actorIdentityClaim[JWT_CLAIM_LEVEL_OF_ASSURANCE];
        let actorAcr = actorIdentityClaim[JWT_CLAIM_AUTH_LEVEL_OF_ASSURANCE];
        let actorUuAppKey = actorIdentityClaim[JWT_CLAIM_UU_APP_KEY] || actorIdentityClaim[JWT_CLAIM_UU_APP_KEY_OLD];
        if (actorUuAppKey) {
          actorUuAppKey = UuAppKey.parse(actorUuAppKey);
        }
        let actorAccountType = actorIdentityClaim[JWT_CLAIM_ACCOUNT_TYPE] || DEFAULT_ACCOUNT_TYPE;
        let actorIdentityData = {
          name: actorName,
          levelOfAssurance: actorLoa,
          type: actorType,
          authenticationLevelOfAssurance: actorAcr,
          uuAppKey: actorUuAppKey,
          accountType: actorAccountType
        };
        actorIdentity = new Identity(actorUuIdentity, actorIdentityData);
        // TODO Remove after upgrade to uu_appg01_core-authentication 5.12
        actorIdentity.getAccountType = () => {
          return actorAccountType;
        };
      }
    }
    super({
      id,
      authenticationId,
      authenticationTime,
      authenticationLevelOfAssurance,
      identity,
      actorIdentity,
      clientIdentity,
      applicationIdentity,
      attributes
    });
    this._configPrefix = configPrefix;
    this._serviceName = serviceName;
    this._oauthClient = oauthClient;
    this._supportedAcrValues = supportedAcrValues;
    this._idToken = idToken;
    this._accessToken = accessToken;
    this._logger = LoggerFactory.get("uuapp.oidc.Session");
    // TODO Workaround for providers not providing acr value (should be moved to core session)
    if (!this._authenticated && !this._authenticationLevelOfAssurance) {
      // Session should return isAuthenticated as true as long as there is some identity other than anonymous
      this._authenticated = this._identity && this._identity.getUuIdentity() && this._identity.getUuIdentity() !== ANONYMOUS_UUIDENTITY;
    }
    // TODO Remove after upgrade to uu_appg01_core-authentication 5.12
    this._actorIdentity = actorIdentity;
  }
  getServiceName() {
    return this._serviceName;
  }
  async getServiceUri() {
    let service = CoreAuthenticationService.get(this._serviceName);
    return typeof service.getServiceUri === "function" ? await service.getServiceUri() : null;
  }
  getProviderUri() {
    let service = CoreAuthenticationService.get(this._serviceName);
    return typeof service.getProviderUri === "function" ? service.getProviderUri() : null;
  }

  /**
   * Returns actor user identity.
   * @returns {Identity} Actor user identity
   */
  // TODO Remove after upgrade to uu_appg01_core-authentication 5.12
  getActorIdentity() {
    return this._actorIdentity;
  }
  async getCallTokenScope(uri, opts = {}) {
    let scopeMode = opts ? opts.scopeMode : null;
    if (scopeMode == null) {
      let cfgKey = `${this._configPrefix}default_call_token_scope_mode`;
      scopeMode = Config.getString(cfgKey) || DEFAULT_SCOPE_MODE;
    }
    if (scopeMode === "none") {
      return null;
    }
    let scope;
    if (scopeMode === "baseUri" && opts.baseUri) {
      scope = opts.baseUri.toString().replace(/^\/|\/$/g, "");
      if (!scope.match(/^https?:/i)) {
        let gateway = opts.gatewayUri || "https://uuapp.plus4u.net";
        scope = `${gateway.replace(/\/$/, "")}/${scope}`;
      }
    } else {
      try {
        let uriBuilder = UriBuilder.parse(uri);
        uriBuilder.clearParameters();
        if (scopeMode === "useCase") {
          scope = uriBuilder.toUri().toString();
        } else if (scopeMode === "allUseCases" || scopeMode === "baseUri") {
          uriBuilder.setUseCase(null);
          scope = uriBuilder.toUri().toString();
        } else {
          throw new BaseError(`Unsupported scope mode: ${scopeMode}`);
        }
      } catch (e) {
        scope = uri.toString().split("?")[0];
        scope = scope.replace(/\/$/, "");
      }
    }
    return scope;
  }
  async getCallToken(scope, opts = {}) {
    let useTokenExchange = opts ? opts.useTokenExchange : null;
    if (typeof useTokenExchange !== "boolean") {
      let cfgKey = `${this._configPrefix}use_token_exchange`;
      useTokenExchange = Config.hasKey(cfgKey) ? Config.getBoolean(cfgKey) : DEFAULT_USE_TOKEN_EXCHANGE;
    }
    let callTokenType = opts ? opts.callTokenType : null;
    if (!callTokenType) {
      let cfgKey = `${this._configPrefix}call_token_type`;
      callTokenType = Config.getString(cfgKey);
    }
    let excludeAuthType = opts ? opts.excludeAuthenticationType : false;
    let token = null;
    if (!useTokenExchange) {
      if (callTokenType === "idToken") {
        token = this._idToken;
      } else if (callTokenType === "accessToken") {
        token = this._accessToken;
      } else if (!callTokenType) {
        token = this._idToken || this._accessToken;
      }
    } else {
      let clientId = await ClientCredentialsProvider.getClientId(this._serviceName);
      let tokenKey;
      if (Array.isArray(scope)) {
        tokenKey = Digest.sha1(`${this.getIdentity().getUuIdentity()}:${this.getAuthenticationId()}:${clientId}:${scope.sort().join("|")}`);
      } else {
        tokenKey = Digest.sha1(`${this.getIdentity().getUuIdentity()}:${this.getAuthenticationId()}:${clientId}:${scope}`);
      }
      let grantedToken = await this._oauthClient.getToken(tokenKey);
      if (!grantedToken) {
        let tokenToExchange;
        let tokenType;
        // Try to exchange preferred token type
        if (callTokenType === "idToken") {
          tokenToExchange = this._idToken;
          tokenType = callTokenType;
        } else if (callTokenType === "accessToken") {
          tokenToExchange = this._accessToken;
          tokenType = callTokenType;
        }
        // If preferred token type is not available,
        // try to exchange what we have
        if (!tokenToExchange) {
          if (this._idToken) {
            tokenToExchange = this._idToken;
            tokenType = "idToken";
          } else if (this._accessToken) {
            tokenToExchange = this._accessToken;
            tokenType = "accessToken";
          }
        }
        let credentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName);
        grantedToken = await this._oauthClient.exchangeToken(tokenToExchange, tokenType, credentials, scope);
        let expiresAt = grantedToken.expires_at || Number(new Date() / 1000 + grantedToken.expires_in);
        this._oauthClient.cacheToken(tokenKey, expiresAt, grantedToken);
      }
      if (callTokenType === "idToken") {
        token = grantedToken.id_token;
      } else if (callTokenType === "accessToken") {
        token = grantedToken.access_token;
      } else if (!callTokenType) {
        token = grantedToken.id_token || grantedToken.access_token;
      }
    }
    if (!token) {
      throw new BaseError(`Call token of type "${callTokenType || "idToken"}" is not available.`);
    }
    if (excludeAuthType === true) {
      return token;
    } else {
      return `Bearer ${token}`;
    }
  }
  async actAs(uuIdentity, scope = null, opts = {}) {
    if (scope != null && typeof scope !== "string" && !Array.isArray(scope)) {
      opts = scope;
      scope = null;
    }
    let actorTokenType = opts ? opts.callTokenType : null;
    if (!actorTokenType) {
      let cfgKey = `${this._configPrefix}call_token_type`;
      actorTokenType = Config.getString(cfgKey);
    }
    let actorToken = null;
    if (actorTokenType === "idToken") {
      actorToken = this._idToken;
    } else if (actorTokenType === "accessToken") {
      actorToken = this._accessToken;
    } else if (!actorTokenType) {
      actorToken = this._idToken || this._accessToken;
    }
    let clientId = await ClientCredentialsProvider.getClientId(this._serviceName);
    let tokenKey;
    if (Array.isArray(scope)) {
      tokenKey = Digest.sha1(`${this.getIdentity().getUuIdentity()}:${this.getAuthenticationId()}:${uuIdentity}:${clientId}:${scope.sort().join("|")}`);
    } else {
      tokenKey = Digest.sha1(`${this.getIdentity().getUuIdentity()}:${this.getAuthenticationId()}:${uuIdentity}:${clientId}:${scope}`);
    }
    let grantedToken = await this._oauthClient.getToken(tokenKey);
    let credentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName);
    if (!grantedToken) {
      let subjectToken = Base64.urlSafeEncode(Json.stringify({
        uuidentity: uuIdentity
      }));
      grantedToken = await this._oauthClient.delegateToken(actorToken, actorTokenType, subjectToken, credentials, scope);
      let expiresAt = grantedToken.expires_at || Number(new Date() / 1000 + grantedToken.expires_in);
      this._oauthClient.cacheToken(tokenKey, expiresAt, grantedToken);
    }
    let claims = await this._oauthClient.parseToken(grantedToken.id_token, OAUTH_TOKEN_TYPE_ID_TOKEN, true, credentials);
    let supportedAcrValues = await this._oauthClient.getSupportedAcrValues();
    return new this.constructor(this._serviceName, this._oauthClient, supportedAcrValues, claims, grantedToken.id_token, grantedToken.access_token);
  }
  async close() {
    super.close();
    let credentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName);
    if (this._idToken || this._accessToken) {
      try {
        await this._oauthClient.revokeToken(this._idToken || this._accessToken, credentials);
      } catch (e) {
        this._logger.error("Token revocation failed.", e);
      }
    }
    this._oauthClient.listTokens((tokenKey, grantedToken) => {
      if (grantedToken.id_token == this._idToken || grantedToken.access_token == this._accessToken) {
        this._oauthClient.deleteToken(tokenKey);
        return false;
      }
    });
    this._idToken = null;
    this._accessToken = null;
  }
  static _createEmptySession() {
    return new EmptySession();
  }
}
module.exports = Session;

/***/ }),

/***/ "../target/webpack-tmp/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mod = __webpack_require__("module");
var isDoc = typeof document !== "undefined";
var uri = ((mod ? mod.uri : isDoc && (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName("script"), -1)[0] || {}).src) || "").toString();
uri = uri.split(/\//).slice(0, -1).join("/") + "/"; // runtime publicPath configuration required for proper linking of styles, background images, ...
var floatingVersion = "/3.0.0/";
if (uri.substr(-floatingVersion.length) === floatingVersion) uri = uri.substr(0, uri.length - floatingVersion.length) + "/3.9.0/";
__webpack_require__.p = (typeof process !== "undefined" && process.env && (process.env.NODE_ENV) || "development") === "test" && uri === "/" ? "file://" + eval("__filename").replace(/[^/\\]*$/, "") : uri;
module.exports = __webpack_require__("./browser/index.js");
var ex = module.exports;
if (ex && typeof ex === "object") {
  if (!("version" in ex)) Object.defineProperty(ex, "version", {
    configurable: true,
    value: "3.9.0"
  });
  if (!("name" in ex)) Object.defineProperty(ex, "name", {
    configurable: true,
    value: "uu_appg01_oidc".split(/[\/\\]/).pop()
  });
  if (!("namespace" in ex)) Object.defineProperty(ex, "namespace", {
    configurable: true,
    value: "UuApp.Oidc"
  });
}

/***/ }),

/***/ "./internal sync recursive":
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "./internal sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "module":
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_module__;

/***/ }),

/***/ "uu_appg01_core":
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_uu_appg01_core__;

/***/ }),

/***/ "?ec77":
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "chunks/uu_appg01_oidc/" + chunkId + "-" + "53b78c9faf80d984f305" + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "UuApp.Oidc:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 				script.src = url;
/******/ 				if (script.src.indexOf(window.location.origin + '/') !== 0) {
/******/ 					script.crossOrigin = "anonymous";
/******/ 				}
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"index": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						} else installedChunks[chunkId] = 0;
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = this["__webpack_jsonp_uu_appg01_oidc_3_9_0_uu_appg01_oidc"] = this["__webpack_jsonp_uu_appg01_oidc_3_9_0_uu_appg01_oidc"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("../target/webpack-tmp/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});