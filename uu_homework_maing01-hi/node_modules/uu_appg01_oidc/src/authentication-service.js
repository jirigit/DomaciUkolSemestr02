"use strict";

const Os = require("os");
const Fs = require("fs");
const Util = require("util");
const fsReadFile = Util.promisify(Fs.readFile);
const fsExists = Util.promisify(Fs.exists);
const Path = require("path");
const Process = require("process");
const { CacheManager } = require("uu_appg01_cache");
const { BaseError, Digest, Base64, ValueConverter, Config, Json } = require("uu_appg01_core-utils");
const CoreAuthenticationService = require("uu_appg01_core-authentication").AuthenticationService;
const { InvalidCredentials, AuthenticationError } = require("uu_appg01_core-authentication");
const { LoggerFactory } = require("uu_appg01_core-logging");
const DefaultServiceLoader = require("./internal/default-service-loader.js");
const OAuthClient = require("./internal/oauth-client.js");
const OAuthCode = require("./internal/oauth-code.js");
const ClientCredentialsProvider = require("./internal/client-credentials-provider.js");
const OidcSession = require("./session.js");
const { ContextStore } = require("uu_appg01_core-utils");
let UseCaseContext = null;
try {
  UseCaseContext = require("uu_appg01_core-appserver").UseCaseContext;
} catch (e) {
  UseCaseContext = null;
}

const CONFIG_PREFIX = "uu_app_oidc_providers_";

const DEFAULT_ACCESS_TOKEN_PATTERN = ".*";
const DEFAULT_REFRESH_TOKEN_PATTERN = ".*";
const DEFAULT_PRESERVE_ACTOR = true;
const DEFAULT_VERIFY_AUDIENCE = false;
const UU_CLOUD_ENV_VARIABLE = "UU_CLOUD_HOST_NAME";

const META_SERVICE_NAME = "uu_appg01_oidc";

const OAUTH_CODE = "code";
const OAUTH_REDIRECT_URI = "redirect_uri";
const JWT_TOKEN_REGEX = /^[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+$/;

const SERVICE_UU_IDENTITY_CACHE_CODE = "uu_appg01_oidc/serviceUuIdentityCache";
const SERVICE_UU_IDENTITY_CACHE_TTL_CONFIG_NAME = "uu_appg01_oidc_service_uu_identity_cache_ttl";
const SERVICE_UU_IDENTITY_CACHE_TTL_DEFAULT_VALUE = 24 * 60 * 60 * 1000;

const asid = Config.get("asid");
const logger = LoggerFactory.get("uuapp.oidc.AuthenticationService");

/**
 * Implementation of authentication service based on uuOIDC.
 */
class OidcAuthenticationService {
  /**
   * Load and initialize authentication service(s)
   * @param reconfigure
   */
  static load(reconfigure = false) {
    DefaultServiceLoader.load(OidcAuthenticationService, reconfigure);
  }

  /**
   * Creates new instance of uuOIDC authentication service and registers it
   * as authentication service with given name.
   * @param {String} name Service name
   * @param {Object|null} opts Service options
   * @param {String|Uri|null} opts.serviceUri Base URI of OIDC server
   * @param {number} options.tokenCacheSize Maximal size of call token cache
   * @param {number} options.tokenTimeLeeway Time verification tolerance (in seconds)
   */
  static create(name, opts = {}) {
    // Do not allow reinitialization of already registered services
    let force = opts.force || false;
    if (!force && this._providers[name]) {
      return;
    }

    let authService = new this(name, opts);
    // Register service in global authentication service component
    CoreAuthenticationService._register(name, authService);
    // Register oidc meta-service to be able to use multiple oidc providers via generic API
    CoreAuthenticationService._register(META_SERVICE_NAME, this);
    // Store service localy
    // (to be able to choose service based on tokens)
    this._providers[name] = authService;
    if (!this._primaryProvider) {
      this._primaryProvider = name;
    }
  }

  /**
   * Authenticates user.
   * @param {Object|String} credentials User credentials to be verified (data object or token string)
   * @param {String} credentials.access_code1 User access code 1
   * @param {String} credentials.access_code2 User access code 2
   * @param {String} credentials.code Value for OAuth code flow
   * @param {String} credentials.systemIdentity Value for OAuth Client Credentials Flow
   * @param {String|null} scope Scope (single value or array) representing functionality to be invoked within session.
   * @param {Object} opts Authentication options.
   * @param {Boolean} opts.allowPasswordFile If set to false, password file authentication will be disabled. Default value is true.
   * @param {Boolean} opts.preserveActor If set to false, impersonation flow in system identity authentication will not be used. Default value is true.
   * @returns {Promise<Session>} User session for passed user credentials.
   * @throws {InvalidCredentials} In case credentials are not valid.
   * @throws {AuthenticationError} In case authentication fails.
   */
  static async authenticate(credentials, scope = null, opts = {}) {
    if (opts.allowPasswordFile !== false) {
      credentials = await this._resolvePasswordFileCredentials(credentials);
    }
    let supportedServices = [];
    let authenticationErrors = [];
    if (!credentials) {
      // In case of interactive login, we just have to use primary service
      // (we cannot try multiple services due to required browser interaction)
      supportedServices.push(this._providers[this._primaryProvider]);
    } else {
      // In case of given credentials, find all services supporting it
      // (primary service should be always first to check)
      let primaryProvider = this._providers[this._primaryProvider];
      try {
        if (await primaryProvider.areCredentialsSupported(credentials)) {
          supportedServices.push(primaryProvider);
        }
      } catch (e) {
        // Remember problem with checking supported credentials
        authenticationErrors.push([primaryProvider.getServiceName(), e]);
      }
      for (let provider of Object.values(this._providers)) {
        if (provider.getServiceName() !== this._primaryProvider) {
          try {
            if (await provider.areCredentialsSupported(credentials)) {
              supportedServices.push(provider);
            }
          } catch (e) {
            // Remember problem with checking supported credentials
            authenticationErrors.push([provider.getServiceName(), e]);
          }
        }
      }
    }
    if (supportedServices.length === 0) {
      for (let [serviceName, error] of authenticationErrors) {
        logger.error(`Checking of supported credentials for ${serviceName} failed.`, error);
      }
      throw new InvalidCredentials("Unsupported credentials.");
    }
    // Iterate throuth each service supporting credentials and try to authenticate
    for (let service of supportedServices) {
      try {
        //In case of successful authentication return immediately
        return await service.authenticate(credentials, scope, opts);
      } catch (e) {
        // Remember service name and authentication error
        authenticationErrors.push([service.getServiceName(), e]);
      }
    }
    for (let [serviceName, error] of authenticationErrors.slice(0, -1)) {
      logger.error(`Authentication with ${serviceName} failed.`, error);
    }
    //In case authentication did not succeed, throw last error
    throw authenticationErrors.pop()[1];
  }

  static async authenticateSystemIdentity(scope, opts = {}) {
    if (UseCaseContext && UseCaseContext.getUri()) {
      return OidcAuthenticationService.authenticate({ systemIdentity: UseCaseContext.getUri().getAwid() }, scope, opts);
    } else {
      return OidcAuthenticationService.authenticate({ systemIdentity: asid }, scope, opts);
    }
  }

  /**
   * Returns name of primary authentication service.
   * @returns {String} Name of primary authentication service
   */
  static getServiceName() {
    let primaryProvider = this._providers[this._primaryProvider];
    return primaryProvider ? primaryProvider.getServiceName() : null;
  }

  /**
   * Returns URI of primary authentication service.
   * @returns {String} URI of primary authentication service
   */
  static async getServiceUri() {
    let primaryProvider = this._providers[this._primaryProvider];
    return primaryProvider ? await primaryProvider.getServiceUri() : null;
  }

  /**
   * Returns URI of primary authentication service.
   * @returns {String} URI of primary authentication service
   * @deprecated
   */
  static getProviderUri() {
    let primaryProvider = this._providers[this._primaryProvider];
    return primaryProvider ? primaryProvider.getProviderUri() : null;
  }

  /**
   * Creates new instance of uuOIDC authentication service.
   * @param {String} name Service name
   * @param {Object|null} opts Service options
   * @param {String|Uri|null} opts.serviceUri Base URI of OIDC server
   * @param {number} options.tokenCacheSize Maximal size of call token cache
   * @param {number} options.tokenTimeLeeway Time verification tolerance (in seconds)
   */
  constructor(name, opts = {}) {
    if (!name) {
      throw new BaseError("Service name is not defined");
    }
    this._serviceName = name;
    this._serviceUri = opts.serviceUri;
    if (!this._serviceUri) {
      throw new BaseError(`There is no service URI defined for service ${this._serviceName}`);
    }
    this._configPrefix = `${CONFIG_PREFIX}${name}_`;
    let cacheMaxAge = Config.get(SERVICE_UU_IDENTITY_CACHE_TTL_CONFIG_NAME) !== null
      ? Config.getNumber(SERVICE_UU_IDENTITY_CACHE_TTL_CONFIG_NAME) * 1000
      : SERVICE_UU_IDENTITY_CACHE_TTL_DEFAULT_VALUE;
    try {
      this._serviceUuIdentityCache = CacheManager.getCache(SERVICE_UU_IDENTITY_CACHE_CODE);
    } catch (e) {
      if (e.message.endsWith('does not exist.')) {
        this._serviceUuIdentityCache = CacheManager.createCache(SERVICE_UU_IDENTITY_CACHE_CODE, { ttl: cacheMaxAge });
      }
    }
    this._accessTokenPattern = new RegExp(opts.accessTokenPattern || DEFAULT_ACCESS_TOKEN_PATTERN);
    this._refreshTokenPattern = new RegExp(opts.refreshTokenPattern || DEFAULT_REFRESH_TOKEN_PATTERN);
    this._doVerifyAudience = typeof opts.verifyAudience === "boolean" ? opts.verifyAudience : DEFAULT_VERIFY_AUDIENCE;
    // Allow audience alias by default in uuCloud environment (checked by presence of specific uuCloud environment variable)
    this._allowAudienceAlias =
      typeof opts.allowAudienceAlias === "boolean" ? opts.allowAudienceAlias : !!process.env[UU_CLOUD_ENV_VARIABLE];
    let oauthRealization;
    if (opts.oauthRealization) {
      let sourcePath = Config.get("server_root") || Process.cwd();
      oauthRealization = ValueConverter.toClass(opts.oauthRealization, sourcePath);
    } else {
      oauthRealization = OAuthClient;
    }
    this._oauthClient = new oauthRealization(this._serviceUri, opts);
    this._oauthCode = new OAuthCode(this._serviceUri, opts);
    this._callTokenType = opts.callTokenType;
    this._callTokenIntrospectAge = opts.callTokenIntrospectAge;
    this._logger = LoggerFactory.get("uuapp.oidc.AuthenticationService");
  }

  /**
   * Returns Returns name of authentication service.
   * @returns {String} Name of authentication service
   */
  getServiceName() {
    return this._serviceName;
  }

  /**
   * Returns URI of authentication service.
   * @returns {String} URI of authentication service
   */
  async getServiceUri() {
    return (await this._oauthClient.getIssuerList())[0];
  }

  /**
   * Returns URI of authentication service.
   * @returns {String|Uri|*} URI of authentication service
   * @deprecated
   */
  getProviderUri() {
    return this._serviceUri;
  }

  /**
   * Checks if credentials are supported by service.
   * @param credentials Credentials to be checked.
   * @return {Promise<boolean>} True if credentials are supported
   */
  async areCredentialsSupported(credentials) {
    if (typeof credentials === "string") {
      if (credentials.match(JWT_TOKEN_REGEX)) {
        let tokenIssuer = null;
        try {
          tokenIssuer = JSON.parse(Base64.urlSafeDecode(credentials.split(".")[1])).iss;
        } catch (e) {
          throw new InvalidCredentials("Token is not trusted (unknown token issuer).", e);
        }
        let supportedIssuers = await this._oauthClient.getIssuerList();
        return supportedIssuers.includes(tokenIssuer);
      } else {
        return !!credentials.match(this._accessTokenPattern);
      }
    } else if (typeof credentials === "object") {
      return true;
    } else {
      return false;
    }
  }

  async authenticate(credentials, scope = null, opts = {}) {
    if (opts.allowPasswordFile !== false) {
      credentials = await OidcAuthenticationService._resolvePasswordFileCredentials(credentials);
    }
    let session = null;
    if (!credentials) {
      if (!this._oauthCode.isSupported()) {
        throw new InvalidCredentials("Missing credentials.");
      }
      let clientId = await ClientCredentialsProvider.getClientId(this._serviceName);
      try {
        credentials = await this._oauthCode.get(clientId, scope);
      } catch (e) {
        throw new AuthenticationError("Authentication failed.", e);
      }
      session = await this.authenticate(credentials, scope);
    } else if (typeof credentials === "string") {
      let supportedAcrValues;
      let claims;
      let idToken;
      let accessToken;
      if (JWT_TOKEN_REGEX.test(credentials)) {
        claims = await this._oauthClient.parseToken(credentials, this._callTokenType, true, null);
        if (this._callTokenIntrospectAge != null && claims.iat && (claims.iat + this._callTokenIntrospectAge) < (Date.now() / 1000)) {
          let clientCredentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName);
          claims = await this._oauthClient.introspectToken(credentials, this._callTokenType, clientCredentials);
        }
        if (this._doVerifyAudience) {
          await this._verifyAudience(claims);
        }
        supportedAcrValues = await this._oauthClient.getSupportedAcrValues();
        if (this._callTokenType === "idToken") {
          idToken = credentials;
          accessToken = null;
        } else if (this._callTokenType === "accessToken") {
          idToken = null;
          accessToken = credentials;
        } else {
          // uuOidc by default uses JWT format only for idToken
          idToken = credentials;
          accessToken = null;
        }
      } else {
        let tokenKey = Digest.sha1(credentials);
        claims = await this._oauthClient.getToken(tokenKey);
        if (!claims) {
          let clientCredentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName);
          claims = await this._oauthClient.parseToken(credentials, this._callTokenType, true, clientCredentials);
          if (this._doVerifyAudience) {
            await this._verifyAudience(claims);
          }
          this._oauthClient.cacheToken(tokenKey, claims.exp, claims);
        } else if (this._callTokenIntrospectAge != null && claims.iat && (claims.iat + this._callTokenIntrospectAge) < (Date.now() / 1000)) {
          // In case token claims of access token are returned from cache, do additional intropection if needed
          let clientCredentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName);
          claims = await this._oauthClient.introspectToken(credentials, this._callTokenType, clientCredentials);
        }
        supportedAcrValues = await this._oauthClient.getSupportedAcrValues();
        if (this._callTokenType === "idToken") {
          idToken = credentials;
          accessToken = null;
        } else if (this._callTokenType === "accessToken") {
          idToken = null;
          accessToken = credentials;
        } else {
          // uuOidc by default uses JWT format only for idToken
          idToken = null;
          accessToken = credentials;
        }
      }
      session = new OidcSession(this._serviceName, this._oauthClient, supportedAcrValues, claims, idToken, accessToken);
    } else {
      let clientCredentials = credentials.clientCredentials;
      if (credentials[OAUTH_CODE]) {
        if (!clientCredentials) {
          clientCredentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName);
        }
        let authorizationCode = credentials[OAUTH_CODE];
        let redirectUri = credentials[OAUTH_REDIRECT_URI];
        let token = await this._oauthClient.grantAuthorizationCodeToken(
          authorizationCode,
          clientCredentials,
          redirectUri,
          scope
        );
        let claims = await this._oauthClient.parseToken(token.id_token, "idToken");
        let supportedAcrValues = await this._oauthClient.getSupportedAcrValues();
        session = new OidcSession(
          this._serviceName,
          this._oauthClient,
          supportedAcrValues,
          claims,
          token.id_token,
          token.access_token
        );
      } else if (credentials.systemIdentity) {
        const awid = credentials.systemIdentity;
        if (awid === asid) {
          if (UseCaseContext && UseCaseContext.getUri() && UseCaseContext.getUri().getAwid() !== asid) {
            this._logger.info(
              `Authentication of asid System Identity ${asid} from awid request scope ${UseCaseContext.getUri().getAwid()}.`
            );
          }
        } else {
          if (!UseCaseContext || !UseCaseContext.getUri()) {
            throw new AuthenticationError("Authentication of System Identity failed. Unable to load request context.");
          }

          let contextAwid = UseCaseContext.getUri().getAwid();
          if (contextAwid === asid) {
            this._logger.info(
                `Authentication of awid System Identity ${awid} from asid request scope ${asid}.`
            );
          } else if (contextAwid !== awid) {
            throw new InvalidCredentials("Invalid System Identity credentials. It is forbidden to authenticate System Identity of different awid.");
          }
        }
        let clientId;
        if (clientCredentials) {
          clientId = clientCredentials.client_id;
        } else {
          clientId = await ClientCredentialsProvider.getClientId(this._serviceName, awid);
        }
        
        let token;
        let claims;
        let actorSession;
        let cfgKey = `${this._configPrefix}preserve_actor`;
        let useImpersonationFlow = Config.hasKey(cfgKey) ? Config.getBoolean(cfgKey) : DEFAULT_PRESERVE_ACTOR;
        if (opts.hasOwnProperty('preserveActor')) {
          useImpersonationFlow = opts.preserveActor;
        }
        if (useImpersonationFlow) {
          if (UseCaseContext && typeof UseCaseContext.getSession === 'function') {
            actorSession = UseCaseContext.getSession();
            let actorToken = actorSession ? await actorSession.getCallToken(null, { useTokenExchange: false, excludeAuthenticationType: true }) : null;
            if (!actorToken) {
              useImpersonationFlow = false;
            }
          }
        }
        if (useImpersonationFlow && actorSession) {
          let serviceUuIdentity = await this._serviceUuIdentityCache.get(awid, clientId);
          if (!serviceUuIdentity) {
            if (!clientCredentials) {
              clientCredentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName, awid);
            }
            let clientCredentialsToken = await this._grantClientCredentialsToken(clientId, clientCredentials, scope, awid);
            let clientCredentialsTokenClaims = await this._oauthClient.parseToken(clientCredentialsToken.id_token, "idToken");
            serviceUuIdentity = clientCredentialsTokenClaims.uuidentity;
            await this._serviceUuIdentityCache.set(awid, clientId, serviceUuIdentity);
          }
          let impersonationedTokenKey;
          let initialActorUuIdentity = actorSession.getActorIdentity() ? actorSession.getActorIdentity().getUuIdentity() : actorSession.getIdentity().getUuIdentity();
          if (Array.isArray(scope)) {
            impersonationedTokenKey = Digest.sha1(`${initialActorUuIdentity}:${actorSession.getIdentity().getUuIdentity()}:${clientId}:${scope.sort().join("|")}`);
          } else {
            impersonationedTokenKey = Digest.sha1(`${initialActorUuIdentity}:${actorSession.getIdentity().getUuIdentity()}:${clientId}:${scope}`);
          }
          token = this._oauthClient.getToken(impersonationedTokenKey);
          if (!token) {
            if (!clientCredentials) {
              clientCredentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName, awid);
            }
            let actorToken = await actorSession.getCallToken(null, { useTokenExchange: false, excludeAuthenticationType: true });
            let subjectToken = Base64.urlSafeEncode(Json.stringify({uuidentity: serviceUuIdentity}));
            token = await this._oauthClient.delegateToken(actorToken, null, subjectToken, clientCredentials, scope);
            let expiresAt = token.expires_at || Number(Date.now() / 1000 + token.expires_in);
            this._oauthClient.cacheToken(impersonationedTokenKey, expiresAt, token);
          }
          claims = await this._oauthClient.parseToken(token.id_token, "idToken");
        } else {
          let tokenKey;
          if (Array.isArray(scope)) {
            tokenKey = Digest.sha1(`${clientId}:${scope.sort().join("|")}`);
          } else {
            tokenKey = Digest.sha1(`${clientId}:${scope}`);
          }
          token = this._oauthClient.getToken(tokenKey);
          if (!token) {
            if (!clientCredentials) {
              clientCredentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName, awid);
            }
            token = await this._grantClientCredentialsToken(clientId, clientCredentials, scope, awid);
            let expiresAt = token.expires_at || Number(Date.now() / 1000 + token.expires_in);
            this._oauthClient.cacheToken(tokenKey, expiresAt, token);
          }
          claims = await this._oauthClient.parseToken(token.id_token, "idToken");
          await this._serviceUuIdentityCache.set(awid, clientId, claims.uuidentity);
        }
        
        let supportedAcrValues = await this._oauthClient.getSupportedAcrValues();
        session = new OidcSession(
          this._serviceName,
          this._oauthClient,
          supportedAcrValues,
          claims,
          token.id_token,
          token.access_token
        );
      } else {
        let clientId;
        if (clientCredentials) {
          clientId = clientCredentials.client_id;
        } else {
          clientId = await ClientCredentialsProvider.getClientId(this._serviceName);
        }
        let username = credentials.username || credentials.accessCode1 || credentials.access_code1;
        let password = credentials.password || credentials.accessCode2 || credentials.access_code2;
        if (!username || !password) {
          throw new InvalidCredentials("Unsupported credentials.");
        }
        let tokenKey;
        if (Array.isArray(scope)) {
          tokenKey = Digest.sha1(`${username}:${clientId}:${scope.sort().join("|")}`);
        } else {
          tokenKey = Digest.sha1(`${username}:${clientId}:${scope}`);
        }
        let token = this._oauthClient.getToken(tokenKey);
        if (!token) {
          if (!clientCredentials) {
            clientCredentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName);
          }
          token = await this._oauthClient.grantResourceOwnerPasswordCredentialsToken(
            username,
            password,
            clientCredentials,
            scope
          );
          let expiresAt = token.expires_at || Number(Date.now() / 1000 + token.expires_in);
          this._oauthClient.cacheToken(tokenKey, expiresAt, token);
        }
        let claims = await this._oauthClient.parseToken(token.id_token, "idToken");
        let supportedAcrValues = await this._oauthClient.getSupportedAcrValues();
        session = new OidcSession(
          this._serviceName,
          this._oauthClient,
          supportedAcrValues,
          claims,
          token.id_token,
          token.access_token
        );
      }
    }
    return session;
  }

  async authenticateSystemIdentity(scope, opts = {}) {
    if (UseCaseContext && UseCaseContext.getUri()) {
      return this.authenticate({ systemIdentity: UseCaseContext.getUri().getAwid() }, scope, opts);
    } else {
      return this.authenticate({ systemIdentity: asid }, scope, opts);
    }
  }

  async _grantClientCredentialsToken(clientId, clientCredentials, scope, awid) {
    let tokenKey;
    if (Array.isArray(scope)) {
      tokenKey = Digest.sha1(`${clientId}:${scope.sort().join("|")}`);
    } else {
      tokenKey = Digest.sha1(`${clientId}:${scope}`);
    }
    let token = this._oauthClient.getToken(tokenKey);
    if (!token) {
      if (!clientCredentials) {
        clientCredentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName, awid);
      }
      token = await this._oauthClient.grantClientCredentialsToken(clientCredentials, scope);
      let expiresAt = token.expires_at || Number(Date.now() / 1000 + token.expires_in);
      this._oauthClient.cacheToken(tokenKey, expiresAt, token);
    }
    return token;
  }

  async _verifyAudience(claims) {
    let serviceUri = null;
    let serviceUriAlias = null;
    if (UseCaseContext && ContextStore.get("uuapp.server.endpoint")) {
      serviceUri = UseCaseContext.getUri().toString();
      if (this._allowAudienceAlias) {
        let baseUriAlias = UseCaseContext.getBaseUriAlias();
        if (baseUriAlias) {
          serviceUriAlias = `${baseUriAlias}/${UseCaseContext.getUri().getUseCase()}`;
        }
      }
    }
    let audienceClaim = claims.aud ? (Array.isArray(claims.aud) ? claims.aud : [claims.aud]) : [];
    let checkServiceUri = serviceUri && audienceClaim.length > 1;
    let clientId = null;
    if (!checkServiceUri) {
      clientId = await ClientCredentialsProvider.getClientId(this._serviceName);
    }
    for (let audience of audienceClaim) {
      if (checkServiceUri) {
        if (serviceUri.startsWith(audience) || (serviceUriAlias && serviceUriAlias.startsWith(audience))) {
          return true;
        }
      } else {
        if (clientId === audience) {
          return true;
        }
      }
    }
    throw new InvalidCredentials(
      `Token scope does not match (verified value: "${
        checkServiceUri ? serviceUri : clientId
      }", received scope: [${audienceClaim.join(", ")}]).`
    );
  }

  static async _resolvePasswordFileCredentials(credentials) {
    if (typeof credentials !== "string") {
      return credentials;
    }
    let passwdFilePath = credentials;
    if (!Path.isAbsolute(passwdFilePath)) {
      passwdFilePath = Path.join(Os.homedir(), ".uu", passwdFilePath);
    }
    if (!(await fsExists(passwdFilePath))) {
      return credentials;
    }
    credentials = {};
    let passwdFileContent = await fsReadFile(passwdFilePath, "utf8");
    passwdFileContent = passwdFileContent.replace(/\r\n?/g, "\n");
    passwdFileContent.split("\n").forEach(function (line) {
      line = line.trim();
      if (/^[#!]/.test(line)) {
        return;
      }
      let [name, value] = line.split(/[=:](.*)/, 2);
      name = name ? name.trim() : null;
      if (name) {
        value = value ? value.trimLeft() : null;
        credentials[name] = value ? value : null;
      }
    });
    return credentials;
  }
}

OidcAuthenticationService._providers = {};
OidcAuthenticationService._primaryProvider = null;

// Load all available OIDC authentication services
OidcAuthenticationService.load(false);

module.exports = OidcAuthenticationService;
