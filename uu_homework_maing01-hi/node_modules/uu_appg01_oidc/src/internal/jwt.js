"use strict";

const Crypto = typeof window === "undefined" ? require("crypto") : window.crypto;
// With Node.js 15-18 webcrypto is experimental and available via different module than on 19+
const SubtleCrypto = (Crypto && Crypto.subtle) || (Crypto && Crypto.webcrypto && Crypto.webcrypto.subtle);
const { InvalidCredentials } = require("uu_appg01_core-authentication");
const { Base64, Json } = require("uu_appg01_core-utils");
const Jwks = require("./jwks.js");

const JWT_TOKEN_REGEX = /^[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+$/;
const DEFAULT_TOKEN_TIME_LEEWAY = 5 * 60;
const DEFAULT_TOKEN_TYPE = "JWT"
const DEFAULT_TOKEN_SIGN_ALG = "RS256";

const DEFAULT_PUBLIC_KEY_FORMAT = "jwk";
const DEFAULT_PRIVATE_KEY_FORMAT = "pkcs8";
const DEFAULT_KEY_ALGORITHM = "RSASSA-PKCS1-v1_5";
const DEFAULT_KEY_DIGEST = "SHA-256";
const DEFAULT_KEY_PARAMS = {name: DEFAULT_KEY_ALGORITHM, hash: {name: DEFAULT_KEY_DIGEST}}

class Jwt {

  constructor(discovery, opts = {}) {
    if (!discovery) {
      throw new BaseError("Instance of discovery must be provided");
    }
    this._discovery = discovery;
    this._jwks = new Jwks(this._discovery, opts);
    this._customIssuer = opts.issuer;
    this._tokenTimeLeeway = opts.tokenTimeLeeway ? Number(opts.tokenTimeLeeway) : DEFAULT_TOKEN_TIME_LEEWAY;
    this._disableWebcryptoApi =  (typeof opts.disableWebcryptoApi === "boolean") ? opts.disableWebcryptoApi : false;
    this._textEncoder = new TextEncoder();
  }

  async parseToken(token, verify = true, verifyOpts = {}) {
    if (!token || !token.match(JWT_TOKEN_REGEX)) {
      throw new InvalidCredentials("Unsupported token format.");
    }
    let tokenParts = token.split(".");
    let headers, claims;
    try {
      headers = Json.parse(Base64.urlSafeDecode(tokenParts[0]));
      claims = Json.parse(Base64.urlSafeDecode(tokenParts[1]));
    } catch (e) {
      throw new InvalidCredentials("Parsing of token failed.", e);
    }
    if (verify) {
      await this._verifyToken(headers, claims, tokenParts, verifyOpts);
    }
    return claims;
  }

  async createToken(claims, privateKey) {
    let headers = {alg: DEFAULT_TOKEN_SIGN_ALG, typ: DEFAULT_TOKEN_TYPE};
    let signedData = Base64.urlSafeEncode(Json.stringify(headers)) + "." + Base64.urlSafeEncode(Json.stringify(claims));
    let signature;
    if (SubtleCrypto && !this._disableWebcryptoApi) {
      if (privateKey.includes("RSA PRIVATE KEY")) {
        // This is for backward compatibility with applications which were initialized
        // using "node-rsa" library generating private key in PKCS#1 format, as native
        // SubtleCrypto API supports only PKCS#8 format.
        privateKey = Crypto.createPrivateKey(privateKey);
        privateKey = privateKey.export({format: "pem", type: "pkcs8"});
      }
      privateKey = Base64.decode(privateKey.split("\n").slice(1, -1).join(), "binary");
      let cryptoKey = await SubtleCrypto.importKey(DEFAULT_PRIVATE_KEY_FORMAT, privateKey, DEFAULT_KEY_PARAMS, true, ["sign"]);
      signature = await SubtleCrypto.sign(DEFAULT_KEY_PARAMS, cryptoKey, this._textEncoder.encode(signedData));
    } else {
      // Fallback for environments where SubtleCrypto is not available
      // (older brosers, browsers without SSL context, and older versions of Node.js)
      let JSRSASIGN;
      if (typeof window === "undefined") {
        // TODO Workaround mainly for jest which cannot handle import.
        // Require must be done via variable, else webpack will bundle
        // jsrasing into library instead of using external chunk.
        let requireName = "jsrsasign";
        JSRSASIGN = require(requireName);
      } else {
        JSRSASIGN = await import("jsrsasign");
      }
      let sig = new JSRSASIGN.KJUR.crypto.Signature({alg: "SHA256withRSA"});
      sig.init(privateKey);
      sig.updateString(signedData);
      signature = Uint8Array.from(sig.sign().match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
    }
    return signedData + "." + Base64.urlSafeEncode(signature);
  }

  isExpired(claims, leeway = null) {
    leeway = leeway != null ? leeway : this._tokenTimeLeeway;
    return claims.exp && claims.exp < (Date.now() / 1000 - leeway);
  }

  verifyExpiration(claims, leeway = null) {
    if (this.isExpired(claims, leeway)) {
      throw new InvalidCredentials("Token is expired.");
    }
  }

  async _verifyToken(headers, claims, tokenParts, verifyOpts = {}) {
    this.verifyExpiration(claims, verifyOpts && verifyOpts.leeway);

    let expectedIssuer = verifyOpts && verifyOpts.issuer;
    if (!expectedIssuer) {
      let metadata = await this._discovery.getMetadata();
      expectedIssuer = [metadata.issuer];
      if (metadata.access_token_issuer) {
        expectedIssuer.push[metadata.access_token_issuer];
      }
      if (this._customIssuer) {
        expectedIssuer.push[this._customIssuer];
      }
    } else if (!Array.isArray(expectedIssuer)) {
      expectedIssuer = [expectedIssuer];
    }
    if (!expectedIssuer.includes(claims.iss)) {
      throw new InvalidCredentials("Unsupported issuer.");
    }

    let publicKey = verifyOpts && verifyOpts.publicKey;
    if (!publicKey) {
      publicKey = await this._jwks.getPublicKeyData(headers.kid);
    }
    let expectedAlgorithm = publicKey.alg;
    if (!expectedAlgorithm) {
      let metadata = await this._discovery.getMetadata();
      expectedAlgorithm = (metadata.id_token_signing_alg_values_supported || [])[0];
      if (!expectedAlgorithm) {
        expectedAlgorithm = DEFAULT_TOKEN_SIGN_ALG;
      }
    }    
    if (headers.alg != DEFAULT_TOKEN_SIGN_ALG) {
      throw new InvalidCredentials("Unexpected signature algorithm.");
    }

    let signedData = tokenParts[0] + "." + tokenParts[1];
    let signature = Base64.decode(tokenParts[2], "binary");
    let isValid;
    if (SubtleCrypto && !this._disableWebcryptoApi) {
      try {
        let cryptoKey = await SubtleCrypto.importKey(DEFAULT_PUBLIC_KEY_FORMAT, publicKey, DEFAULT_KEY_PARAMS, false, ['verify']);
        signedData = this._textEncoder.encode(signedData);
        isValid = await SubtleCrypto.verify(DEFAULT_KEY_PARAMS, cryptoKey, signature, signedData);
      } catch (e) {
        throw new InvalidCredentials("Unable to verify signature.", e);
      }
    } else {
      // Fallback for environments where SubtleCrypto is not available
      // (older brosers, browsers without SSL context, and older versions of Node.js)
      let JSRSASIGN;
      if (typeof window === "undefined") {
        // TODO Workaround mainly for jest which cannot handle import.
        // Require must be done via variable, else webpack will bundle
        // jsrasing into library instead of using external chunk.
        let requireName = "jsrsasign";
        JSRSASIGN = require(requireName);
      } else {
        JSRSASIGN = await import("jsrsasign");
      }
      try {
        signature = signature.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');
        publicKey = JSRSASIGN.KEYUTIL.getKey(publicKey);
        let sig = new JSRSASIGN.KJUR.crypto.Signature({alg: "SHA256withRSA"});
        sig.init(publicKey);
        sig.updateString(signedData);
        isValid = sig.verify(signature);
      } catch (e) {
        throw new InvalidCredentials("Unable to verify signature.", e);
      }
    }
    if (!isValid) {
      throw new InvalidCredentials("Invalid token signature.");
    }
  }

}

module.exports = Jwt;
