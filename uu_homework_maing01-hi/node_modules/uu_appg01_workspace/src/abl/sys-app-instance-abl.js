"use strict";

const { LruCache, Config } = require("uu_appg01_core-utils");
const { Validator } = require("uu_appg01_core-validation");
const { LoggerFactory } = require("uu_appg01_core-logging");
const { DaoFactory, ObjectStoreError, ObjectNotFound, Lock, ObjectLocked } = require("uu_appg01_objectstore");
const { ValidationHelper } = require("uu_appg01_core-appserver");
const { UriBuilder } = require("uu_appg01_core-uri");
const { AppClient } = require("uu_appg01_server-client");
const { AuditLog } = require("uu_appg01_auditlog");
const UuCmdHelper = require("../helpers/uu-cmd-helper");
const AuthorizeHelper = require("../helpers/authorize-helper.js");

const Errors = require("../api/errors/sys-app-instance-errors");
const OidcClientHelper = require("../helpers/oidc-client-helper");
const AppClientTokenService = require("../app-client-token-service");
const ProfileConfig = require("../helpers/profile-config.js");
const SysProfile = require("./sys-profile-abl");
const SysAppClientTokenAbl = require("./sys-app-client-token-abl");
const SysAppPermission = require("./sys-permission-abl");
const SysDataStoreStats = require("./sys-app-data-store-stats-abl");

const LOCK_CODE = "sysAppInstanceInitLock";
const LOCK_DURATION = 60 * 5;
const APP_INSTANCE_CACHE_TTL_CONFIG_NAME = "uu_app_workspace_app_instance_cache_ttl";
const APP_INSTANCE_CACHE_TTL_DEFAULT_VALUE = 1000 * 60 * 5;
const APP_INSTANCE_AUTH_STRATEGY_ATTRS = [
  "authorizationStrategy",
  "roleGroupUriMap",
  "permissionMap",
  "uuTerritoryBaseUri",
  "boundArtifactId",
  "boundArtifactCode",
  "boundArtifactProfileMap",
];
const SYS_APP_INSTANCE_VERSION = "3.0";
const ROLE_GROUP_INTERFACE = "roleGroupInterface";

const WARNINGS = {
  sysAppInstanceNotProperlyCreated: {
    code: `${Errors.Init.UC_CODE}sysAppInstanceNotProperlyCreated`,
    message: "The uuAppInstance has not been created properly.",
  },
};

/**
 * represent sysAppConfig collection in the database
 * and store configuration of the workspace
 */
class SysAppInstanceAbl {
  constructor() {
    // Initialize cache with TTL 5 minutes if is not configured, configuration is in seconds
    let maxAge =
      Config.get(APP_INSTANCE_CACHE_TTL_CONFIG_NAME) != null
        ? Config.get(APP_INSTANCE_CACHE_TTL_CONFIG_NAME) * 1000
        : APP_INSTANCE_CACHE_TTL_DEFAULT_VALUE;
    this.configCache = new LruCache({ maxAge });
    this.validator = Validator.load();
    this.dao = DaoFactory.getDao("sysUuSubAppInstance");
    this.logger = LoggerFactory.get("uuapp.workspace.SysAppInstanceAbl");

    this.SYS_STATES = {
      CREATED: "created",
      ACTIVE: "active",
      RESTRICTED: "restricted",
    };
  }

  /**
   * Initializes system schemas (SysAppInstance) of application server.
   *
   * @param {Object} params
   * @param {String} params.asid
   * @param {Object} params.dtoIn
   * @param {Object} params.ucUri
   * @param {Object} params.authorizationResult
   * @param {String} params.uuIdentity
   * @param {Object} params.appClientToken
   * @returns {Promise<Object>} uuObject sysAppInstance
   */
  async init({ asid, dtoIn, ucUri, authorizationResult, uuIdentity, appClientToken, session }) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuSubAppInstanceInitDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Init.UC_CODE}unsupportedKeys`, // A1 - dtoIn contains keys beyond the scope of dtoInType
      Errors.Init.InvalidDtoInError // A2 - failed dtoIn validation
    );

    // HDS 1.4. - Keys that are missing from dtoIn and a default value is required for them (see default values table),

    if (!dtoIn.sysState) {
      // set default value
      dtoIn.sysState = this.SYS_STATES.RESTRICTED;
    }
    dtoIn.version = SYS_APP_INSTANCE_VERSION;
    let authData = {};
    APP_INSTANCE_AUTH_STRATEGY_ATTRS.forEach((authAttr) => {
      if (dtoIn[authAttr]) {
        authData[authAttr] = dtoIn[authAttr];
        delete dtoIn[authAttr];
      }
    });

    // HDS 2. - Checks if the caller has rights to initialize an appInstance. One of the following conditions must be met:
    // HDS 2.1. - The caller is the AsidLicenseOwner.
    // HDS 2.2. - baseRegistryUri is loaded from deployment config and uuAppClientToken is validated (using baseRegistryUri).
    const configBaseRegistryUri = Config.get("base_registry_uri");

    if (authorizationResult.isAuthorizationEnabled()) {
      if (authorizationResult.getAuthorizedProfiles().length === 0) {
        let isValid = false;
        if (appClientToken) {
          if (!configBaseRegistryUri) {
            // A4
            throw new Errors.Init.ApplicationIsNotAuthorized({ uuAppErrorMap });
          } else {
            try {
              isValid = await AppClientTokenService.isTokenValid(
                ucUri,
                appClientToken,
                UriBuilder.parse(configBaseRegistryUri).toUri()
              );
            } catch (e) {
              // A5
              throw new Errors.Init.ApplicationSignatureCheckFailed(
                { uuAppErrorMap },
                {
                  uuAppClientToken: appClientToken._original.split(".").slice(0, 2).join("."),
                },
                e
              );
            }
          }
        }

        if (!isValid) {
          let paramMap = {
            uuIdentity,
          };

          if (appClientToken) {
            paramMap.appClientToken = appClientToken._original.split(".").slice(0, 2).join(".");
          }
          // A3
          throw new Errors.Init.UserIsNotAuthorized({ uuAppErrorMap }, paramMap);
        }
      }
    }

    // HDS 3. - System initializes a new key pair using AppComponent method AppClientToken.initKeys.
    await SysAppClientTokenAbl.initKeys(asid);

    // HDS 4. - If dtoIn contains baseRegistryUri, system calls sys/appClientToken/listKeys to verify that baseRegistryUri is valid.
    if (dtoIn.baseRegistryUri) {
      let baseUri = UriBuilder.parse(dtoIn.baseRegistryUri).toUri().getBaseUri();
      let uri = UriBuilder.parse(baseUri).setUseCase("sys/appClientToken/listKeys");
      try {
        await AppClient.get(uri.toString());
      } catch (e) {
        // A6
        throw new Errors.Init.BaseRegistryUriVerificationFailed(
          { uuAppErrorMap },
          { baseRegistryUri: dtoIn.baseRegistryUri },
          e
        );
      }
    }

    // HDS 5. - Verifies, that there is no uuObject sysAppInstance with given asid in uuAppObject store.
    let appInstance = await this.dao.getByAsid(asid);

    if (appInstance) {
      if (appInstance.sysState !== this.SYS_STATES.CREATED) {
        // A7
        throw new Errors.Init.SysUuSubAppInstanceIsAlreadyInitialized({ uuAppErrorMap }, { asid });
      } else {
        try {
          let lock = new Lock(LOCK_CODE, LOCK_DURATION);
          await this.dao.lockOne(asid, lock);
        } catch (e) {
          // A8
          if (e instanceof ObjectLocked) {
            throw new Errors.Init.SysAppInstanceAlreadyCreatedAndLocked({ uuAppErrorMap }, { asid });
          }
          throw e;
        }
        // A9
        ValidationHelper.addWarning(
          uuAppErrorMap,
          WARNINGS.sysAppInstanceNotProperlyCreated.code,
          WARNINGS.sysAppInstanceNotProperlyCreated.message
        );

        let lock = new Lock(LOCK_CODE, LOCK_DURATION);
        await this.dao.unlockOne(asid, lock);
        await this.dao.deleteByAsid(asid);
        await SysProfile.deleteAllAppProfiles(asid);
      }
    } else {
      appInstance = {};
    }

    // HDS 6. - Checks and sets authorization data
    let updateAsidAuthoritiesProfile = false;
    let updateProfilesBasedOnRoleGroupUriMap = false;
    if (dtoIn.uuAppProfileAsidAuthorities && authData.authorizationStrategy) {
      if (authData.authorizationStrategy === ROLE_GROUP_INTERFACE) {
        updateAsidAuthoritiesProfile = true;
        if (authData.roleGroupUriMap) {
          await AuthorizeHelper.setAuthorizationData(
            Errors.Init,
            ucUri,
            authData,
            appInstance,
            session,
            uuAppErrorMap,
            false
          );
          updateProfilesBasedOnRoleGroupUriMap = true;
        }
      } else {
        // A11
        throw new Errors.Init.DtoInNotAmbiguous(
          { uuAppErrorMap },
          { authorizationStrategy: authData.authorizationStrategy }
        );
      }
    }

    if (dtoIn.uuAppProfileAsidAuthorities && !authData.authorizationStrategy) {
      updateAsidAuthoritiesProfile = true;
    } else {
      if (authData.authorizationStrategy === ROLE_GROUP_INTERFACE) {
        await AuthorizeHelper.setAuthorizationData(
          Errors.Init,
          ucUri,
          authData,
          appInstance,
          session,
          uuAppErrorMap,
          false
        );
        updateProfilesBasedOnRoleGroupUriMap = true;
      } else {
        appInstance = await AuthorizeHelper.setAuthorizationData(
          Errors.Init,
          ucUri,
          authData,
          appInstance,
          session,
          uuAppErrorMap
        );
      }
    }

    //HDS 7. - Creates schemas and indexes for uuAppInstance and uuAppWorkSpace and uuAppClientToken -
    // SysAppInstance, SysAppWorkspace, SysProfile, SysPermission, SysUuAppSecret. (dao method createSchema).
    await this.dao.createSchema();
    const schemas = [
      "sysUuSubAppInstance",
      "sysUuAppWorkspace",
      "sysProfile",
      "sysPermission",
      "sysUuAppSecret",
      "sysUuAppDataStoreStats",
      "sysImportMapping",
    ];
    let schemaCreateResults = schemas.map(async (schema) => {
      try {
        return await DaoFactory.getDao(schema).createSchema();
      } catch (e) {
        // A12
        throw new Errors.Init.CreateSchemaDaoFailed({ uuAppErrorMap }, e);
      }
    });
    await Promise.all(schemaCreateResults);

    // HDS 8. - BaseRegistryUri value is loaded from dtoIn. If the value is missing, it is loaded from deployment configuration.
    let baseRegistryUri = dtoIn.baseRegistryUri || configBaseRegistryUri;

    // HDS 9. - In case name, description are missing in dtoIn, the values are loaded from uuBaseRegistry
    // through its interface uuSubAppInstance/get with asid parameter. (A10)
    // TODO HDS 9

    dtoIn.asid = asid;
    // HDS 10. - If there is dtoIn.adviceNote, system also sets adviceNote.uuIdentity to caller uuIdentity and adviceNote.startTime to current time.
    dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);

    // HDS 11. - DtoIn is verified, stored into uuObject sysAppInstance in uuAppObjectStore with sysState.state set to "created" and this uuObject is locked.
    let lock = new Lock(LOCK_CODE, LOCK_DURATION);
    if (!appInstance.authorizationStrategy) appInstance.authorizationStrategy = ROLE_GROUP_INTERFACE;
    let uuObjectCreate = { ...dtoIn, ...appInstance };
    uuObjectCreate.baseRegistryUri = baseRegistryUri;
    delete uuObjectCreate.uuAppProfileAsidAuthorities;
    uuObjectCreate.sysState = this.SYS_STATES.CREATED;
    delete uuObjectCreate.uuAsidEeCredentialsInitToken;
    try {
      await this.dao.create(uuObjectCreate, lock);
    } catch (e) {
      // A13
      if (e instanceof ObjectStoreError) {
        throw new Errors.Init.SysUuSubAppInstanceDaoCreateFailed({ uuAppErrorMap }, e);
      }
      throw e;
    }

    // HDS 12. - Creates uuObject sysProfile for each profile defined in asid profileList in profiles.json.
    const profileCodes = ProfileConfig.getPrivilegedProfiles(asid);
    try {
      await SysProfile.initProfiles(asid, profileCodes);
    } catch (e) {
      // A14
      throw new Errors.Init.SysProfileDaoCreateFailed({ uuAppErrorMap }, e);
    }

    // HDS 13.1 - Updates profiles based on roleGroupUriMap
    if (updateProfilesBasedOnRoleGroupUriMap) {
      await AuthorizeHelper.setAuthorizationData(
        Errors.Init,
        ucUri,
        authData,
        appInstance,
        session,
        uuAppErrorMap,
        true
      );
    }
    // HDS 13.2 - Updates AsidAuthorities profile based on uuAppProfilesAsidAuthorities value
    if (updateAsidAuthoritiesProfile) {
      await this._updateAsidAuthoritiesProfile(Errors.Init, asid, dtoIn.uuAppProfileAsidAuthorities, uuAppErrorMap);
    }

    // HDS 14. - Creates the sysDataStoreStats uuObject in the uuAppObjectStore.
    try {
      await SysDataStoreStats.create(asid);
    } catch (e) {
      // A15
      throw new Errors.Init.SysUuAppInstanceDataStoreStatsDaoCreateFailed({ uuAppErrorMap }, e);
    }

    // HDS 15. - Updates state in uuBaseRegistry to "active" using uuBaseRegistryinterface uuSubAppInstance/activate. (A16, A17)
    // TODO HDS 15

    // HDS 16. - Sets sysState.state of uuObject sysAppInstance to dtoIn.sysState.state value and unlocks it.
    let uuObjectUpdate = { asid, sysState: dtoIn.sysState };
    let dtoOut;
    try {
      await this.dao.update(uuObjectUpdate, lock);
      dtoOut = await this.dao.unlockOne(asid, lock);
    } catch (e) {
      // A18
      throw new Errors.Init.SysUuSubAppInstanceDaoUpdateFailed({ uuAppErrorMap }, e);
    }

    // HDS 17. - If the application is running in production mode,
    // the OIDC client is initialized via uuCmd oidc/initOidcClient.
    await OidcClientHelper.initOidcClient(asid, uuAppErrorMap, this.logger, dtoIn.uuAsidEeCredentialsInitToken); // A19

    // Creating sysAuditLogConfig and sysAuditLogRecord schemas
    if (AuditLog.hasOwnProperty("init")) {
      await AuditLog.init(uuAppErrorMap);
    }

    // HDS 18. - Returns properly filled out dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Updates AsidAuthorities profile based on uuAppProfilesAsidAuthorities value
   *
   * @param error
   * @param asid
   * @param uuAppProfileAsidAuthorities
   * @param uuAppErrorMap
   * @returns {Promise<void>}
   * @private
   */
  async _updateAsidAuthoritiesProfile(error, asid, uuAppProfileAsidAuthorities, uuAppErrorMap) {
    // HDS 13. - Sets roleGroupUri in AsidAuthorities profile (uuObject sysProfile).
    // Value from dtoIn.uuAppProfileAsidAuthorities is used and uuObject is updated.
    if (uuAppProfileAsidAuthorities.startsWith("urn:uuIdentity:")) {
      let uuIdentity = uuAppProfileAsidAuthorities.replace("urn:uuIdentity:", "");
      await SysAppPermission.create(asid, { profile: "AsidAuthorities", uuIdentityList: [uuIdentity] });
    } else {
      try {
        const asidAuthoritiesProfile = await SysProfile.getProfileByCode(asid, "AsidAuthorities");
        asidAuthoritiesProfile.roleGroupUri = uuAppProfileAsidAuthorities;
        await SysProfile.update(asidAuthoritiesProfile);
      } catch (e) {
        // A15
        throw new error.SysProfileDaoUpdateFailed({ uuAppErrorMap }, e);
      }
    }
  }

  /**
   *
   Sets one key of SysAppInstance uuObject to given value.
   Avoid setting the system attributes (described on SysAppInstance schema page).
   It might break functionality of uuAppWorkspace library.
   * @param {string} asid
   * @param {string} key
   * @param {string} value
   * @returns {Promise<*>}
   */

  async setConfigParameter(asid, key, value) {
    const dtoIn = {
      asid,
      key,
    };
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("setConfigInstanceParameterDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetConfigParameter.UC_CODE}unsupportedKeys`, // A1 - dtoIn contains keys beyond the scope of dtoInType
      Errors.SetConfigParameter.InvalidDtoIn // A1 - failed dtoIn validation
    );

    // HDS 2. - Updates sysAppInstance uuObject in uuAppObjectStore (sysAppInstance DAO update) (A2, A3)
    let appInstance;
    let uuOject = { asid };
    uuOject[key] = value;
    try {
      appInstance = await this.dao.update(uuOject);
    } catch (e) {
      if (e instanceof ObjectNotFound) {
        // A2
        throw new Errors.SetConfigParameter.SysUuSubAppInstanceDoesNotExist({ uuAppErrorMap }, { asid });
      } else if (e instanceof ObjectStoreError) {
        // A3
        throw new Errors.SetConfigParameter.SysUuSubAppInstanceDaoUpdateFailed({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    // Update cache
    this._updateCacheByAsid(appInstance);

    // HDS 3. - Returns properly filled dtoOut.
    appInstance.uuAppErrorMap = uuAppErrorMap;
    return appInstance;
  }

  /**
   *
   Gets a value of SysAppInstance uuObject for given key.
   * @param {string} asid
   * @param {string} key
   * @param {Object} uuAppErrorMap
   * @returns {Promise<*>}
   */

  async getConfigParameter(asid, key, uuAppErrorMap = {}) {
    const dtoIn = {
      asid,
      key: key,
    };
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("getConfigInstanceParameterDtoInType", dtoIn);
    ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      Errors.GetConfigParameter.InvalidDtoIn // A1 - failed dtoIn validation
    );

    // HDS 2. - System loads asid from application configuration.
    // HDS 3. - System loads uuObject sysAppInstance from cache. (A2)
    // HDS 4. - System reads value of attribute given in dtoIn.key. (A4)
    let dtoOut = (await this.get(asid))[key]; // A2, A4

    // HDS 5. - Returns properly filled dtoOut.
    return dtoOut === undefined ? null : dtoOut;
  }

  /**
   * Returns application instance.
   *
   * @param {String} asid
   * @param {Object} uuAppErrorMap
   * @returns {Promise<*>}
   */
  async get(asid, uuAppErrorMap = {}) {
    // HDS 1. - System loads uuObject sysAppInstance from cache.
    let appInstance = this.configCache.get(asid);

    // HDS 1.1. - If cache doesn't exist,
    // loads uuObject sysAppInstance from uuAppObjectStore by uuAppInstance DAO getByAsid.
    if (!appInstance) {
      // A1
      appInstance = await this.dao.getByAsid(asid);
      if (!appInstance) {
        // A2
        throw new Errors.Get.SysUuSubAppInstanceDoesNotExistError({ uuAppErrorMap }, { asid });
      }

      // HDS 1.2. - Adds uuObject to the cache.
      this._updateCacheByAsid(appInstance);
    }

    // HDS 2. - Returns properly filled dtoOut.
    appInstance.uuAppErrorMap = uuAppErrorMap;
    return appInstance;
  }

  /**
   * Sets basic properties of uuSubAppInstance like name and description.
   * It does not allow to change properties connected with business logic as version/capacity/licenseOwner etc.
   *
   * @param {String} asid
   * @param {Object} dtoIn
   * @param {Object} uuIdentity
   * @returns {Promise<*>}
   */
  async set(asid, dtoIn, uuIdentity) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuSubAppInstanceSetDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      // A1, A2
      dtoIn,
      validationResult,
      `${Errors.Set.UC_CODE}unsupportedKeys`,
      Errors.Set.InvalidDtoIn
    );

    // HDS 2. - If there is dtoIn.adviceNote, system also sets adviceNote.uuIdentity to caller uuIdentity and adviceNote.startTime to current time.
    if (dtoIn.adviceNote) {
      dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);
    }

    // HDS 3. - Verified dtoIn is saved to the uuAppObjectStore.
    let dtoOut;
    dtoIn.asid = asid;
    try {
      dtoOut = await this.dao.update(dtoIn);
    } catch (e) {
      if (e.cause instanceof ObjectNotFound) {
        // A3
        throw new Errors.Set.SysUuSubAppInstanceDoesNotExist({ uuAppErrorMap }, { asid });
      } else if (e.cause instanceof ObjectStoreError) {
        // A4
        throw new Errors.Set.SysUuSubAppInstanceDaoUpdateFailed({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    this._updateCacheByAsid(dtoOut);

    // HDS 4. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Allows to set one of the active System States of uuAppInstance.
   *
   * @param {String} asid
   * @param {Object} dtoIn
   * @param {String} uuIdentity
   * @returns {Promise<*>}
   */
  async setActiveSysState(asid, dtoIn, uuIdentity) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuSubAppInstanceSetActiveSysStateDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetActiveSysState.UC_CODE}unsupportedKeys`, // A1
      Errors.SetActiveSysState.InvalidDtoIn // A2
    );

    // HDS 2. - If there is dtoIn.adviceNote, system also sets adviceNote.uuIdentity to caller uuIdentity
    // and adviceNote.startTime to current time.
    dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);

    // HDS 3. - System sets sysAppInstance.sysState to active, updates sysAppInstance uuObject
    // (sysAppInstance DAO update) and updates cache. (TTL set to 5 minutes) (A3, A4)
    let dtoOut;
    try {
      let appInstance = { ...dtoIn };
      appInstance.asid = asid;
      appInstance.sysState = this.SYS_STATES.ACTIVE;
      dtoOut = await this.dao.update(appInstance);
    } catch (e) {
      if (e instanceof ObjectNotFound) {
        // A3
        throw new Errors.SetActiveSysState.SysUuSubAppInstanceDoesNotExist({ uuAppErrorMap }, { asid });
      } else if (e instanceof ObjectStoreError) {
        // A4
        throw new Errors.SetActiveSysState.SysUuSubAppInstanceDaoUpdateFailed({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    // Update cache
    this._updateCacheByAsid(dtoOut);

    // HDS 4. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Allows to set uuAppInstance sysState to restricted.
   *
   * @param {String} asid
   * @param {Object} dtoIn
   * @param {String} uuIdentity
   * @returns {Promise<*>}
   */
  async setRestrictedSysState(asid, dtoIn, uuIdentity) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuSubAppInstanceSetRestrictedSysStateDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetRestrictedSysState.UC_CODE}unsupportedKeys`,
      Errors.SetRestrictedSysState.InvalidDtoInError
    ); // A1, A2

    // HDS 2. - If there is dtoIn.adviceNote, system also sets adviceNote.uuIdentity to caller uuIdentity and adviceNote.startTime to current time.
    dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);

    // HDS 3. -
    // System sets sysAppInstance.sysState to restricted, updates sysAppInstance uuObject
    // (sysAppInstance DAO update) and updates cache. (TTL set to 5 minutes) (A3, A4)
    let dtoOut;
    try {
      let appInstance = { ...dtoIn };
      appInstance.asid = asid;
      appInstance.sysState = this.SYS_STATES.RESTRICTED;
      dtoOut = await this.dao.update(appInstance);
    } catch (e) {
      if (e instanceof ObjectNotFound) {
        // A3
        throw new Errors.SetRestrictedSysState.SysUuSubAppInstanceDoesNotExist({ uuAppErrorMap }, { asid });
      } else if (e instanceof ObjectStoreError) {
        // A4
        throw new Errors.SetRestrictedSysState.SysUuSubAppInstanceDaoUpdateFailed({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    // Update cache
    this._updateCacheByAsid(dtoOut);

    // HDS 4. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Allow to set authorization strategy of the uuSubAppInstance.
   *
   * @param {uri} uri uri of the application
   * @param {Object} dtoIn dtoIn attributes to set according to sys/uuSubAppInstance/setAuthorizationStrategy uuCmd
   * @param {Object} session authentication session
   * @returns {Promise<Object>} uuObject sysUuSubAppInstance
   */
  async setAuthorizationStrategy(uri, dtoIn, session) {
    let asid = uri.awid;
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuSubAppInstanceSetAuthStrategyDtoInType", dtoIn);
    // A1, A2
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetAuthorizationStrategy.UC_CODE}unsupportedKeys`,
      Errors.SetAuthorizationStrategy.InvalidDtoInError
    );
    let appInstance = await this.getByAsid(asid);
    // HDS 2. - Checks, if the uuIdentity has rights to run use case sys/uuSubAppInstance/setAuthorizationStrategy
    // in given dtoIn.authorizationStrategy and sets auth data. (A3)
    if (dtoIn.authorizationStrategy === ROLE_GROUP_INTERFACE) {
      appInstance = await AuthorizeHelper.setAuthorizationData(
        Errors.SetAuthorizationStrategy,
        uri,
        dtoIn,
        appInstance,
        session,
        uuAppErrorMap,
        true
      );
    } else {
      appInstance = await AuthorizeHelper.setAuthorizationData(
        Errors.SetAuthorizationStrategy,
        uri,
        dtoIn,
        appInstance,
        session,
        uuAppErrorMap
      );
    }
    // HDS 3. - Sets new authorization attributes to uuSubAppInstance.
    // (sysUuSubAppInstance DAO update) (A4, A5)
    try {
      appInstance = await this.dao.update({ asid, ...appInstance });
    } catch (e) {
      if (e.cause instanceof ObjectNotFound) {
        // A4
        throw new Errors.SetAuthorizationStrategy.SysUuSubAppInstanceDoesNotExist({ uuAppErrorMap }, { asid });
      } else if (e.cause instanceof ObjectStoreError) {
        // A5
        throw new Errors.SetAuthorizationStrategy.SysUuSubAppInstanceDaoUpdateFailed({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    this._updateCacheByAsid(appInstance);
    appInstance.uuAppErrorMap = uuAppErrorMap;
    // HDS 4. - Returns properly filled dtoOut.
    return appInstance;
  }

  /**
   * Return appInstance object by given asid.
   *
   * @param {String} asid
   * @returns {Promise<*>}
   */
  async getByAsid(asid) {
    return await this.dao.getByAsid(asid);
  }

  /**
   * update appInstance with asid in the cache.
   *
   * @param {Object} appInstance
   */
  _updateCacheByAsid(appInstance) {
    if (this.SYS_STATES.CREATED !== appInstance.sysState) {
      this.configCache.set(appInstance.asid, appInstance);
    }
  }

  /**
   * reset cache
   */
  clearCache() {
    this.configCache.clear();
  }
}

module.exports = new SysAppInstanceAbl();
