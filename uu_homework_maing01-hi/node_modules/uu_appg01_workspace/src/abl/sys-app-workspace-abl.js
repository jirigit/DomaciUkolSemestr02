"use strict";

const fs = require("fs");
const path = require("path");
const { Config, Finder, LruCache } = require("uu_appg01_core-utils");
const { Validator } = require("uu_appg01_core-validation");
const { LoggerFactory } = require("uu_appg01_core-logging");
const { DaoFactory, ObjectStoreError, ObjectNotFound, Lock } = require("uu_appg01_objectstore");
const { ValidationHelper } = require("uu_appg01_core-appserver");
const { UriBuilder } = require("uu_appg01_core-uri");
const { AppClient } = require("uu_appg01_server-client");

const SysProfile = require("./sys-profile-abl");
const SysPermission = require("./sys-permission-abl");
const SysAppInstance = require("./sys-app-instance-abl");
const SysAppClientTokenAbl = require("./sys-app-client-token-abl");
const SysDataStoreStats = require("./sys-app-data-store-stats-abl");
const ProfileConfig = require("../helpers/profile-config.js");
const Errors = require("../api/errors/sys-app-workspace-errors.js");
const OidcClientHelper = require("../helpers/oidc-client-helper");
const UuCmdHelper = require("../helpers/uu-cmd-helper");
const AuthorizeHelper = require("../helpers/authorize-helper.js");
const SysAppSecretStoreAbl = require("./sys-app-secret-store-abl");

const ART_AUTHZ_TYPE = "artifact";
const APP_WORKSPACE_CACHE_TTL_CONFIG_NAME = "uu_app_workspace_app_workspace_cache_ttl";
const APP_WORKSPACE_CACHE_TTL_DEFAULT_VALUE = 1000 * 60 * 5;
const SYS_APP_WORKSPACE_VERSION = "3.0";
const DEFAULT_MAX_NOA = 1000;
const ROLE_GROUP_INTERFACE = "roleGroupInterface";
const SECRET_SET = "uuAppOidcClientKey";

/**
 * represent sysAppWorkspace collection in the database
 * and store information about workspace
 */
class SysAppWorkspaceAbl {
  constructor() {
    // Initialize cache with TTL 5 minutes if is not configured, configuration is in seconds
    let maxAge =
      Config.get(APP_WORKSPACE_CACHE_TTL_CONFIG_NAME) != null
        ? Config.getNumber(APP_WORKSPACE_CACHE_TTL_CONFIG_NAME) * 1000
        : APP_WORKSPACE_CACHE_TTL_DEFAULT_VALUE;
    this.sysAppCache = new LruCache({ maxAge });
    this.validator = Validator.load();
    this.dao = DaoFactory.getDao("sysUuAppWorkspace");
    this.logger = LoggerFactory.get("uuapp.workspace.SysAppWorkspaceAbl");
    this.LOCK_CODE = "sysAppInstanceInitLock";
    this.LOCK_DURATION = 60 * 5;

    this.SYS_STATES = {
      REGISTERED: "registered",
      CREATED: "created",
      ASSIGNED: "assigned",
      ACTIVE: "active",
      RESTRICTED: "restricted",
      READ_ONLY: "readOnly",
      SUSPENDED: "suspended",
      CLOSED: "closed",
    };
  }

  /**
   * create empty collection with indexes
   * @returns {Promise<void>}
   */
  async createSchema() {
    await this.dao.createSchema();
  }

  /**
   * creates uuAppWorkspace and sets its state to "created".
   * @param {Object} dtoIn
   * @param {Object} uuIdentity
   * @returns {Promise<{}>}
   */
  async create({ dtoIn, uuIdentity }) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceCreateDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Create.UC_CODE}unsupportedKeys`,
      Errors.Create.InvalidDtoInError
    ); // A1, A2

    // HDS 2. Checks whether the awid can be created.
    const asid = Config.get("asid");
    let uuAppWorkspaceList = []; // is used to collect awids of already created workspaces, not used if empty
    if (dtoIn.awidList) {
      let createdWorkspaces = [];
      for (const awid of dtoIn.awidList) {
        // HDS 2.1. Checks whether the awid can be created.
        // HDS 2.1.1. AWID identificator is the same as ASID.
        if (awid === asid) {
          ValidationHelper.addWarning(
            uuAppErrorMap,
            `${Errors.Create.UC_CODE}awidConflictsWithAsid`,
            `SysUuAppWorkspace cannot be create. Awid must not be the same as asid.`,
            { asid }
          );
          continue;
        }
        // HDS 2.1.2. Checks whether AWID already exists within ASID.
        let appWorkspace = await this.dao.getByAwid(awid);
        if (appWorkspace) {
          createdWorkspaces.push(awid);
          ValidationHelper.addWarning(
            uuAppErrorMap,
            `${Errors.Create.UC_CODE}sysUuAppWorkspaceAlreadyCreated`,
            `SysUuAppWorkspace has already been created.`,
            { awidList: createdWorkspaces }
          );
          continue;
        }
        // HDS 2.2. Creates object SysUuAppWorkspace through the dao method create
        let uuObject = dtoIn;
        delete uuObject.awidList;
        uuObject.awid = awid;
        uuObject.sysState = this.SYS_STATES.CREATED;
        uuObject.version = SYS_APP_WORKSPACE_VERSION;
        let createdWorkspace;
        try {
          createdWorkspace = await this.createUuObject(uuObject);
          uuAppWorkspaceList.push(createdWorkspace);
        } catch (e) {
          throw new Errors.Create.SysUuAppWorkspaceDaoCreateFailedError({ uuAppErrorMap }, e);
        }
      }
      // HDS 3. Returns properly filled dtoOut.
      return { uuAppWorkspaceList, ...{ uuAppErrorMap } };
    }

    // HDS 4. Processees deprecated logic of assigning awid to awidLicenceOwner if it was entered in dtoIn for backwards compatibility.
    if (dtoIn.awid && dtoIn.awidLicenseOwnerList && dtoIn.awidLicense) {
      // HDS 4.A.1. Creates object SysUuAppWorkspace through the dao method create
      const awid = dtoIn.awid;

      let appWorkspace = await this.dao.getByAwid(awid);
      if (appWorkspace) {
        throw new Errors.Create.SysUuAppWorkspaceAlreadyCreated({ uuAppErrorMap }, { awid });
      }

      let uuObject = dtoIn;
      if (uuObject.adviceNote) {
        uuObject = UuCmdHelper.fillAdviceNote(uuObject, uuIdentity);
      }
      uuObject.sysState = this.SYS_STATES.CREATED;
      uuObject.version = SYS_APP_WORKSPACE_VERSION;
      let createdWorkspace;
      try {
        createdWorkspace = await this.createUuObject(uuObject);
      } catch (e) {
        throw new Errors.Create.SysUuAppWorkspaceDaoCreateFailedError({ uuAppErrorMap }, e);
      }

      // HDS 4.A.2. - Creates the SysProfile uuObject for each profile from the profileList defined in profiles.json.
      let profileCodes = ProfileConfig.getProfiles();
      try {
        await SysProfile.initProfiles(awid, profileCodes);
      } catch (e) {
        if (e instanceof ObjectStoreError) {
          throw new Errors.Create.SysProfileDaoCreateFailedError({ uuAppErrorMap }, e);
        }
        throw e;
      }
      // HDS 4.A.3.A - Creates the sysDataStoreStats uuObject in the uuAppObjectStore.
      try {
        await SysDataStoreStats.create(awid);
      } catch (e) {
        throw new Errors.Create.SysUuAppWorkspaceDataStoreStatsDaoCreateFailedError({ uuAppErrorMap }, e);
      }

      // HDS 4.A.3.B Initializes a new key pair using AppComponent method AppClientToken.initKeys

      await SysAppClientTokenAbl.initKeys(awid); // A16

      // HDS 4.A.4. - If the application is started in production mode, the OIDC client is initialized using the uuCmd oidc/initOidcClient
      await OidcClientHelper.initOidcClient(awid, uuAppErrorMap, this.logger); // A17

      // HDS 4. - Returns properly filled out dtoOut.
      let dtoOut = {
        ...createdWorkspace,
        ...{ uuAppErrorMap },
      };
      return dtoOut;
    }
  }

  /**
   * assigns available uuAppWorkspace with selected licence to awidLicenceOwners and sets it to "assigned" state.
   * @param {Object} dtoIn
   * @param {Object} uuIdentity
   * @returns {Promise<{}>}
   */
  async assign({ dtoIn, uuIdentity }) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceAssignDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Assign.UC_CODE}unsupportedKeys`,
      Errors.Assign.InvalidDtoInError
    );
    // A1, A2

    // HDS 2. - Loads uuAppWorkspace to be assigned.

    // HDS 2.A - awid is specified in dtoIn
    let awid = dtoIn.awid;

    let appWorkspace;

    let lock = new Lock(this.LOCK_CODE, this.LOCK_DURATION);
    if (awid) {
      appWorkspace = await this.dao.getByAwid(awid);
      if (!appWorkspace) {
        throw new Errors.Assign.sysUuAppWorkspaceNotCreated({ uuAppErrorMap }, { awid });
      }
      if (appWorkspace) {
        if (appWorkspace.sysState !== this.SYS_STATES.CREATED) {
          // A8
          throw new Errors.Assign.sysUuAppWorkspaceAlreadyAssigned({ uuAppErrorMap }, { awid });
        } else if (appWorkspace.awidLicenseOwnerList) {
          throw new Errors.Assign.sysUuAppWorkspaceNotAvailable({ uuAppErrorMap });
        }
        await this.dao.lockOne(awid, lock);
      }
    } else {
      // HDS 2.B. Lists awids in created state through DAO listBySysStateListAndAwidList and loads the first avalable awid and locks it
      this.logger.debug("Awid wasn't set in dtoIn, looking for workspace in 'created' state");
      const appWorkspaceList = await this.dao.listByStateListAndAwidList([this.SYS_STATES.CREATED]);

      appWorkspace = appWorkspaceList.itemList.find((workspace) => !workspace["awidLicenseOwnerList"]);

      if (!appWorkspace) {
        throw new Errors.Assign.sysUuAppWorkspaceNotAvailable({ uuAppErrorMap });
      }
      awid = appWorkspace.awid;
      await this.dao.lockOne(awid, lock);
      this.logger.debug(`Workspace with awid: ${awid} is about to be assigned`);
    }

    // HDS 3. - Updates the uuAppWorkspace object (through DAO method update) with attributes specified in dtoIn and Added Attributes and unlocks it.
    if (dtoIn.adviceNote) {
      dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);
    }
    appWorkspace = {
      ...appWorkspace,
      ...dtoIn,
    };
    appWorkspace.sysState = this.SYS_STATES.ASSIGNED;
    try {
      appWorkspace = await this.dao.update(appWorkspace, lock);
    } catch (e) {
      if (e instanceof ObjectStoreError) {
        throw new Errors.Assign.SysUuAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, e);
      }
      throw e;
    } finally {
      appWorkspace = await this.dao.unlockOne(appWorkspace.awid, lock);
      this._updateCache(appWorkspace);
    }

    // HDS 4. - Prepares objects on other uuSchemas for given awid.
    // HDS 4.1 - Creates the SysProfile uuObject for each profile from the profileList defined in profiles.json.
    let profileCodes = ProfileConfig.getProfiles();
    try {
      await SysProfile.initProfiles(awid, profileCodes);
    } catch (e) {
      // A13
      if (e instanceof ObjectStoreError) {
        throw new Errors.Assign.SysProfileDaoCreateFailedError({ uuAppErrorMap }, e);
      }
      throw e;
    }

    // 4.2. - Creates the sysDataStoreStats uuObject in the uuAppObjectStore.
    try {
      await SysDataStoreStats.create(awid);
    } catch (e) {
      throw new Errors.Assign.SysUuAppWorkspaceDataStoreStatsDaoCreateFailedError({ uuAppErrorMap }, e);
    }

    // HDS 4.3. - Initializes a new key pair using AppComponent method AppClientToken.initKeys
    await SysAppClientTokenAbl.initKeys(awid); // A16

    // HDS 5. - If the application is started in production mode, the OIDC client is initialized using the uuCmd oidc/initOidcClient
    await OidcClientHelper.initOidcClient(awid, uuAppErrorMap, this.logger, dtoIn.uuAwidEeCredentialsInitToken); // A17

    // HDS 6. - Returns properly filled out dtoOut.
    return {
      ...appWorkspace,
      ...{ uuAppErrorMap },
    };
  }

  /**
   * Sets available uuAppWorkspace to "assigned" state.
   * @param awid workspace identifier
   * @param dtoIn
   * @returns {Promise<*&{uuAppErrorMap: *}>}
   */
  async setAssignedSysState(awid, dtoIn) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceSetAssignedSysStateDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetAssignedSysState.UC_CODE}unsupportedKeys`,
      Errors.SetAssignedSysState.InvalidDtoIn
    );
    // A1, A2

    // HDS 2. - Loads uuAppWorkspace to be assigned.
    // HDS 2.A - awid is specified in dtoIn
    let lock = new Lock(this.LOCK_CODE, this.LOCK_DURATION);

    let appWorkspace = await this.dao.getByAwid(awid);
    if (!appWorkspace) {
      throw new Errors.SetAssignedSysState.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
    }
    if (appWorkspace) {
      if (appWorkspace.sysState === this.SYS_STATES.ASSIGNED) {
        // A8
        throw new Errors.SetAssignedSysState.sysUuAppWorkspaceAlreadyAssigned({ uuAppErrorMap }, { awid });
      } else if (appWorkspace.awidLicenseOwnerList) {
        throw new Errors.SetAssignedSysState.sysUuAppWorkspaceNotAvailable({ uuAppErrorMap });
      }
      await this.dao.lockOne(awid, lock);
    }

    // HDS 3. - Updates the uuAppWorkspace object (through DAO method update) with attributes specified in dtoIn and Added Attributes and unlocks it.

    let uuAppWorkspace = {
      ...appWorkspace,
      adviceNote: dtoIn.adviceNote && Object.keys(dtoIn.adviceNote).length > 0 ? dtoIn.adviceNote : appWorkspace.adviceNote,
      sysState: this.SYS_STATES.ASSIGNED,
    };

    try {
      appWorkspace = await this.dao.update(uuAppWorkspace, lock);
    } catch (e) {
      if (e instanceof ObjectStoreError) {
        throw new Errors.SetAssignedSysState.SysUuAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, e);
      }
      throw e;
    } finally {
      appWorkspace = await this.dao.unlockOne(appWorkspace.awid, lock);
    }

    this._updateCache(appWorkspace);

    return {
      ...appWorkspace,
      ...{ uuAppErrorMap },
    };
  }

  /**
   * Sets available uuAppWorkspace to "created" state.
   * @param awid workspace identifier
   * @returns {Promise<*&{uuAppErrorMap: *}>}
   */
  async setCreatedSysState(awid) {
    let uuAppErrorMap = {};
    // HDS 1. - Loads uuAppWorkspace to be created.
    // HDS 1.A - awid is specified in dtoIn
    let lock = new Lock(this.LOCK_CODE, this.LOCK_DURATION);

    let appWorkspace = await this.dao.getByAwid(awid);
    if (!appWorkspace) {
      throw new Errors.SetCreatedSysState.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
    }
    if (appWorkspace) {
      if (appWorkspace.sysState === this.SYS_STATES.CREATED) {
        // A8
        throw new Errors.SetCreatedSysState.sysUuAppWorkspaceAlreadyCreated({ uuAppErrorMap }, {awid});
      }
      await this.dao.lockOne(awid, lock);
    }

    // HDS 3. - Updates the uuAppWorkspace object (through DAO method update) and Added Attributes and unlocks it.

    let uuAppWorkspace = {
      ...appWorkspace,
      sysState: this.SYS_STATES.CREATED,
    };

    try {
      appWorkspace = await this.dao.update(uuAppWorkspace, lock);
    } catch (e) {
      if (e instanceof ObjectStoreError) {
        throw new Errors.SetCreatedSysState.SysUuAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, e);
      }
      throw e;
    } finally {
      appWorkspace = await this.dao.unlockOne(appWorkspace.awid, lock);
    }

    this._updateCache(appWorkspace);

    return {
      ...appWorkspace,
      ...{ uuAppErrorMap },
    };
  }

  /**
   * updates available uuAppWorkspace with awidInitiatorList.
   * @param {Object} dtoIn
   * @param {Object} uuIdentity
   * @returns {Promise<{}>}
   */
  async reassign({ dtoIn, uuIdentity }) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceReassignDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Reassign.UC_CODE}unsupportedKeys`,
      Errors.Reassign.InvalidDtoInError
    );
    // A1, A2

    // HDS 2. - Loads uuAppWorkspace to be assigned.

    // HDS 2.A - awid is specified in dtoIn
    let awid = dtoIn.awid;

    let lock = new Lock(this.LOCK_CODE, this.LOCK_DURATION);

    let appWorkspace = await this.dao.getByAwid(awid);

    if (!appWorkspace) {
      throw new Errors.Reassign.sysUuAppWorkspaceNotCreated({ uuAppErrorMap }, { awid });
    }

    if (appWorkspace.sysState !== this.SYS_STATES.ASSIGNED) {
      // A8
      throw new Errors.Reassign.AwidNotInProperState({ uuAppErrorMap }, { awid });
    }

    await this.dao.lockOne(awid, lock);

    // HDS 3. - Updates the uuAppWorkspace object (through DAO method update) with attributes specified in dtoIn and Added Attributes and unlocks it.
    if (dtoIn.adviceNote) {
      dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);
    }

    let uuAppWorkspace = {
      ...appWorkspace,
      ...dtoIn,
    };

    try {
      appWorkspace = await this.dao.update(uuAppWorkspace, lock);
    } catch (e) {
      if (e instanceof ObjectStoreError) {
        throw new Errors.Reassign.SysUuAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, e);
      }
      throw e;
    } finally {
      appWorkspace = await this.dao.unlockOne(appWorkspace.awid, lock);
    }

    // HDS 6. - Returns properly filled out dtoOut.
    return {
      ...appWorkspace,
      ...{ uuAppErrorMap },
    };
  }

  /**
   * unassign available uuAppWorkspace with selected licence to awidLicenceOwners and sets it to "assigned" state.
   * @param {Object} dtoIn
   * @param {Object} uuIdentity
   * @returns {Promise<{}>}
   */
  async unassign({ dtoIn, uuIdentity }) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceUnassignDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Unassign.UC_CODE}unsupportedKeys`,
      Errors.Unassign.InvalidDtoInError
    );
    // A1, A2

    // HDS 2. - Loads uuAppWorkspace to be assigned.
    // HDS 2.A - awid is specified in dtoIn
    let { awid, adviceNote } = dtoIn;

    let lock = new Lock(this.LOCK_CODE, this.LOCK_DURATION);

    let appWorkspace = await this.dao.getByAwid(awid);

    if (!appWorkspace) {
      throw new Errors.Unassign.sysUuAppWorkspaceNotCreated({ uuAppErrorMap }, { awid });
    }

    if (appWorkspace.sysState !== this.SYS_STATES.ASSIGNED) {
      // A8
      throw new Errors.Unassign.AwidNotInProperState({ uuAppErrorMap }, { awid });
    }

    await this.dao.lockOne(awid, lock);


    // HDS 3. - Updates the uuAppWorkspace object (through DAO method update) with attributes
    // specified in dtoIn and Added Attributes and unlocks it.
    if (adviceNote) {
      dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);
    }

    let uuAppWorkspace = {
      ...appWorkspace,
      ...dtoIn,
      sysState: this.SYS_STATES.CREATED,
      awidInitiatorList: null
    };

    try {
      appWorkspace = await this.dao.update(uuAppWorkspace, lock);
    } catch (e) {
      if (e instanceof ObjectStoreError) {
        throw new Errors.Unassign.SysUuAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, e);
      }
      throw e;
    } finally {
      appWorkspace = await this.dao.unlockOne(appWorkspace.awid, lock);
      this._updateCache(appWorkspace);
    }

    // HDS 4. - System deletes objects on other uuSchemas for given awid.
    // HDS 4.1 - Deletes the SysProfile uuObject for each profile from the profileList defined in profiles.json.
    // (DAO deleteByAwid method)

    try {
      await SysProfile.deleteAllAppProfiles(awid);
    } catch (e) {
      // A13
      if (e instanceof ObjectStoreError) {
        throw new Errors.Unassign.SysProfileDaoDeleteFailed({ uuAppErrorMap }, e);
      }
      throw e;
    }

    // 4.2. - Deletes the sysUuAppDataStoreStats uuObject in the uuAppObjectStore (through DAO deleteByAwid method).
    try {
      await SysDataStoreStats.delete(awid);
    } catch (e) {
      throw new Errors.Unassign.SysUuAppDataStoreStatsDaoDeleteFailed({ uuAppErrorMap }, e);
    }

    // HDS 4.3. - System deletes sysUuAppSecret uuObject in the uuAppObjectStore (through DAO deleteByAwid method).
    try {
      await SysPermission.deleteByAwid(awid);
    } catch (e) {
      throw new Errors.Unassign.SysPermissionDaoDeleteFailed({ uuAppErrorMap }, e);
    }

    // HDS 5. - System deletes sysUuAppSecret uuObject in the uuAppObjectStore (through DAO deleteByAwid method).
    try {
      await SysAppClientTokenAbl.removeKeys(awid); // A16
    } catch (e) {
      throw new Errors.Unassign.SysPermissionDaoDeleteFailed({ uuAppErrorMap }, e);
    }

    // HDS 6. - Returns properly filled out dtoOut.
    return {
      ...appWorkspace,
      ...{ uuAppErrorMap },
    };
  }

  /**
   * return licenseOwner information
   * @param {String} awid
   * @param {Object} uuAppErrorMap
   * @returns {Promise<{}>}
   */
  async getLicenseOwner(awid, uuAppErrorMap = {}) {
    // HDS 1. - Loads sysAppWorkspace from cache. (sysAppWorkspace DAO getByAwid) (A1, A2)
    let appWorkspace;
    try {
      appWorkspace = await this.get(awid, uuAppErrorMap);
    } catch (e) {
      // A2
      throw new Errors.SysGetLicenseOwner.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
    }

    // HDS 2. - Returns properly filled dtoOut.
    let license = {};

    license.awidLicenseOwnerList = appWorkspace["awidLicenseOwnerList"];
    license.uuAppErrorMap = uuAppErrorMap;

    return license;
  }

  /**
   * return workspace information from database
   * @param {uri} uri uri of the application
   * @param {Object} dtoIn
   * @returns {Promise<{}>}
   */

  async delete(uri, dtoIn) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysDeleteAppWorkspaceDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Delete.UC_CODE}unsupportedKeys`,
      Errors.Delete.InvalidDtoInError
    ); // A1, A2

    // HDS 2. - System loads sysAppWorkspace from cache. (A3)
    let awid = dtoIn.awid;
    let sysAppWorkspace;
    try {
      sysAppWorkspace = await this.get(awid); // A3
    } catch (e) {
      if (e instanceof Errors.Get.SysUuAppWorkspaceDoesNotExistError) {
        // A4
        throw new Errors.Delete.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      }
      throw e;
    }

    // HDS 3. - System checks that sysAppWorkspace is in "closed" state. (A5)
    if (sysAppWorkspace.sysState !== this.SYS_STATES.CLOSED) {
      // A5
      throw new Errors.Delete.SysUuAppWorkspaceNotInProperState(
        { uuAppErrorMap },
        { awid, state: sysAppWorkspace.sysState }
      );
    }

    // HDS 4. - System checks that there is no uuBT artifact connected to the sysAppWorkspace
    // - sysAppWorkspace.uuAWSC is empty. (A6)
    if (sysAppWorkspace.uuAWSC) {
      // A6
      throw new Errors.Delete.UuAwscConnectedToTheSysUuAppWorkspace(
        { uuAppErrorMap },
        {
          awid,
          uuAWSC: sysAppWorkspace.uuAWSC,
        }
      );
    }

    // HDS 5. - Gets a list of all uuAppDataStore schemas
    // HDS 6. - System does these steps for each uuAppDataStore schema
    // HDS 6.1. - Gets DAO method according to the schema name.
    for (let [schema, dao] of DaoFactory._daos.entries()) {
      // HDS 6.2. - Creates query and searches for the records according to awid attribute
      let filter = { awid };
      let isBinary = Object.getPrototypeOf(dao.constructor).name === "UuBinaryDao";

      // HDS 6.3 - Based on DAO ancestor the type of schema is determined.
      if (isBinary) {
        // HDS 6.3.2 - uuBinary: gets a list of all uuBinary using DAO find and deletes
        // every uuBinary form that list using DAO deleteOne (including even the locked ones)
        await this._executeDeleteBinary(dao, schema, filter);
      } else {
        // HDS 6.3.1 - uuObject: deletes all records using DAO deleteMany (including even the locked ones)
        await this._executeDeleteMany(dao, schema, filter);
      }
    }

    // HDS 6.3.2 - Deletes keys of uuAppOidcClientKey in sysUuAppSecret collection using removeSecret() CMD
    const asid = uri.awid;
    await SysAppSecretStoreAbl.removeSecret(asid, SECRET_SET, `oidcg02|${awid}|Public`);
    await SysAppSecretStoreAbl.removeSecret(asid, SECRET_SET, `oidcg02|${awid}|Private`);
    await SysAppSecretStoreAbl.removeSecret(asid, SECRET_SET, `oidcg02|${awid}|Secret`);

    // HDS 7. - Deletes all uuAppWorkspace cache.
    this.deleteFromCache(awid);

    // HDS 8. - Returns properly filled dtoOut.
    return { uuAppErrorMap };
  }

  async setAuthorizationStrategy(uri, dtoIn, session) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceSetAuthTypeDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetAuthorizationStrategy.UC_CODE}unsupportedKeys`,
      Errors.SetAuthorizationStrategy.InvalidDtoInError
    ); // A1, A2
    // HDS 2. - Checks, if the uuIdentity has rights to run use case sys/uuAppWorkspace/setAuthorizationStrategy
    // in given dtoIn.authorizationStrategy and sets auth data. (A3)
    let appWorkspace = await this.dao.getByAwid(uri.awid);
    if (dtoIn.authorizationStrategy === ROLE_GROUP_INTERFACE) {
      appWorkspace = await AuthorizeHelper.setAuthorizationData(
        Errors.SetAuthorizationStrategy,
        uri,
        dtoIn,
        appWorkspace,
        session,
        uuAppErrorMap,
        true
      );
    } else {
      appWorkspace = await AuthorizeHelper.setAuthorizationData(
        Errors.SetAuthorizationStrategy,
        uri,
        dtoIn,
        appWorkspace,
        session,
        uuAppErrorMap
      );
    }
    // HDS 3. - Sets new sysAppWorkspace.authorizationStrategy to dtoIn.authorizationStrategy value.
    // (sysAppWorkspace DAO update) (A4, A5)
    try {
      appWorkspace = await this.dao.updateByAwid(uri.awid, { ...appWorkspace });
    } catch (e) {
      if (e.cause instanceof ObjectNotFound) {
        // A4
        throw new Errors.SetAuthorizationStrategy.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid: uri.awid });
      } else if (e.cause instanceof ObjectStoreError) {
        // A5
        throw new Errors.SetAuthorizationStrategy.SysUuAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    this._updateCache(appWorkspace);

    appWorkspace.uuAppErrorMap = uuAppErrorMap;

    // HDS 4. - Returns properly filled dtoOut.
    return appWorkspace;
  }

  async connectArtifact(uri, dtoIn, session) {
    // HDS 1.1, 1.2, 1.3
    let validationResult = this.validator.validate("sysConnectArtifactDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.ConnectArtifact.UC_CODE}unsupportedKeys`,
      Errors.ConnectArtifact.InvalidDtoInError
    );
    // HDS 2
    let appWorkspace = await this.dao.getByAwid(uri.awid);
    if (appWorkspace.sysState === this.SYS_STATES.REGISTERED || appWorkspace.sysState === this.SYS_STATES.CLOSED) {
      throw new Errors.ConnectArtifact.UuAppWorkspaceIsNotInProperStateError(
        { uuAppErrorMap },
        { state: appWorkspace.sysState }
      );
    }
    // HDS 3
    uuAppErrorMap = await AuthorizeHelper.connectArtifact(
      Errors.ConnectArtifact,
      uri,
      dtoIn["artifactUri"],
      session,
      dtoIn.synchronizeArtifactBasicAttributes,
      uuAppErrorMap
    );
    // HDS 4
    let workspace = {
      artifactUri: dtoIn["artifactUri"],
      authorizationStrategy: ART_AUTHZ_TYPE,
    };
    try {
      appWorkspace = await this.dao.updateByAwid(uri.awid, workspace);
    } catch (e) {
      throw new Errors.ConnectArtifact.SysUuAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, e);
    }
    this._updateCache(appWorkspace);
    appWorkspace = { ...appWorkspace, ...{ uuAppErrorMap } };
    // HDS 5
    return appWorkspace;
  }

  /**
   * Provides information about an application workspace.
   *
   * @param {String} awid
   * @param {Object} uuAppErrorMap
   * @returns {Promise<*>}
   */
  async get(awid, uuAppErrorMap = {}) {
    // HDS 1. - System loads uuObject sysAppWorkspace from cache
    let sysAppWorkspace = this.sysAppCache.get(awid);

    // HDS 1. A1.1 - If cache doesn't exist, loads uuObject sysAppWorkspace from uuAppObjectStore by sysAppWorkspace DAO getByAwid.
    if (!sysAppWorkspace) {
      sysAppWorkspace = await this.dao.getByAwid(awid);

      if (!sysAppWorkspace) {
        // A2
        throw new Errors.Get.SysUuAppWorkspaceDoesNotExistError({ uuAppErrorMap }, { awid });
      }
      // HDS 1. A1.2 - Adds uuObject to the cache.
      this._updateCache(sysAppWorkspace);
    }

    // HDS 2. - Returns properly filled dtoOut.
    let dtoOut = { ...sysAppWorkspace };
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Set information about an application workspace.
   *
   * @param {String} awid
   * @param {Object} dtoIn
   * @param {String} uuIdentity
   * @returns {Promise<*>}
   */
  async set(awid, dtoIn, uuIdentity) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceSetDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Set.UC_CODE}unsupportedKeys`,
      Errors.Set.InvalidDtoInError
    ); // A1, A2

    // HDS 2. - If there is dtoIn.adviceNote, system also sets adviceNote.uuIdentity to caller uuIdentity and adviceNote.startTime to current time.
    if (dtoIn.adviceNote) {
      dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);
    }

    // HDS 3. - Verified dtoIn is saved to the uuAppObjectStore (sysAppWorkspace DAO update)
    // and uuObject is updated in cache. (A3, A4)
    let dtoOut = {};
    try {
      let sysAppWorkspace = dtoIn;
      sysAppWorkspace.awid = awid;
      dtoOut = await this.dao.update(sysAppWorkspace);
    } catch (e) {
      if (e instanceof ObjectNotFound) {
        // A3
        throw new Errors.Set.SysUuAppWorkspaceDoesNotExistError({ uuAppErrorMap }, { awid });
      } else if (e instanceof ObjectStoreError) {
        // A4
        throw new Errors.Set.SysUuAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    this._updateCache(dtoOut);

    // HDS 4. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   *
   Sets one key of SysAppWorkspace uuObject to given value.
   * @param {string} awid
   * @param {string} key
   * @param {string} value
   * @returns {Promise<*>}
   */

  async setConfigParameter(awid, key, value) {
    const dtoIn = {
      awid,
      key,
    };
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("setConfigWorkspaceParameterDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetConfigParameter.UC_CODE}unsupportedKeys`, // A1 - dtoIn contains keys beyond the scope of dtoInType
      Errors.SetConfigParameter.InvalidDtoIn // A1 - failed dtoIn validation
    );

    // HDS 2. - Updates sysAppWorkspace uuObject in uuAppObjectStore (sysAppWorkspace DAO update) (A2, A3)
    let appWorkspace;
    let uuOject = { awid };
    uuOject[key] = value;
    try {
      appWorkspace = await this.dao.update(uuOject);
    } catch (e) {
      if (e instanceof ObjectNotFound) {
        // A2
        throw new Errors.SetConfigParameter.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      } else if (e instanceof ObjectStoreError) {
        // A3
        throw new Errors.SetConfigParameter.SysUuAppWorkspaceDaoUpdateFailed({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    // Update cache
    this._updateCache(appWorkspace);

    // HDS 3. - Returns properly filled dtoOut.
    appWorkspace.uuAppErrorMap = uuAppErrorMap;
    return appWorkspace;
  }

  /**
   *
   Gets a value of SysAppWorkspace uuObject for given key.
   * @param {string} awid
   * @param {string} key
   * @param {Object} uuAppErrorMap
   * @returns {Promise<*>}
   */

  async getConfigParameter(awid, key, uuAppErrorMap = {}) {
    const dtoIn = {
      awid,
      key: key,
    };
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("getConfigWorkspaceParameterDtoInType", dtoIn);
    ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      Errors.GetConfigParameter.InvalidDtoIn // A1 - failed dtoIn validation
    );

    // HDS 2. - System loads awid from application configuration.
    // HDS 3. - System loads uuObject sysAppInstance from cache. (A2)
    // HDS 4. - System reads value of attribute given in dtoIn.key. (A4)
    let dtoOut = (await this.get(awid))[key]; // A2, A4

    // HDS 5. - Returns properly filled dtoOut.
    return dtoOut === undefined ? null : dtoOut;
  }

  async getUuAppMetamodel(identity) {
    const uuAppErrorMap = {};

    const uuIdentityType = identity.getType();

    // HDS 1. - System checks that caller is systemIdentity
    if (!["uuAsidEe", "uuAwidEe"].includes(uuIdentityType)) {
      // A1
      throw new Errors.GetUuAppMetamodel.InvalidUuIdentityType({ uuAppErrorMap }, { uuIdentity: identity.getUuIdentity(), uuIdentityType });
    }

    // HDS 2. - System gets metamodel zip file from configuration
    const filename = `metamodel_${identity.getUuAppKey().getProduct()}.zip`;
    const root = Config.get("server_root") || process.cwd();
    const metamodelPath = Finder.findConfigInProject(root, `{app,src,}/config/${filename}`) || path.join(root, "app", "config", filename);
    if (!fs.existsSync(metamodelPath)) {
      // A2
      throw new Errors.GetUuAppMetamodel.UuAppMetamodelNotFound({ uuAppErrorMap });
    }

    // HDS 3. - Returns properly filled dtoOut
    const dtoOut = {
      data: fs.createReadStream(metamodelPath),
      filename: filename,
      contentType: "application/zip",
    }
    return dtoOut;
  }

  /**
   * Sets uuAppWorkspace to the closed state.
   *
   * @param {Object} dtoIn
   * @param {Object} uuAppErrorMap
   * @returns {Promise<*>}
   */
  async close(dtoIn, uuAppErrorMap) {
    // HDS - 1. Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceCloseDtoInType", dtoIn);
    uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Close.UC_CODE}unsupportedKeys`,
      Errors.Close.InvalidDtoIn
    ); // A1, A2

    // HDS 2. System loads sysAppWorkspace from cache.
    let awid = dtoIn.awid;
    let sysAppWorkspace = this.sysAppCache.get(awid);

    // HDS 3. - System checks whether the state of uuAppWorkspace is set to one of active states
    // ("closed") (sysAppWorkspace DAO get)
    if (!sysAppWorkspace) {
      // A3
      sysAppWorkspace = await this.dao.getByAwid(awid);
      if (!sysAppWorkspace) {
        // A4
        throw new Errors.Close.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      }
    }

    if (sysAppWorkspace.sysState === this.SYS_STATES.CLOSED) {
      // A5
      throw new Errors.Close.SysUuAppWorkspaceAlreadyClosed({ uuAppErrorMap }, { state: sysAppWorkspace.sysState });
    }

    // HDS 4. - System sets the state of uuAppWorkspace to "closed" (sysAppWorkspace DAO update).
    let dtoOut;
    try {
      sysAppWorkspace.sysState = this.SYS_STATES.CLOSED;
      dtoOut = await this.dao.update(sysAppWorkspace);
    } catch (e) {
      if (e instanceof ObjectStoreError) {
        // A6
        throw new Errors.Close.SysUuAppWorkspaceDaoUpdateFailed(
          { uuAppErrorMap },
          {
            awid,
            state: this.SYS_STATES.CLOSED,
          },
          e
        );
      }
      throw e;
    }

    this._updateCache(dtoOut);

    // HDS 5. - System sets the state of uuAppWorkspace to "closed" in uuBaseRegistry.
    // (using uuBaseRegistry/close interface). (A7)
    // TODO impl. missing uuCMD step

    // HDS 6. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Sets uuAppWorkspace to the suspended state.
   * Can be called only if uuAppWorkspace is in the active state.
   *
   * @param {Object} dtoIn
   * @param {Object} uuAppErrorMap
   * @returns {Promise<*>}
   */
  async suspend(dtoIn, uuAppErrorMap) {
    // HDS - 1. Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceSuspendTypeDtoIn", dtoIn);
    uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Suspend.UC_CODE}unsupportedKeys`,
      Errors.Suspend.InvalidDtoIn
    ); // A1, A2

    // HDS 2. System loads sysAppWorkspace from cache.
    let awid = dtoIn.awid;
    let sysAppWorkspace = this.sysAppCache.get(awid);

    // HDS 3. - System checks whether the state of uuAppWorkspace is set to one of active states
    // ("active", "restricted", "readOnly") (sysAppWorkspace DAO get)
    if (!sysAppWorkspace) {
      // A3
      sysAppWorkspace = await this.dao.getByAwid(awid);
      if (!sysAppWorkspace) {
        // A4
        throw new Errors.Suspend.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      }
    }

    if (
      !(
        sysAppWorkspace.sysState === this.SYS_STATES.ACTIVE ||
        sysAppWorkspace.sysState === this.SYS_STATES.RESTRICTED ||
        sysAppWorkspace.sysState === this.SYS_STATES.READ_ONLY
      )
    ) {
      // A5
      throw new Errors.Suspend.SysUuAppWorkspaceNotInProperState(
        { uuAppErrorMap },
        { state: sysAppWorkspace.sysState }
      );
    }

    // HDS 4. - System sets sysAppWorkspace.previousSysState to current sysAppWorkspace state.
    sysAppWorkspace.previousSysState = sysAppWorkspace.sysState;

    // HDS 5. - System sets the state of uuAppWorkspace to "suspended" (sysAppWorkspace DAO update). (A5)
    let dtoOut;
    try {
      sysAppWorkspace.sysState = this.SYS_STATES.SUSPENDED;
      dtoOut = await this.dao.update(sysAppWorkspace);
    } catch (e) {
      if (e instanceof ObjectStoreError) {
        // A6
        throw new Errors.Suspend.SysUuAppWorkspaceDaoUpdateFailed(
          { uuAppErrorMap },
          {
            awid,
            state: this.SYS_STATES.SUSPENDED,
          }
        );
      }
      throw e;
    }

    this._updateCache(dtoOut);

    // HDS 6. - System sets the state of uuAppWorkspace to "suspended" in uuBaseRegistry. (using uuBaseRegistry/suspend interface). (A6)
    // TODO impl. missing uuCMD step

    // HDS 7. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Sets uuAppWorkspace to the active state.
   * Can be called only if uuAppWorkspace is in the suspended state.
   *
   * @param {Object} dtoIn
   * @param {Object} uuAppErrorMap
   * @returns {Promise<*>}
   */
  async resume(dtoIn, uuAppErrorMap) {
    // HDS - 1. Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceResumeTypeDtoIn", dtoIn);
    uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Resume.UC_CODE}unsupportedKeys`,
      Errors.Resume.InvalidDtoIn
    ); // A1, A2

    // HDS 2. System loads sysAppWorkspace from cache.
    let awid = dtoIn.awid;
    let sysAppWorkspace = this.sysAppCache.get(awid);

    // HDS 3. - System checks whether the state of uuAppWorkspace is set to one of active states
    // ("suspended") (sysAppWorkspace DAO get)
    if (!sysAppWorkspace) {
      // A3
      sysAppWorkspace = await this.dao.getByAwid(awid);
      if (!sysAppWorkspace) {
        // A4
        throw new Errors.Resume.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      }
    }

    if (sysAppWorkspace.sysState !== this.SYS_STATES.SUSPENDED) {
      // A5
      throw new Errors.Resume.sysUuAppWorkspaceNotInSuspendedState(
        { uuAppErrorMap },
        { state: sysAppWorkspace.sysState }
      );
    }

    // HDS 4. - System sets the state of uuAppWorkspace to sysAppWorkspace.previousSysState
    // and deletes this attribute from the uuObject. (A6)
    sysAppWorkspace.sysState = sysAppWorkspace.previousSysState;

    if (!sysAppWorkspace.previousSysState) {
      // A6
      sysAppWorkspace.sysState = this.SYS_STATES.ACTIVE;
    }

    delete sysAppWorkspace.previousSysState;

    // HDS 5. - System sets the state of uuAppWorkspace to "active" (sysAppWorkspace DAO update).
    // and updates cache. (TTL set to 5 minutes) (A7)

    let dtoOut;
    try {
      dtoOut = await this.dao.update(sysAppWorkspace);
    } catch (e) {
      if (e instanceof ObjectStoreError) {
        // A6
        throw new Errors.Suspend.SysUuAppWorkspaceDaoUpdateFailed(
          { uuAppErrorMap },
          {
            awid,
            state: this.SYS_STATES.SUSPENDED,
          },
          e
        );
      }
      throw e;
    }

    this._updateCache(dtoOut);

    // HDS 6. - System sets the state of uuAppWorkspace to "active" in uuBaseRegistry. (using uuBaseRegistry/activate interface). (A8)
    // TODO impl. missing uuCMD step

    // HDS 7. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Allows to set one of the active System States of uuAppWorkspace.
   *
   * @param {String} awid
   * @param {Object} dtoIn
   * @param {String} uuIdentity
   * @returns {Promise<*>}
   */
  async setActiveSysState(awid, dtoIn, uuIdentity) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceSetActiveSysStateDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetActiveSysState.UC_CODE}unsupportedKeys`,
      Errors.SetActiveSysState.InvalidDtoIn
    ); // A1, A2

    // HDS 2. - If there is dtoIn.adviceNote, system also sets adviceNote.uuIdentity to caller uuIdentity and adviceNote.startTime to current time.
    dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);

    // HDS 3. - System sets sysAppWorkspace.sysState to active and updates sysAppWorkspace uuObject (sysAppWorkspace DAO update).
    let dtoOut;
    try {
      let sysAppWorkspace = { ...dtoIn };
      sysAppWorkspace.awid = awid;
      sysAppWorkspace.sysState = this.SYS_STATES.ACTIVE;
      dtoOut = await this.dao.update(sysAppWorkspace);
    } catch (e) {
      if (e instanceof ObjectNotFound) {
        // A3
        throw new Errors.SetActiveSysState.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      } else if (e instanceof ObjectStoreError) {
        // A4
        throw new Errors.SetActiveSysState.SysUuAppWorkspaceDaoUpdateFailed({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    this._updateCache(dtoOut);

    // HDS 4. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Allows to set one of the active System States of uuAppWorkspace.
   *
   * @param {String} awid
   * @param {Object} dtoIn
   * @param {String} uuIdentity
   * @returns {Promise<*>}
   */
  async setRestrictedSysState(awid, dtoIn, uuIdentity) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceSetRestrictedSysStateDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetRestrictedSysState.UC_CODE}unsupportedKeys`,
      Errors.SetRestrictedSysState.InvalidDtoIn
    ); // A1, A2

    // HDS 2. - If there is dtoIn.adviceNote, system also sets adviceNote.uuIdentity to caller uuIdentity
    // and adviceNote.startTime to current time.
    dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);

    // HDS 3. - System sets sysAppWorkspace.sysState to active
    // and updates sysAppWorkspace uuObject (sysAppWorkspace DAO update).
    let dtoOut;
    try {
      let sysAppWorkspace = { ...dtoIn };
      sysAppWorkspace.awid = awid;
      sysAppWorkspace.sysState = this.SYS_STATES.RESTRICTED;
      dtoOut = await this.dao.update(sysAppWorkspace);
    } catch (e) {
      if (e instanceof ObjectNotFound) {
        // A3
        throw new Errors.SetRestrictedSysState.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      } else if (e instanceof ObjectStoreError) {
        // A4
        throw new Errors.SetRestrictedSysState.SysUuAppWorkspaceDaoUpdateFailed({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    this._updateCache(dtoOut);

    // HDS 4. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Allows to set one of the active System States of uuAppWorkspace.
   *
   * @param {String} awid
   * @param {Object} dtoIn
   * @param {String} uuIdentity
   * @returns {Promise<*>}
   */
  async setReadOnlySysState(awid, dtoIn, uuIdentity) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceSetReadOnlySysStateDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetReadOnlySysState.UC_CODE}unsupportedKeys`,
      Errors.SetReadOnlySysState.InvalidDtoIn
    ); // A1, A2

    // HDS 2. - If there is dtoIn.adviceNote, system also sets adviceNote.uuIdentity to caller uuIdentity and adviceNote.startTime to current time.
    dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);

    // HDS 3. - System sets sysAppWorkspace.sysState to readOnly and updates sysAppWorkspace uuObject (sysAppWorkspace DAO update)
    let dtoOut;
    try {
      let sysAppWorkspace = { ...dtoIn };
      sysAppWorkspace.awid = awid;
      sysAppWorkspace.sysState = this.SYS_STATES.READ_ONLY;
      dtoOut = await this.dao.update(sysAppWorkspace);
    } catch (e) {
      if (e instanceof ObjectNotFound) {
        // A3
        throw new Errors.SetReadOnlySysState.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      } else if (e instanceof ObjectStoreError) {
        // A4
        throw new Errors.SetReadOnlySysState.SysUuAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    this._updateCache(dtoOut);

    // HDS 4. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * List information about uuAppWorkspaces provided in dtoIn. If dtoIn is empty,
   * command returns every uuAppWorkspace stored in uuAppObjectStore.
   *
   * @param {Object} dtoIn
   * @param {Object} uuAppErrorMap
   * @returns {Promise<*>}
   */
  async list(dtoIn, uuAppErrorMap) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceListDtoInType", dtoIn);
    uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.List.UC_CODE}unsupportedKeys`,
      Errors.List.InvalidDtoIn
    ); // A1, A2

    // HDS 2. - Loads each sysAppWorkspace uuObject (sysAppWorkspace DAO listByStateAndAwidList) from the uuAppObjectStore
    // that corresponds to dtoIn.awidList. In case dtoIn.awidList is empty, system loads every sysAppWorkspace from uuAppObjectStore.
    let list = await this.dao.listByStateListAndAwidList(dtoIn.sysStateList, dtoIn.awidList, dtoIn.pageInfo);

    // HDS 3. - Returns properly filled out dtoOut.
    list.uuAppErrorMap = uuAppErrorMap;
    return list;
  }

  /**
   * Loads information about system uuAppWorkspace data and data of uuBT which
   * the uuAppWorkspace is connected to (for authenticated users).
   *
   * @param {uri} uri uri of the application
   * @param {Object} session authentication session
   * @param {Object} uuAppErrorMap
   * @returns {Promise<Object>} object containing sysData, uuAppErrorMap and possibly territoryData
   */
  async load(uri, session, uuAppErrorMap) {
    const awid = uri.getAwid();
    const dtoOut = {};

    // HDS 1
    const asid = Config.get("asid");
    const asidData = await SysAppInstance.getByAsid(asid);

    // HDS 2
    const awidData = await this.get(awid);

    // HDS 3
    const relatedObjectsMap = {
      uuAppUuFlsBaseUri: Config.get("fls_base_uri"),
      uuAppUuSlsBaseUri: Config.get("sls_base_uri"),
      uuAppBusinessModelUri: Config.get("business_model_uri"),
      uuAppApplicationModelUri: Config.get("application_model_uri"),
      uuAppBusinessRequestsUri: Config.get("business_request_uri"),
      uuAppUserGuideUri: Config.get("user_guide_uri"),
      uuAppWebKitUri: Config.get("web_uri"),
      uuAppProductPortalUri: Config.get("product_portal_uri"),
    };

    // HDS 4
    const cmdUri = UriBuilder.parse(uri).setUseCase("sys/uuAppWorkspace/load").clearParameters();
    const WorkspaceAuthorizationService = require("../workspace-authorization-service.js"); // to avoid circular dependency
    const authorizationResult = await WorkspaceAuthorizationService.authorize(session, cmdUri.toUri());

    const profileData = {
      uuIdentityProfileList: authorizationResult.getUuIdentityProfileList(),
      profileList: authorizationResult.getProfileList(),
    };

    // HDS 5
    dtoOut.sysData = { asidData, awidData, relatedObjectsMap, profileData };

    // HDS 6, 6.A
    if (awidData.sysState !== "created") {
      // HDS 6.A.1
      let artifactUri;
      if (awidData.authorizationStrategy === "artifact") {
        const { uuTerritoryBaseUri, artifactId, artifactCode } = (awidData.authorizationData || {}).artifact || {};
        if (uuTerritoryBaseUri) {
          artifactUri = UriBuilder.parse(uuTerritoryBaseUri)
            .setParameters({ id: artifactId, code: artifactCode })
            .toString();
        } else {
          artifactUri = awidData.artifactUri;
        }
      } else if (awidData.authorizationStrategy === "boundArtifact") {
        const { uuTerritoryBaseUri, boundArtifactId, boundArtifactCode } =
          (awidData.authorizationData || {}).boundArtifact || {};
        if (uuTerritoryBaseUri) {
          artifactUri = UriBuilder.parse(uuTerritoryBaseUri)
            .setParameters({ id: boundArtifactId, code: boundArtifactCode })
            .toString();
        } else {
          artifactUri = awidData.artifactUri;
        }
      }

      if (artifactUri) {
        const parsedArtifactUri = UriBuilder.parse(artifactUri);
        const { id, code } = parsedArtifactUri.getParameters();
        const loadUri = parsedArtifactUri.setUseCase("uuArtifactIfc/loadData").clearParameters().toUri();
        const loadDtoIn = { id, code, loadContextNavigation: true, loadVisualIdentification: true };
        let territoryData;
        try {
          territoryData = await AppClient.get(loadUri, loadDtoIn, { session });
        } catch (e) {
          // HDS 6.A.1.1
          throw new Errors.Load.TerritoryDataLoadFailed({ uuAppErrorMap }, { loadUri, loadDtoIn }, e);
        }
        dtoOut.territoryData = territoryData;
      }
    }

    // HDS 7
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Loads information about system uuAppWorkspace data and data of uuBT which
   * the uuAppWorkspace is connected to (for unauthenticated users).
   *
   * @param {uri} uri uri of the application
   * @param {Object} session authentication session
   * @param {Object} uuAppErrorMap
   * @returns {Promise<Object>} object containing sysData, uuAppErrorMap and possibly territoryData
   */
  async loadBasicData(uri, session, uuAppErrorMap) {
    const awid = uri.getAwid();
    const dtoOut = {};

    // HDS 1
    const relatedObjectsMap = {
      uuAppUuFlsBaseUri: Config.get("fls_base_uri"),
      uuAppUuSlsBaseUri: Config.get("sls_base_uri"),
      uuAppBusinessModelUri: Config.get("business_model_uri"),
      uuAppApplicationModelUri: Config.get("application_model_uri"),
      uuAppBusinessRequestsUri: Config.get("business_request_uri"),
      uuAppUserGuideUri: Config.get("user_guide_uri"),
      uuAppWebKitUri: Config.get("web_uri"),
      uuAppProductPortalUri: Config.get("product_portal_uri"),
    };
    dtoOut.sysData = { relatedObjectsMap };

    // HDS 2, 2.A
    const awidData = await this.get(awid);
    if (awidData.sysState !== "created") {
      // HDS 2.A.1
      let artifactUri;
      if (awidData.authorizationStrategy === "artifact") {
        const { uuTerritoryBaseUri, artifactId, artifactCode } = (awidData.authorizationData || {}).artifact || {};
        if (uuTerritoryBaseUri) {
          artifactUri = UriBuilder.parse(uuTerritoryBaseUri)
            .setParameters({ id: artifactId, code: artifactCode })
            .toString();
        } else {
          artifactUri = awidData.artifactUri;
        }
      } else if (awidData.authorizationStrategy === "boundArtifact") {
        const { uuTerritoryBaseUri, boundArtifactId, boundArtifactCode } =
          (awidData.authorizationData || {}).boundArtifact || {};
        if (uuTerritoryBaseUri) {
          artifactUri = UriBuilder.parse(uuTerritoryBaseUri)
            .setParameters({ id: boundArtifactId, code: boundArtifactCode })
            .toString();
        } else {
          artifactUri = awidData.artifactUri;
        }
      }

      if (artifactUri) {
        const parsedArtifactUri = UriBuilder.parse(artifactUri);
        const { id, code } = parsedArtifactUri.getParameters();
        const loadUri = parsedArtifactUri.setUseCase("loadArtifactVisualIdentification").clearParameters().toUri();
        const loadDtoIn = { artifactId: id, artifactCode: code };
        let visualIdentificationDtoOut;
        try {
          visualIdentificationDtoOut = await AppClient.get(loadUri, loadDtoIn);
        } catch (e) {
          // HDS 2.A.1.1
          throw new Errors.LoadBasicData.TerritoryDataLoadFailed({ uuAppErrorMap }, { loadUri, loadDtoIn }, e);
        }
        const uuTerritoryBaseUri = parsedArtifactUri.setUseCase("").clearParameters().toUri();
        dtoOut.territoryData = {
          data: {
            visualIdentification: visualIdentificationDtoOut.value,
            artifact: { id: visualIdentificationDtoOut.artifact },
            context: { territory: { uuTerritoryBaseUri } },
          },
        };
      }
    }

    // HDS 3
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * update appWorkspace in the cache.
   *
   * @param {Object} appWorkspace
   */
  _updateCache(appWorkspace) {
    if (![this.SYS_STATES.REGISTERED, this.SYS_STATES.CREATED, this.SYS_STATES.ASSIGNED].includes(appWorkspace.sysState)) {
      this.sysAppCache.set(appWorkspace.awid, appWorkspace);
    }
  }

  /**
   * reset whole cache
   */
  clearCache() {
    this.sysAppCache.clear();
  }

  /**
   * deletes item from cache
   */
  deleteFromCache(item) {
    this.sysAppCache.delete(item);
  }

  /**
   * check for NoaLimit and store workspace to the database
   * @param {Object} uuObject
   * @param {Object} lock
   * @returns {Promise<*>}
   */
  async createUuObject(uuObject, lock) {
    await this._checkNoa();
    return await this.dao.create(uuObject, lock);
  }

  /**
   * delete workspace by awid and reset the cache
   * @param {String} awid
   * @returns {Promise<*>}
   */
  async deleteAppWorkspace(awid) {
    this.clearCache();
    return await this.dao.deleteByAwid(awid);
  }

  /**
   * Internal command for retrieving workspaces not in given state but with given awids.
   *
   * @param excludedStateList {Array}
   * @param awidList {Array} - when falsy, list all awids
   * @returns {Array}
   */
  async listByExcludedStateListAndAwidList(excludedStateList, awidList) {
    let appWorkspaces = [];
    let pageIndex = 0;
    let loadedWorkspaces;

    do {
      loadedWorkspaces = await this.dao.listByExcludedStateListAndAwidList(excludedStateList, awidList, {
        pageIndex,
      });
      appWorkspaces = appWorkspaces.concat(loadedWorkspaces.itemList);
      pageIndex += 1;
    } while (loadedWorkspaces && appWorkspaces.length < loadedWorkspaces.pageInfo.total);

    return appWorkspaces;
  }

  /**
   * check for Noa limit
   * @returns {Promise<void>}
   * @private
   */
  async _checkNoa() {
    let maxNoa = DaoFactory.getMaxNoa() || DEFAULT_MAX_NOA;
    let awidsCount = await this.dao.getCount();

    if (awidsCount >= maxNoa) {
      throw new Errors.MaximumNumberAwidsError(maxNoa);
    }
  }

  async _executeDeleteMany(dao, schema, filter) {
    // to avoid circular dependency
    const SysDumpRestoreAbl = require("./sys-dump-restore-abl");
    let dumbDao = SysDumpRestoreAbl._getDumpDao(dao, schema);
    await dumbDao.deleteMany(filter);
  }

  async _executeDeleteBinary(dao, schema, filter) {
    // to avoid circular dependency
    const SysDumpRestoreAbl = require("./sys-dump-restore-abl");
    let dumbDao = SysDumpRestoreAbl._getDumpDao(dao, schema);
    await dumbDao.deleteBinary(filter, schema);
  }
}

module.exports = new SysAppWorkspaceAbl();
