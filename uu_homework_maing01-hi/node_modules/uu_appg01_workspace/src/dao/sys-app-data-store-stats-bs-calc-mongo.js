const { DbConnection } = require("uu_appg01_datastore");
const { LoggerFactory } = require("uu_appg01_core-logging");

class SysAppDataStoreStatsBsCalcMongo {

  constructor(connectionString) {
    this.logger = LoggerFactory.get("uuapp.workspace.SysAppDataStoreStatsBsCalcMongo");
    connectionString += connectionString.includes("?") ? "&" : "?";
    connectionString += "readPreference=secondaryPreferred";
    this.connectionString = connectionString;
    DbConnection.init(connectionString);
  }

  async calculate(awid, collectionName) {
    let db = await DbConnection.get(this.connectionString);
    let agggregateCalcSupported = await this._isAggregateCalculationSupported(db);

    let objectStats;

    if (agggregateCalcSupported) {
      this.logger.debug(`Calculating statistics via aggregation (${awid}, ${collectionName})`);

      let aggregation = [
        {$match: { awid: awid }},
        { $group: { _id: { awid: "$awid" }, count: { $sum: 1 }, dataSize: { $sum: { $bsonSize: "$$ROOT" } }, fileIds: { $push: "$fileId" } } },
        { $project: { _id: 0, count: 1, dataSize: 1, fileIds: 1 } }
      ];

      objectStats = await db.collection(collectionName).aggregate(aggregation).next();
      if (!objectStats) {
        objectStats = { count: 0, dataSize: 0, fileIds: [] };
      }

    } else {
      this.logger.debug(`Calculating statistics via map reduce (${awid}, ${collectionName})`);

      let collectionInfo = await db.collection(collectionName).mapReduce(
        "function () {" +
          "emit(0, {" +
          "count: 1," +
          "dataSize: Object.bsonsize(this)," +
          "fileIds: [this.fileId]" +
          "});" +
          "}",
        "function (_, infos) {" +
          "var count = 0;" +
          "var dataSize = 0;" +
          "var fileIds = [];" +
          "infos.forEach(function (info) {" +
          "count += info.count;" +
          "dataSize += info.dataSize;" +
          "fileIds.push.apply(fileIds, info.fileIds);" +
          "});" +
          "return {" +
          "count: count," +
          "dataSize: dataSize," +
          "fileIds: fileIds" +
          "};" +
          "}",
        { out: { inline: 1 }, query: { awid } }
      );

      if (!collectionInfo[0]) {
        objectStats = { count: 0, dataSize: 0, fileIds: [] };
      } else {
        objectStats = collectionInfo[0].value;
      }

    }

    if (objectStats["count"] > 0) {
      let collStats;
      collStats = await db.command({ "collStats": collectionName });

      let totalIndexSize = collStats["totalIndexSize"];
      let totalCount = collStats["count"];
      objectStats.indexSize = (totalIndexSize / totalCount) * objectStats.count;

      let match = { _id: { $in: objectStats["fileIds"] } };
      let group = { _id: 0, size: { $sum: "$length" } };

      let res;

      res = await db
        .collection(`${collectionName}.files`)
        .aggregate([{ $match: match }, { $group: group }])
        .toArray();
      objectStats.dataSize += res[0]["size"];

      objectStats.size = objectStats.dataSize + objectStats.indexSize;
    } else {
      objectStats.size = objectStats.indexSize = 0;
    }

    delete objectStats.fileIds;

    return objectStats;
  }

  async getStats() {
    let db = await DbConnection.get(this.connectionString);
    return db.stats();
  }

  async _isAggregateCalculationSupported(db) {
    try {
      let buildInfo = await db.command({ "buildInfo": 1 });
      let majorVersion = buildInfo.version.split(".")[0];
      return Number(majorVersion) >= 5;
    } catch (e) {
      this.logger.warn("Failed to evaluate DB version for stat calculation.", e);
      return false;
    }
  }

}

module.exports = SysAppDataStoreStatsBsCalcMongo;
