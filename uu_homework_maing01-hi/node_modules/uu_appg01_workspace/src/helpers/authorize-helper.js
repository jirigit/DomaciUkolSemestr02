"use strict";
const { AppClient } = require("uu_appg01_core-appclient");
const { AuthorizationService } = require("uu_appg01_core-authorization");
const { ValidationHelper } = require("uu_appg01_core-appserver");
const { Validator } = require("uu_appg01_core-validation");
const { UriBuilder } = require("uu_appg01_core-uri");
const AppClientTokenErrors = require("../api/errors/sys-app-client-token-errors");
const AppClientTokenService = require("../app-client-token-service");
const SysProfile = require("../abl/sys-profile-abl.js");

const DEFAULT_SERVICE_NAME = "uu_appg01_workspace";
const ROLE_GROUP_INTERFACE = "roleGroupInterface";

class AuthorizeHelper {
  constructor() {
    this.validator = Validator.load();
  }

  /**
   * Checks if the user has rights to run specific uri according to set authorization strategy
   * @param error
   * @param uri
   * @param dtoIn
   * @param session
   * @param uuAppErrorMap
   * @returns {Promise<void>}
   */
  async checkAuthz(error, { uri = null, dtoIn = {}, session = null, uuAppErrorMap = {} }) {
    let authzError;
    let authzResult;
    try {
      let authzSvc = AuthorizationService.get(DEFAULT_SERVICE_NAME);
      authzResult = await authzSvc.authorize(session, uri, dtoIn);
    } catch (e) {
      authzError = e;
    }

    if (authzError || !authzResult.isAuthorized()) {
      if (!authzError && authzResult.getAuthorizationError()) {
        authzError = authzResult.getAuthorizationError();
        if (authzError.code && authzError.code.endsWith("artifactDoesNotExist")) {
          throw new error.ArtifactDoesNotExist(
            { uuAppErrorMap },
            {
              artifact: authzError.paramMap.artifact,
              uuIdentity: session.getIdentity().getUuIdentity(),
              authorizationStrategy: dtoIn["authorizationStrategy"],
            }
          );
        } else if (authzError.code && authzError.code.endsWith("accessDenied")) {
          throw new error.ArtifactAccessDenied(
            { uuAppErrorMap },
            {
              artifact: authzError.paramMap.artifact,
              artifactTypeCode: authzError.paramMap.artifactTypeCode,
              uuIdentity: session.getIdentity().getUuIdentity(),
              authorizationStrategy: dtoIn["authorizationStrategy"],
            }
          );
        }
      }
      throw new error.UserIsNotAuthorizedToChangeAuthorizationStrategy(
        { uuAppErrorMap },
        {
          uuIdentity: session.getIdentity().getUuIdentity(),
          authorizationStrategy: dtoIn["authorizationStrategy"],
        },
        authzError
      );
    }
  }

  /**
   * Gets authorization data for specific authorization strategy
   *
   * @param error
   * @param uri
   * @param dtoIn
   * @param session
   * @param uuAppErrorMap
   * @returns {Promise<{uuAppErrorMap: {}, authData: {authorizationStrategy}}>}
   */
  async getAuthorizationData(error, uri, dtoIn, session, uuAppErrorMap = {}) {
    let authData = { authorizationStrategy: dtoIn.authorizationStrategy };
    let artifactUri = null;
    switch (authData.authorizationStrategy) {
      case "uuIdentityList":
        authData = { ...authData, permissionMap: dtoIn.permissionMap };
        uuAppErrorMap = this._validateSetAuthorizationDataType(
          error,
          authData,
          "sysSetAuthStrategyUuIdentityListDtoInType",
          uuAppErrorMap
        );
        break;
      case "roleGroupInterface":
        authData = { ...authData, roleGroupUriMap: dtoIn.roleGroupUriMap };
        uuAppErrorMap = this._validateSetAuthorizationDataType(
          error,
          authData,
          "sysSetAuthStrategyRoleGroupInterfaceDtoInType",
          uuAppErrorMap
        );
        break;
      case "boundArtifact":
        authData = {
          ...authData,
          uuTerritoryBaseUri: dtoIn.uuTerritoryBaseUri,
          boundArtifactProfileMap: dtoIn.boundArtifactProfileMap,
        };
        dtoIn.boundArtifactId
          ? (authData.boundArtifactId = dtoIn.boundArtifactId)
          : (authData.boundArtifactCode = dtoIn.boundArtifactCode);
        uuAppErrorMap = this._validateSetAuthorizationDataType(
          error,
          authData,
          "sysSetAuthStrategyBoundArtifactDtoInType",
          uuAppErrorMap
        );
        break;
      case "artifact":
        authData = {
          ...authData,
          uuTerritoryBaseUri: dtoIn.uuTerritoryBaseUri,
          artifactId: dtoIn.artifactId,
          artifactCode: dtoIn.artifactCode,
          synchronizeArtifactBasicAttributes: dtoIn.synchronizeArtifactBasicAttributes
            ? dtoIn.synchronizeArtifactBasicAttributes
            : false,
        };
        dtoIn.artifactId ? (authData.artifactId = dtoIn.artifactId) : (authData.artifactCode = dtoIn.artifactCode);
        uuAppErrorMap = this._validateSetAuthorizationDataType(
          error,
          authData,
          "sysSetAuthStrategyArtifactDtoInType",
          uuAppErrorMap
        );
        artifactUri = this._buildArtifactUri(authData.uuTerritoryBaseUri, authData.artifactId, authData.artifactCode);
        uuAppErrorMap = await this.connectArtifact(
          error,
          uri,
          artifactUri,
          session,
          authData.synchronizeArtifactBasicAttributes,
          uuAppErrorMap
        );
        break;
    }
    return { authData, uuAppErrorMap };
  }

  /**
   * Sets authorization data to entity
   *
   * @param error
   * @param ucUri
   * @param dtoIn
   * @param entity object
   * @param session
   * @param uuAppErrorMap
   * @param updateProfiles
   * @returns {Promise<{authorizationData}|*>}
   */
  async setAuthorizationData(error, ucUri, dtoIn, entity, session, uuAppErrorMap = {}, updateProfiles = false) {
    let authResult = await this.getAuthorizationData(error, ucUri, dtoIn, session, uuAppErrorMap);
    let authData = authResult.authData;
    uuAppErrorMap = authResult.uuAppErrorMap;
    await this.checkAuthz(error, { uri: ucUri, dtoIn: authData, session, uuAppErrorMap });
    if (!entity) entity = {};
    entity["authorizationStrategy"] = authData.authorizationStrategy;
    if (entity.authorizationStrategy === ROLE_GROUP_INTERFACE) {
      updateProfiles &&
        (await SysProfile.updateProfilesBasedOnRoleGroupUriMap(
          ucUri.awid,
          dtoIn.roleGroupUriMap,
          uuAppErrorMap,
          error.UC_CODE
        ));
    } else {
      delete authData.authorizationStrategy;
      entity.authorizationData
        ? (entity.authorizationData[entity["authorizationStrategy"]] = { ...authData })
        : (entity.authorizationData = { [entity["authorizationStrategy"]]: { ...authData } });
    }
    return entity;
  }

  /**
   * Connects the uuBT artifact
   *
   * @param ErrorClass
   * @param uri
   * @param artifactUri
   * @param session
   * @param syncArtifactBasicAttributes
   * @param uuAppErrorMap
   * @returns {Promise<{}>}
   */
  async connectArtifact(
    ErrorClass,
    uri,
    artifactUri,
    session,
    syncArtifactBasicAttributes = false,
    uuAppErrorMap = {}
  ) {
    // HDS
    let callUriBuilder = UriBuilder.parse(artifactUri);
    callUriBuilder.setUseCase("uuAwsc/connectAppWorkspace");
    const callUri = callUriBuilder.toUri();

    let appClientToken;
    try {
      appClientToken = await AppClientTokenService.createToken(uri, callUri);
    } catch (e) {
      if (e instanceof AppClientTokenErrors.GetPrivateKey.KeysNotInitialized) {
        throw new ErrorClass.TokenCreateFailed({ uuAppErrorMap }, e);
      }
      throw e;
    }

    // HDS
    let parameters = {
      id: callUri.getParameters().id,
      code: callUri.getParameters().code,
      uuAppWorkspaceUri: UriBuilder.parse(uri).setUseCase(null).toString(),
      synchronizeArtifactBasicAttributes: syncArtifactBasicAttributes,
    };

    let scope;
    if (typeof session.getCallTokenScope === "function") {
      scope = await session.getCallTokenScope(callUri);
    } else {
      scope = callUri.toString().split("?")[0];
    }
    let headers = {};
    headers["Authorization"] = await session.getCallToken(scope);

    const callOpts = AppClientTokenService.setToken({ headers }, appClientToken);

    try {
      await AppClient.post(callUri, parameters, callOpts);
    } catch (e) {
      if (e.code && e.code.endsWith("artifactDoesNotExist")) {
        throw new ErrorClass.ArtifactDoesNotExist(
          { uuAppErrorMap },
          {
            artifact: e.paramMap.artifact,
            uuIdentity: session.getIdentity().getUuIdentity(),
            authorizationStrategy: "artifact",
          }
        );
      } else {
        throw new ErrorClass.UuCmdConnectAppWorkspaceCallFailedError({ uuAppErrorMap }, e);
      }
    }
    return uuAppErrorMap;
  }

  /**
   * Artifact uri builder
   *
   * @param artifactUri
   * @param id
   * @param code
   * @returns {Uri}
   * @private
   */
  _buildArtifactUri(artifactUri, id, code) {
    const artifactUriBuilder = UriBuilder.parse(artifactUri).clearParameters();
    if (id) {
      artifactUriBuilder.setParameter("id", id);
    } else {
      artifactUriBuilder.setParameter("code", code);
    }
    return artifactUriBuilder.toUri();
  }

  /**
   * Data validation for a specific authorization strategy
   *
   * @param error
   * @param authorizationData
   * @param validationType
   * @param uuAppErrorMap
   * @returns {*|{}}
   * @private
   */
  _validateSetAuthorizationDataType(error, authorizationData, validationType, uuAppErrorMap) {
    let validationResult = this.validator.validate(validationType, authorizationData);
    return ValidationHelper.processValidationResult(
      authorizationData,
      validationResult,
      uuAppErrorMap,
      `${error.UC_CODE}unsupportedKeys`,
      error.InvalidDtoInError
    );
  }
}

module.exports = new AuthorizeHelper();
