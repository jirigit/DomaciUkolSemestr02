"use strict";

const { Config, OptsReader, Mutex, LruCache, Json, Digest } = require("uu_appg01_core-utils");
const { AuthorizationService, AuthorizationError } = require("uu_appg01_core-authorization");
const { UriBuilder } = require("uu_appg01_core-uri");
const { LoggerFactory } = require("uu_appg01_core-logging");
const { AppClient } = require("uu_appg01_server-client");
const { Validator } = require("uu_appg01_core-validation");
const { ValidationHelper } = require("uu_appg01_core-appserver");
const { AuditLog } = require("uu_appg01_auditlog");

let UseCaseContext = null;
try {
  UseCaseContext = require("uu_appg01_core-appserver").UseCaseContext;
} catch (e) {
  UseCaseContext = null;
}

const AppInstanceComponent = require("./api/components/app-instance");
const AppWorkspaceComponent = require("./api/components/app-workspace");
const WorkspaceAuthorizationResult = require("./workspace-authorization-result.js");
const ProfileConfig = require("./helpers/profile-config.js");
const SysPermissionAbl = require("./abl/sys-permission-abl.js");
const SysProfileAbl = require("./abl/sys-profile-abl.js");
const RoleCastService = require("./helpers/role-cast-service.js");
const UuOs8UriHelper = require("./helpers/uu-os8-uri-helper.js");
const WorkspaceAuthorizationErrors = require("./api/errors/authorization-errors.js");

const logger = LoggerFactory.get("WorkspaceAuthorizationService");

const PARAM_ROLE_MANAGEMENT_BASE_URI = "uu_app_workspace_role_management_uri";
const PARAM_USER_PROFILE_CACHE_TTL = "uu_app_workspace_user_profile_cache_ttl";
const PARAM_USER_PROFILE_CACHE_MAX_SIZE = "uu_app_workspace_user_profile_cache_max_size";
const PARAM_USER_PROFILE_NEGATIVE_CACHE_TTL = "uu_app_workspace_user_profile_negative_cache_ttl";

const PARAM_OBJECT_USER_PROFILE_CACHE_TTL = "uu_app_workspace_object_user_profile_cache_ttl";
const PARAM_OBJECT_USER_PROFILE_CACHE_MAX_SIZE = "uu_app_workspace_object_user_profile_cache_max_size";
const PARAM_OBJECT_USER_PROFILE_NEGATIVE_CACHE_TTL = "uu_app_workspace_object_user_profile_negative_cache_ttl";

const PARAM_AUTHORIZATION_TIMEOUT = "uu_app_workspace_authorization_timeout";
const DEFAULT_AUTHORIZATION_TIMEOUT = 5 * 1000;

const PARAM_ROLE_CAST_CACHE_TTL = "uu_app_workspace_role_cast_cache_ttl";

const DEFAULT_SERVICE_NAME = "uu_appg01_workspace";
const DEFAULT_ROLE_MANAGEMENT_BASE_URI = "https://api.plus4u.net";
const DEFAULT_USER_PROFILE_CACHE_TTL = 5 * 60 * 1000;
const DEFAULT_USER_PROFILE_CACHE_MAX_SIZE = 10_000;
const DEFAULT_USER_PROFILE_NEGATIVE_CACHE_TTL = 60 * 1000;
const DEFAULT_OBJECT_USER_PROFILE_CACHE_TTL = 5 * 60 * 1000;
const DEFAULT_OBJECT_USER_PROFILE_CACHE_MAX_SIZE = 10_000;
const DEFAULT_OBJECT_USER_PROFILE_NEGATIVE_CACHE_TTL = 60 * 1000;
const ARTIFACT_AUTHZ_STRATEGY = "artifact";
const BOUND_ARTIFACT_AUTHZ_STRATEGY = "boundArtifact";
const UU_IDENTITY_LIST_AUTHZ_STRATEGY = "uuIdentityList";
const ROLE_GROUP_INTERFACE_AUTHZ_STRATEGY = "roleGroupInterface";
const DEFAULT_AUTHZ_STRATEGY = ROLE_GROUP_INTERFACE_AUTHZ_STRATEGY;

const GGALL = "urn:uu:GGALL";
const GGPLUS4U = "urn:uu:GGPLUS4U";
const ANONYMOUS_USER = "0-0";

const PUBLIC_PROFILE = "Public";
const AUTHENTICATED_PROFILE = "Authenticated";
const CREATED_SYS_STATE = "created";
const ASSIGNED_SYS_STATE = "assigned";
const WORKSPACE_AUTH_TYPE = "workspace";
const OBJECT_AUTH_TYPE = "object";
const SEVERITY = {
  error: "ERROR",
  info: "INFO",
};
const AUTH_PROCESS_FAILED = "UuAppWorkspace authorization process failed.";
const AUTH_PROCESS_COMPLETED = "UuAppWorkspace authorization process completed.";

class WorkspaceAuthorizationService {
  /**
   * Checks whether identity represented by the session is authorized to access resources at given uri. In case identity
   * is not authorized, error is not directly raised, but unauthorized authorization context is returned as result.
   * Logic which is performing authorization is then responsible to raise AccessDenied error in case there is no
   * alternative flow to handle unauthorized access.
   * @param {Session} session Instance of session representing authenticated user
   * @param {uri} uri Address of the use case
   * @param {Object} authorizationData Authorization data may contain additional data for performing the authorization.
   * @param {String} authorizationData.uuAppMetamodelVersion Version of uuAppMetamodel
   * @returns {Promise<AuthorizationResult>} Authorization result
   */
  static async authorize(session, uri, authorizationData) {
    return await AuthorizationService.get(DEFAULT_SERVICE_NAME).authorize(session, uri, authorizationData);
  }

  /**
   * Creates new instance of uuAppWorkspace authorization service and registers it
   * as authorization service with given name.
   * @param {String} name Service name
   * @param {Object|null} options Service options
   */
  static create(name, options = {}) {
    let authService = new WorkspaceAuthorizationService(options);
    AuthorizationService._register(name, authService);
  }

  /**
   * Creates new instance of uuAppWorkspace authorization service.
   * @param options Service options
   * @private
   */
  constructor(options = {}) {
    let opts = new OptsReader(options, Config);
    let userProfileCacheTtl = opts.getNumber(PARAM_USER_PROFILE_CACHE_TTL);
    if (userProfileCacheTtl == null) {
      userProfileCacheTtl = opts.getNumber(PARAM_ROLE_CAST_CACHE_TTL);
      userProfileCacheTtl = userProfileCacheTtl == null ? DEFAULT_USER_PROFILE_CACHE_TTL : userProfileCacheTtl * 1000;
    }
    let userProfileCacheMaxSize = opts.getNumber(
      PARAM_USER_PROFILE_CACHE_MAX_SIZE,
      DEFAULT_USER_PROFILE_CACHE_MAX_SIZE
    );
    this._userProfileNegativeCacheTtl = opts.getNumber(
      PARAM_USER_PROFILE_NEGATIVE_CACHE_TTL,
      DEFAULT_USER_PROFILE_NEGATIVE_CACHE_TTL
    );
    this._userProfileCache = new LruCache({ maxAge: userProfileCacheTtl, maxSize: userProfileCacheMaxSize });

    let objectUserProfileCacheMaxSize = opts.getNumber(
      PARAM_OBJECT_USER_PROFILE_CACHE_MAX_SIZE,
      DEFAULT_OBJECT_USER_PROFILE_CACHE_MAX_SIZE
    );
    let objectUserProfileCacheTtl = opts.getNumber(
      PARAM_OBJECT_USER_PROFILE_CACHE_TTL,
      DEFAULT_OBJECT_USER_PROFILE_CACHE_TTL
    );
    this._objectUserProfileNegativeCacheTtl = opts.getNumber(
      PARAM_OBJECT_USER_PROFILE_NEGATIVE_CACHE_TTL,
      DEFAULT_OBJECT_USER_PROFILE_NEGATIVE_CACHE_TTL
    );
    this._objectUserProfileCache = new LruCache({
      maxAge: objectUserProfileCacheTtl,
      maxSize: objectUserProfileCacheMaxSize,
    });

    this._mutex = new Mutex();
    let uu0S8CastServiceBaseUrl = opts.get(PARAM_ROLE_MANAGEMENT_BASE_URI, DEFAULT_ROLE_MANAGEMENT_BASE_URI);
    this._castService = new RoleCastService(uu0S8CastServiceBaseUrl, 0); // do not use internal cast cache
    this._authTimeout = opts.getNumber(PARAM_AUTHORIZATION_TIMEOUT, DEFAULT_AUTHORIZATION_TIMEOUT) / 1000;
    this._asid = Config.get("asid");
    ProfileConfig.loadProfilesConfig();
    this.validator = Validator.load();
  }

  async authorize(session, uri, authorizationData = {}) {
    if (typeof authorizationData === "string") {
      authorizationData = { authorizationStrategy: authorizationData };
    }
    let authStrategy = authorizationData.authorizationStrategy;
    let identity = session.getIdentity();
    let uuIdentity = (identity ? identity.getUuIdentity() : ANONYMOUS_USER) || ANONYMOUS_USER;
    let awid = uri.getAwid();
    let useCaseName = uri.getUseCase();

    let ucProfiles;
    let allProfiles;
    if (ProfileConfig.isPrivilegedCall(awid)) {
      ucProfiles = ProfileConfig.getPrivilegedUseCaseProfiles(awid, useCaseName);
      allProfiles = ProfileConfig.getPrivilegedProfiles(awid);
    } else {
      ucProfiles = ProfileConfig.getUseCaseProfiles(useCaseName);
      allProfiles = ProfileConfig.getProfiles();
    }

    if (ucProfiles.length === 0) {
      const result = new WorkspaceAuthorizationResult({ uuIdentity, isAuthorized: false, uri });
      await this._sendLogData({ result, authStrategy, ucName: useCaseName, awid }, WORKSPACE_AUTH_TYPE, SEVERITY.info);
      return result;
    }
    if (ucProfiles.length === 1 && ucProfiles.includes(PUBLIC_PROFILE)) {
      const result = new WorkspaceAuthorizationResult({ uuIdentity, isAuthorized: true, uri });
      await this._sendLogData({ result, authStrategy, ucName: useCaseName, awid }, WORKSPACE_AUTH_TYPE, SEVERITY.info);

      return result;
    }

    const isAuthenticated = uuIdentity !== ANONYMOUS_USER;
    if (isAuthenticated && ucProfiles.length === 1 && ucProfiles.includes(AUTHENTICATED_PROFILE)) {
      const result = new WorkspaceAuthorizationResult({ uuIdentity, isAuthorized: true, uri });
      await this._sendLogData({ result, authStrategy, ucName: useCaseName, awid }, WORKSPACE_AUTH_TYPE, SEVERITY.info);
      return result;
    }

    let {
      userProfiles,
      authorizationTime,
      authorizationStrategy: resultAuthorizationStrategy,
      authorizationError,
    } = await this._getUserProfiles(awid, uuIdentity, session, ucProfiles, authorizationData);
    let authorizedProfiles = ucProfiles.filter((profile) => userProfiles.has(profile));

    if (authorizedProfiles.length === 0 && !ucProfiles.includes(PUBLIC_PROFILE)) {
      // check negative authorization cache
      if (Date.now() - authorizationTime > this._userProfileNegativeCacheTtl) {
        let result = await this._getUserProfiles(awid, uuIdentity, session, ucProfiles, authorizationData, false);
        userProfiles = result.userProfiles;
        authorizationError = result.authorizationError;
      } else {
        // In case authorized profiles are empty, try to re-load explicit permissions
        // which are often used to provide immediate temporary access and might not yet
        // be cached
        let result = await this._loadProfilesByPermissions(awid, uuIdentity);
        // Push additional profiles to existing result, so that cached result is updated
        result.userProfiles.forEach((profile) => userProfiles.add(profile));
      }
      authorizedProfiles = ucProfiles.filter((profile) => userProfiles.has(profile));
    }

    let logData = {
      authorizationType: WORKSPACE_AUTH_TYPE,
      authorizationStrategy: resultAuthorizationStrategy,
      authorizedUseCase: useCaseName,

      useCaseProfileList: ucProfiles,
      uuIdentityProfileList: [...userProfiles],
      authorizedProfileList: authorizedProfiles,
    };

    if (authStrategy === ARTIFACT_AUTHZ_STRATEGY) {
      let { awscArtifactUri, artifactId, artifactCode } = this._getArtifactAuthData(awid);
      logData.artifactUri = this._buildArtifactUri(awscArtifactUri, artifactId, artifactCode);
    }
    if (resultAuthorizationStrategy === BOUND_ARTIFACT_AUTHZ_STRATEGY) {
      logData.boundArtifactUri = await this._getBoundArtifactUri(awid, authorizationData);
    }

    await AuditLog.log(SEVERITY.info, "uuApp/authorization", AUTH_PROCESS_COMPLETED, logData);

    let contextData = {
      uuIdentity,
      useCase: useCaseName,
      authorizationStrategy: resultAuthorizationStrategy,
      profileList: allProfiles.filter((p) => ![PUBLIC_PROFILE, AUTHENTICATED_PROFILE].includes(p)),
      authorizedProfileList: authorizedProfiles,
      uuIdentityProfileList: [...userProfiles],
      useCaseProfileList: ucProfiles,
      authorizationError,
      uri
    };
    if (ucProfiles.includes(PUBLIC_PROFILE) || (isAuthenticated && ucProfiles.includes(AUTHENTICATED_PROFILE))) {
      contextData.isAuthorized = true;
    }
    return new WorkspaceAuthorizationResult(contextData);
  }

  async authorizeObject(session, useCase, authorizationData = {}) {
    let awid = null;
    let authStrategy = authorizationData.authorizationStrategy;
    if (UseCaseContext && UseCaseContext.getUri()) {
      awid = this._getUriFromContext().getAwid();
    }
    if (!useCase || !useCase.name) {
      let error = `Unable to authorize object. Use case name must be defined.`;
      await this._sendLogData(
        {
          authStrategy,
          awid,
        },
        OBJECT_AUTH_TYPE,
        SEVERITY.error,
        error
      );
      throw new AuthorizationError(error);
    }

    let result;
    let error;
    switch (authStrategy) {
      case ARTIFACT_AUTHZ_STRATEGY:
        result = await this._authorizeObjectArtifact(session, useCase, authorizationData, awid);
        break;
      case BOUND_ARTIFACT_AUTHZ_STRATEGY:
        result = await this._authorizeObjectBoundArtifact(session, useCase, authorizationData, awid);
        break;
      case ROLE_GROUP_INTERFACE_AUTHZ_STRATEGY:
        result = await this._authorizeObjectRoleGroupInterface(session, useCase, authorizationData, awid);
        break;
      case UU_IDENTITY_LIST_AUTHZ_STRATEGY:
        result = await this._authorizeObjectUuIdentityList(session, useCase, authorizationData, awid);
        break;
      default:
        error = `Object authorization failed. Unknown authorization strategy: ${authStrategy}.`;
        await this._sendLogData({ awid, authStrategy, ucName: useCase.name }, OBJECT_AUTH_TYPE, SEVERITY.error, error);
        throw new AuthorizationError(error);
    }

    await this._sendLogData({ awid, result, authStrategy, ucName: useCase.name }, OBJECT_AUTH_TYPE, SEVERITY.info);
    return result;
  }

  _getUriFromContext() {
    let uri = null;
    if (UseCaseContext && UseCaseContext.getUri()) {
      uri = UseCaseContext.getUri()
    }
    return uri;
  }

  async _authorizeObjectArtifact(session, useCase, authorizationData, awid) {
    let uuAppMetamodelVersion = authorizationData.uuAppMetamodelVersion;
    await this._validateAuthorizationData(authorizationData, "authorizeObjectArtifactType", awid);

    if (!awid || awid === this._asid) {
      let error = `Unable to authorize object. Cannot use artifact authorization out of request scope or within asid request.`;
      await this._sendLogData(
        {
          awid,
          authStrategy: authorizationData.authorizationStrategy,
          ucName: useCase.name,
        },
        OBJECT_AUTH_TYPE,
        SEVERITY.error,
        error
      );
      throw new AuthorizationError(error);
    }
    const uuIdentity = session.getIdentity().getUuIdentity();

    const cacheKey = `${awid}|${uuIdentity}|${authorizationData.artifactId}|${authorizationData.artifactCode}|${useCase.name}`;
    let artifactUri;
    let result = await this._useObjectCacheWrapper(
      cacheKey,
      async () => {
        let { awscArtifactUri = null } = await this._getArtifactAuthData(awid);
        if (!awscArtifactUri) {
          let error = `Unable to authorize object. Cannot use artifact authorization because the current awid (${awid}) is not connected to uuBT.`;
          await this._sendLogData(
            {
              authStrategy: authorizationData.authorizationStrategy,
              ucName: useCase.name,
              awid,
            },
            OBJECT_AUTH_TYPE,
            SEVERITY.error,
            error
          );
          throw new AuthorizationError(error);
        }
        artifactUri = this._buildArtifactUri(
          awscArtifactUri,
          authorizationData.artifactId,
          authorizationData.artifactCode
        );
        return this._loadUserProfilesByArtifact(session, uuIdentity, artifactUri, uuAppMetamodelVersion, useCase.name);
      },
      (r) => r.authorizedAppTypeProfiles.length > 0
    );

    if (!result.resultComplete) {
      let error = `Artifact authorization failed. uuIdentity: ${uuIdentity}, artifactUri=${artifactUri}`;
      let cause = result.error;
      await this._sendLogData(
        { authStrategy: authorizationData.authorizationStrategy, ucName: useCase.name, awid },
        OBJECT_AUTH_TYPE,
        SEVERITY.error,
        error,
        cause
      );
      throw new AuthorizationError(error, cause);
    }

    return new WorkspaceAuthorizationResult({
      uuIdentity,
      useCase: useCase.name,
      objectAuthorizationStrategy: authorizationData.authorizationStrategy,
      authorizedObjectProfileList: result.authorizedAppTypeProfiles,
      uuIdentityObjectProfileList: result.userAppTypeProfiles,
      useCaseObjectProfileList: result.ucAppTypeProfiles,
      uri: this._getUriFromContext(),
    });
  }

  async _authorizeBoundArtifact(session, useCase, authorizationData, awid) {
    if (!useCase.objectProfileList) {
      let error = `Unable to authorize object. Use case profiles must be defined.`;
      await this._sendLogData(
        {
          authStrategy: authorizationData.authorizationStrategy,
          ucName: useCase.name,
          awid,
        },
        OBJECT_AUTH_TYPE,
        SEVERITY.error,
        error
      );
      throw new AuthorizationError(error);
    }
    if (authorizationData.uuTerritoryBaseUri && !(authorizationData.uuTerritoryBaseUri instanceof String)) {
      authorizationData.uuTerritoryBaseUri = authorizationData.uuTerritoryBaseUri.toString();
    }
    await this._validateAuthorizationData(authorizationData, "authorizeObjectBoundArtifactType", awid);

    const uuIdentity = session.getIdentity().getUuIdentity();
    const artifactUri = this._buildArtifactUri(
      authorizationData.uuTerritoryBaseUri,
      authorizationData.boundArtifactId,
      authorizationData.boundArtifactCode
    );

    const cacheKey = `${artifactUri.getAwid()}|${uuIdentity}|${authorizationData.boundArtifactId}|${
      authorizationData.boundArtifactCode
    }`;
    let result = await this._useObjectCacheWrapper(
      cacheKey,
      async () => {
        return this._loadUserProfilesByArtifact(session, uuIdentity, artifactUri);
      },
      (result) => {
        const { authorizedProfiles } = this._evaluateboundArtifactProfileMap(
          result,
          authorizationData.boundArtifactProfileMap,
          useCase.objectProfileList
        );
        return authorizedProfiles && authorizedProfiles.length > 0;
      }
    );

    if (!result.resultComplete) {
      let error = `Bound artifact authorization failed. uuIdentity: ${uuIdentity}, boundArtifactUri=${artifactUri}`;
      let cause = result.error;
      await this._sendLogData(
        {
          authStrategy: authorizationData.authorizationStrategy,
          ucName: useCase.name,
          awid,
        },
        OBJECT_AUTH_TYPE,
        SEVERITY.error,
        error,
        cause
      );
      throw new AuthorizationError(error, cause);
    }

    const { authorizedProfiles, identityProfiles } = this._evaluateboundArtifactProfileMap(
      result,
      authorizationData.boundArtifactProfileMap,
      useCase.objectProfileList
    );

    return {
      uuIdentity,
      authorizedProfiles,
      identityProfiles,
      error: result.error,
      resultComplete: result.resultComplete,
    };
  }

  async _authorizeObjectBoundArtifact(session, useCase = {}, authorizationData = {}) {
    let { uuIdentity, authorizedProfiles, identityProfiles } = await this._authorizeBoundArtifact(
      session,
      useCase,
      authorizationData
    );

    return new WorkspaceAuthorizationResult({
      uuIdentity,
      useCase: useCase.name,
      objectAuthorizationStrategy: authorizationData.authorizationStrategy,
      authorizedObjectProfileList: authorizedProfiles,
      uuIdentityObjectProfileList: identityProfiles,
      useCaseObjectProfileList: useCase.objectProfileList,
      uri: this._getUriFromContext(),
    });
  }

  async _authorizeObjectRoleGroupInterface(session, useCase, authorizationData, awid) {
    if (!useCase.objectProfileList) {
      let error = `Unable to authorize object. Use case profiles must be defined.`;
      await this._sendLogData(
        {
          authStrategy: authorizationData.authorizationStrategy,
          ucName: useCase.name,
          awid,
        },
        OBJECT_AUTH_TYPE,
        SEVERITY.error,
        error
      );
      throw new AuthorizationError(error);
    }
    await this._validateAuthorizationData(authorizationData, "authorizeObjectRoleGroupInterfaceType", awid);

    const uuIdentity = session.getIdentity().getUuIdentity();

    const profilesToAuthorize = this._convertRoleGroupUriMapToArray(authorizationData.roleGroupUriMap);

    const cacheKey = `${uuIdentity}|${Digest.sha1(Json.stringify(profilesToAuthorize))}`; // possible optimization - cache each role separately.
    const result = await this._useObjectCacheWrapper(
      cacheKey,
      async () => {
        return this._loadUserProfilesByRoleGroupInterface("", session, uuIdentity, null, profilesToAuthorize);
      },
      (r) => useCase.objectProfileList.some((p) => r.userProfiles.includes(p))
    );

    const identityProfiles = result.userProfiles;
    const authorizedProfiles = useCase.objectProfileList.filter((useCaseProfile) =>
      identityProfiles.includes(useCaseProfile)
    );

    if (authorizedProfiles.length < 1 && !result.resultComplete) {
      let error = `Role group interface authorization failed. uuIdentity: ${uuIdentity}, roleGroupUriMap=${JSON.stringify(
        authorizationData.roleGroupUriMap
      )}`;
      let cause = result.error;
      await this._sendLogData(
        {
          authStrategy: authorizationData.authorizationStrategy,
          ucName: useCase.name,
          awid,
        },
        OBJECT_AUTH_TYPE,
        SEVERITY.error,
        error,
        cause
      );
      throw new AuthorizationError(error, cause);
    }

    return new WorkspaceAuthorizationResult({
      uuIdentity,
      useCase: useCase.name,
      objectAuthorizationStrategy: authorizationData.authorizationStrategy,
      authorizedObjectProfileList: authorizedProfiles,
      uuIdentityObjectProfileList: identityProfiles,
      useCaseObjectProfileList: useCase.objectProfileList,
      uri: this._getUriFromContext(),
    });
  }

  async _authorizeObjectUuIdentityList(session, useCase, authorizationData, awid) {
    if (!useCase.objectProfileList) {
      let error = `Unable to authorize object. Use case profiles must be defined.`;
      await this._sendLogData(
        {
          authStrategy: authorizationData.authorizationStrategy,
          ucName: useCase.name,
          awid,
        },
        OBJECT_AUTH_TYPE,
        SEVERITY.error,
        error
      );
      throw new AuthorizationError(error);
    }
    await this._validateAuthorizationData(authorizationData, "authorizeObjectUuIdentityListType", awid);

    const uuIdentity = session.getIdentity().getUuIdentity();
    const identityProfiles = authorizationData.permissionMap[uuIdentity] || [];
    const authorizedProfiles = useCase.objectProfileList.filter((useCaseProfile) =>
      identityProfiles.includes(useCaseProfile)
    );

    return new WorkspaceAuthorizationResult({
      uuIdentity,
      useCase: useCase.name,
      objectAuthorizationStrategy: authorizationData.authorizationStrategy,
      authorizedObjectProfileList: authorizedProfiles,
      uuIdentityObjectProfileList: identityProfiles,
      useCaseObjectProfileList: useCase.objectProfileList,
      uri: this._getUriFromContext(),
    });
  }

  _evaluateboundArtifactProfileMap(authorizationResult, permissionMatrix, objectProfileList) {
    const authorizedProfiles = new Set();
    const identityProfiles = new Set();

    authorizationResult.userAppTypeProfiles.forEach((uuAppTypeProfile) => {
      if (Object.prototype.hasOwnProperty.call(permissionMatrix, uuAppTypeProfile)) {
        if (!(permissionMatrix[uuAppTypeProfile] instanceof Array)) {
          return;
        }

        permissionMatrix[uuAppTypeProfile].forEach((boundProfile) => {
          identityProfiles.add(boundProfile);

          if (objectProfileList.includes(boundProfile)) {
            authorizedProfiles.add(boundProfile);
          }
        });
      }
    });

    return { authorizedProfiles: Array.from(authorizedProfiles), identityProfiles: Array.from(identityProfiles) };
  }

  async _getUserProfiles(awid, uuIdentity, session, ucProfiles, authorizationData = {}, useCache = true) {
    let cacheKey = `${awid}|${uuIdentity}`;
    let result = this._userProfileCache.get(cacheKey);
    if (!useCache || !result) {
      let authorizationResult = await this._mutex.runOneAtTime(
        cacheKey,
        this._loadUserProfiles.bind(this),
        awid,
        uuIdentity,
        session,
        ucProfiles,
        authorizationData
      );
      result = {
        userProfiles: new Set(authorizationResult.userProfiles),
        authorizationStrategy: authorizationResult.authorizationStrategy,
        authorizationTime: Date.now(),
        authorizationError: authorizationResult.error,
      };
      if (authorizationResult.resultComplete && authorizationResult.doCache) {
        this._userProfileCache.set(cacheKey, result);
      } else if (!authorizationResult.resultComplete && result.userProfiles.size === 0) {
        let error = `Unable to load profiles of user ${uuIdentity}`;
        await this._sendLogData(
          {
            authStrategy: result.authorizationStrategy,
            awid,
          },
          OBJECT_AUTH_TYPE,
          SEVERITY.error,
          error
        );
        throw new AuthorizationError(error);
      }
    }
    return result;
  }

  async _loadUserProfiles(awid, uuIdentity, session, ucProfiles, authorizationData = {}) {
    let { authorizationStrategy = null } = authorizationData;
    let uuAppMetamodelVersion = authorizationData.uuAppMetamodelVersion;
    let authzArtifactUri = null;
    let userProfiles = [];
    let resultComplete = true;
    let doCache = true;
    let error = null;

    // Load system profiles and authorization type
    if (ProfileConfig.isPrivilegedCall(awid)) {
      let subAppInstance;
      // Cache result only in case asid exists
      try {
        subAppInstance = await AppInstanceComponent.get();
      } catch (e) {
        doCache = false;
      }
      userProfiles.push(...ProfileConfig.getPrivilegedUserProfiles(awid, uuIdentity));
      authorizationStrategy = this._getAuthorizationStrategy(subAppInstance, authorizationStrategy);
      authorizationData = this._getAuthorizationData(subAppInstance, authorizationStrategy, authorizationData);
    } else {
      let appWorkspace = await AppWorkspaceComponent.get(awid);
      if (appWorkspace["awidLicenseOwnerList"] && appWorkspace["awidLicenseOwnerList"].includes(uuIdentity)) {
        userProfiles.push("AwidLicenseOwner");
      }
      if (appWorkspace["awidInitiatorList"] && appWorkspace["awidInitiatorList"].includes(uuIdentity)) {
        userProfiles.push("AwidInitiator");
      }
      authorizationStrategy = this._getAuthorizationStrategy(appWorkspace, authorizationStrategy);
      authorizationData = this._getAuthorizationData(appWorkspace, authorizationStrategy, authorizationData);
      if (authorizationStrategy === ARTIFACT_AUTHZ_STRATEGY && !authorizationData.uuTerritoryBaseUri) {
        authzArtifactUri = appWorkspace["artifactUri"];
      }
      // Cache result only in case workspace is not in created, assigned state
      doCache =
        appWorkspace.sysState &&
        appWorkspace.sysState !== CREATED_SYS_STATE &&
        appWorkspace.sysState !== ASSIGNED_SYS_STATE;
    }

    // Load profiles from permissions
    let result = await this._loadProfilesByPermissions(awid, uuIdentity);
    userProfiles.push(...result.userProfiles);
    resultComplete = resultComplete && result.resultComplete;

    // Load profiles based on authorization type
    result = null;
    switch (authorizationStrategy) {
      case UU_IDENTITY_LIST_AUTHZ_STRATEGY:
        if (authorizationData.permissionMap && authorizationData.permissionMap[uuIdentity]) {
          userProfiles.push(...authorizationData.permissionMap[uuIdentity]);
        }
        break;
      case ROLE_GROUP_INTERFACE_AUTHZ_STRATEGY:
        try {
          let profilesToAuthorize = null;
          if (authorizationData.roleGroupUriMap) {
            profilesToAuthorize = this._convertRoleGroupUriMapToArray(authorizationData.roleGroupUriMap);
          }
          result = await this._loadUserProfilesByRoleGroupInterface(
            awid,
            session,
            uuIdentity,
            userProfiles,
            profilesToAuthorize
          );
        } catch (e) {
          logger.error(`RoleGroupInterface authorization of user ${uuIdentity} failed.`, e);
          resultComplete = false;
          error = e;
        }
        break;
      case ARTIFACT_AUTHZ_STRATEGY:
        try {
          if (!authzArtifactUri) {
            authzArtifactUri = this._buildArtifactUri(
              authorizationData.uuTerritoryBaseUri,
              authorizationData.artifactId,
              authorizationData.artifactCode
            );
          }
          result = await this._loadUserProfilesByArtifact(session, uuIdentity, authzArtifactUri, uuAppMetamodelVersion);
        } catch (e) {
          logger.error(`Artifact authorization of user ${uuIdentity} failed.`, e);
          resultComplete = false;
          error = e;
        }
        break;
      case BOUND_ARTIFACT_AUTHZ_STRATEGY:
        try {
          let useCase = { objectProfileList: ucProfiles };
          let boundResult = await this._authorizeBoundArtifact(session, useCase, {
            authorizationStrategy,
            ...authorizationData,
          });
          result = {
            resultComplete: boundResult.resultComplete,
            userProfiles: boundResult.identityProfiles,
            error: boundResult.error,
          };
        } catch (e) {
          logger.error(`Bound artifact authorization of user ${uuIdentity} failed.`, e);
          resultComplete = false;
          error = e;
        }
        break;
    }
    if (result) {
      userProfiles.push(...result.userProfiles);
      resultComplete = resultComplete && result.resultComplete;
      if (!error) {
        error = result.error;
      }
    }

    return { userProfiles, resultComplete, doCache, authorizationStrategy, error };
  }

  async _loadProfilesByPermissions(awid, uuIdentity) {
    let userProfiles = [];
    let resultComplete = true;

    try {
      let permissionProfiles = await SysPermissionAbl.getProfileCodesForUser(awid, uuIdentity);
      if (permissionProfiles && permissionProfiles.length > 0) {
        userProfiles.push(...permissionProfiles[0]["profileList"]);
      }
    } catch (e) {
      logger.error(`Loading of permissions for for user ${uuIdentity} failed.`, e);
      resultComplete = false;
    }

    return { userProfiles, resultComplete };
  }

  async _loadUserProfilesByRoleGroupInterface(awid, session, uuIdentity, knownUserProfiles, loadedProfiles) {
    let userProfiles = [];
    let resultComplete = true;

    if (!loadedProfiles) {
      let allProfiles = await SysProfileAbl.getAppProfileListByAwid(awid);
      let remainingProfiles = allProfiles.filter((profile) => !knownUserProfiles.includes(profile));
      loadedProfiles = (await SysProfileAbl.getAppProfileList(awid, remainingProfiles)).itemList;
    }

    let roleGroupProfileMap = {};
    loadedProfiles.forEach(({ profile, roleGroupUri }) => {
      if (!roleGroupUri) {
        return;
      }
      if (roleGroupUri === GGALL) {
        userProfiles.push(profile);
        return;
      }
      if (roleGroupUri === GGPLUS4U && uuIdentity !== ANONYMOUS_USER) {
        userProfiles.push(profile);
        return;
      }
      let personalRoleUri = this._getPersonalRoleUri(roleGroupUri, uuIdentity);
      if (personalRoleUri && roleGroupUri === personalRoleUri) {
        userProfiles.push(profile);
        return;
      }
      let profileCodes = roleGroupProfileMap[roleGroupUri];
      if (profileCodes) {
        profileCodes.push(profile);
      } else {
        profileCodes = [profile];
        roleGroupProfileMap[roleGroupUri] = profileCodes;
      }
    });

    let profileGroups = Object.keys(roleGroupProfileMap);
    if (uuIdentity === ANONYMOUS_USER || profileGroups.length === 0) {
      return { userProfiles, resultComplete };
    }

    let error;
    try {
      let result = await this._castService.verifyCastExistence(session, profileGroups);
      resultComplete = resultComplete && result.resultComplete;
      error = result.error;
      result.forEach((resultEntry) => {
        profileGroups.forEach((profileGroup) => {
          if (profileGroup === resultEntry.role || UuOs8UriHelper.equalUris(profileGroup, resultEntry.role)) {
            userProfiles.push(...roleGroupProfileMap[profileGroup]);
          }
        });
      });
    } catch (e) {
      logger.error(`Loading of profiles for for user ${uuIdentity} failed.`, e);
      resultComplete = false;
      error = e;
    }

    return { userProfiles, resultComplete, error };
  }

  _getPersonalRoleUri(roleUri, uuIdentity) {
    let personalRole = null;
    if (roleUri.indexOf("ues:") === 0) {
      let terrCode = UuOs8UriHelper.getTerritoryCode(roleUri);
      personalRole = `ues:${terrCode}:${uuIdentity}`;
    }

    return personalRole;
  }

  async _loadUserProfilesByArtifact(session, uuIdentity, authzArtifactUri, uuAppMetamodelVersion, useCase) {
    let userProfiles = [];
    let userAppTypeProfiles = [];
    let authorizedAppTypeProfiles = [];
    let ucAppTypeProfiles = [];
    let resultComplete = true;
    let error;

    if (!authzArtifactUri) {
      logger.error("Artifact authorization: Trying to use artifact authorization when artifactUri is not set.");
      return { userProfiles, resultComplete };
    }

    let uriBuilder;
    try {
      uriBuilder = UriBuilder.parse(authzArtifactUri);
      uriBuilder.setUseCase("uuArtifactIfc/authorizeMe");
      uriBuilder.setParameter("type", "full");
      if (uuAppMetamodelVersion) {
        uriBuilder.setParameter("uuAppMetamodelVersion", uuAppMetamodelVersion);
      }
      if (useCase) {
        uriBuilder.setParameter("useCase", useCase);
      }
      let result = await AppClient.get(uriBuilder.toUri(), null, { session, requestTimeout: this._authTimeout });

      // Profiles user is authorized to on the awsc
      if (result.uuIdentityUuAppProfileList) {
        userProfiles.push(...result.uuIdentityUuAppProfileList);
      } else if (result.userUuAppProfileList) {
        userProfiles.push(...result.userUuAppProfileList);
      }

      // Profiles user is authorized to on the obc
      if (result.uuIdentityUuAppTypeProfileList) {
        userAppTypeProfiles.push(...result.uuIdentityUuAppTypeProfileList);
      } else if (result.userUuAppTypeProfileList) {
        userAppTypeProfiles.push(...result.userUuAppTypeProfileList);
      }

      // Profiles that authorize user to the uc (intersection of userAppTypeProfiles and ucAppTypeProfiles)
      if (result.authorizedUuAppTypeProfileList) {
        authorizedAppTypeProfiles.push(...result.authorizedUuAppTypeProfileList);
      } else if (result.uuAppTypeProfileList) {
        authorizedAppTypeProfiles.push(...result.uuAppTypeProfileList);
      }

      // Profiles that may execute the uc
      if (result.ucUuAppTypeProfileList) {
        ucAppTypeProfiles.push(...result.ucUuAppTypeProfileList);
      }
      if (result.ucUuAppTypeRoleProfileList) {
        ucAppTypeProfiles.push(...result.ucUuAppTypeRoleProfileList);
      }
    } catch (e) {
      if (
        e.status === 403 ||
        e.code === "uu-businessterritory-maing01/authorization/accessDenied" ||
        e.code === "uu-appg01/authorization/accessDenied" ||
        e.code === "uu-myterritory-maing01/authorization/accessDenied"
      ) {
        logger.debug(`User ${uuIdentity} has no profile for artifact (authorization uri: ${uriBuilder}).`, e);
      } else if (
        e.code === "uu-businessterritory-maing01/authorization/artifactDoesNotExist" ||
        e.code === "uu-myterritory-maing01/authorization/artifactDoesNotExist"
      ) {
        logger.debug(
          `Artifact of given type does not exist (authorization uri: ${uriBuilder}, user: ${uuIdentity}).`,
          e
        );
      } else {
        logger.error(`Loading of profiles for user ${uuIdentity} failed (authorization uri: ${uriBuilder}).`, e);
        resultComplete = false;
      }
      error = e;
    }

    return { userProfiles, userAppTypeProfiles, authorizedAppTypeProfiles, ucAppTypeProfiles, resultComplete, error };
  }

  async _validateAuthorizationData(authorizationData, validationType, awid) {
    let validationResult = this.validator.validate(validationType, authorizationData);

    try {
      ValidationHelper.processValidationResult(
        authorizationData,
        validationResult,
        `${WorkspaceAuthorizationErrors.UC_CODE}/unsupportedKeys`,
        WorkspaceAuthorizationErrors.InvalidAuthorizationDataError
      );
    } catch (e) {
      let error = `Unable to authorize object. Authorization data are not valid. (paramMap: ${Json.stringify(
        e.paramMap
      )})`;
      await this._sendLogData(
        { awid, authStrategy: authorizationData.authorizationStrategy },
        OBJECT_AUTH_TYPE,
        SEVERITY.error,
        error
      );
      throw new AuthorizationError(error);
    }
  }

  _buildArtifactUri(awscArtifactUri, id, code) {
    if (awscArtifactUri) {
      const artifactUriBuilder = UriBuilder.parse(awscArtifactUri).clearParameters();
      if (id) {
        artifactUriBuilder.setParameter("id", id);
      } else {
        artifactUriBuilder.setParameter("code", code);
      }
      return artifactUriBuilder.toUri();
    }
    return null;
  }

  async _useObjectCacheWrapper(cacheKey, getResultFn, isPositiveResultFn) {
    let cacheResult = this._objectUserProfileCache.get(cacheKey);

    let authorizationResult;
    // resolve negative cache -> use cache only if its age is lower than negative ttl or it is positive result
    if (
      cacheResult &&
      (Date.now() - cacheResult.authorizationTime < this._objectUserProfileNegativeCacheTtl ||
        isPositiveResultFn(cacheResult.authorizationResult))
    ) {
      // resolve negative cache
      authorizationResult = cacheResult.authorizationResult;
    }
    if (!authorizationResult) {
      authorizationResult = await this._mutex.runOneAtTime(cacheKey, getResultFn);
      if (authorizationResult.resultComplete) {
        this._objectUserProfileCache.set(cacheKey, { authorizationResult, authorizationTime: Date.now() });
      }
    }

    return authorizationResult;
  }

  _convertRoleGroupUriMapToArray(roleGroupUriMap = {}) {
    return Object.entries(roleGroupUriMap)
      .map((e) => ({ profile: e[0], roleGroupUri: e[1] }))
      .sort((a, b) => a.profile.localeCompare(b.profile));
  }

  async _sendLogData(data = {}, authorizationType = "", severity = "", error = null, cause = null) {
    let { awid, result, authStrategy, ucName } = data;

    const logData = {
      authorizationType,
      authorizationStrategy: authStrategy,
      authorizedUseCase: ucName,
    };
    if (authorizationType === OBJECT_AUTH_TYPE) {
      (logData.authorizedObjectProfileList = result ? result.getAuthorizedObjectProfileList() : []),
        (logData.uuIdentityObjectProfileList = result ? result.getUuIdentityObjectProfileList() : []),
        (logData.useCaseObjectProfileList = result ? result.getUseCaseObjectProfileList() : []);
    } else {
      (logData.uuIdentityProfileList = result ? result.getIdentityProfiles() : []),
        (logData.authorizedProfileList = result ? result.getAuthorizedProfiles() : []),
        (logData.useCaseProfileList = result ? result.getUseCaseProfileList() : []);
    }
    if (authStrategy === ARTIFACT_AUTHZ_STRATEGY) {
      let { awscArtifactUri, artifactId, artifactCode } = this._getArtifactAuthData(awid);
      logData.artifactUri = this._buildArtifactUri(awscArtifactUri, artifactId, artifactCode);
    }
    if (authStrategy === BOUND_ARTIFACT_AUTHZ_STRATEGY) {
      logData.boundArtifactUri = await this._getBoundArtifactUri(awid);
    }
    if (error) {
      logData.uuAppErrorMap = JSON.stringify(new AuthorizationError(error, cause));
    }
    let message = "";
    if (severity === SEVERITY.error) {
      message = AUTH_PROCESS_FAILED;
    } else {
      message = AUTH_PROCESS_COMPLETED;
    }
    await AuditLog.log(severity, "uuApp/authorization", message, logData);
    return logData;
  }

  async _getArtifactAuthData(awid) {
    let appWorkspace = await AppWorkspaceComponent.get(awid);
    let awscArtifactUri;
    let artifactId = null;
    let artifactCode = null;
    if (
      appWorkspace &&
      appWorkspace.authorizationData &&
      appWorkspace.authorizationData[ARTIFACT_AUTHZ_STRATEGY] &&
      appWorkspace.authorizationData[ARTIFACT_AUTHZ_STRATEGY].uuTerritoryBaseUri
    ) {
      awscArtifactUri = appWorkspace.authorizationData[ARTIFACT_AUTHZ_STRATEGY].uuTerritoryBaseUri;
      artifactId = appWorkspace.authorizationData[ARTIFACT_AUTHZ_STRATEGY].artifactId;
      artifactCode = appWorkspace.authorizationData[ARTIFACT_AUTHZ_STRATEGY].artifactCode;
    } else {
      awscArtifactUri = appWorkspace.artifactUri;
    }
    return { awscArtifactUri, artifactId, artifactCode };
  }

  async _getBoundArtifactUri(awid, authorizationData = null) {
    let authData = null;
    let boundArtifactUri = null;
    if (this._asid === awid) {
      let subAppInstance = {};
      try {
        subAppInstance = await AppInstanceComponent.get();
        // eslint-disable-next-line no-empty
      } catch (e) {}
      authData = this._getAuthorizationData(subAppInstance, BOUND_ARTIFACT_AUTHZ_STRATEGY, authorizationData);
    } else if (awid) {
      let appWorkspace = await AppWorkspaceComponent.get(awid);
      authData = this._getAuthorizationData(appWorkspace, BOUND_ARTIFACT_AUTHZ_STRATEGY);
    }
    if (authData) {
      boundArtifactUri = this._buildArtifactUri(
        authData.uuTerritoryBaseUri,
        authData.boundArtifactId,
        authData.boundArtifactCode
      );
    }
    return boundArtifactUri;
  }

  _getAuthorizationData(entity = null, authorizationStrategy = null, authorizationData = null) {
    let authData = entity && entity.authorizationData;
    return authData && authData[authorizationStrategy]
      ? { ...authData[authorizationStrategy], ...authorizationData }
      : { ...authorizationData };
  }

  _getAuthorizationStrategy(entity = null, authorizationStrategy = null) {
    return authorizationStrategy || (entity && entity["authorizationStrategy"]) || DEFAULT_AUTHZ_STRATEGY;
  }
}

// Register default uuAppWorkspace authorization service
WorkspaceAuthorizationService.create(DEFAULT_SERVICE_NAME);

module.exports = WorkspaceAuthorizationService;
