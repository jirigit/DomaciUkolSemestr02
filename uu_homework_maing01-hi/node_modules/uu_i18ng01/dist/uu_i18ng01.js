/*!
 * UAF COMMERCIAL LICENSE
 * ----------------------
 * 1. PREAMBLE and Definitions
 *   1.1 These UAF Commercial License Terms ("UAF CLT") govern licensing of the Unicorn Application Framework (UAF).
 *     The Customer and Unicorn concluded an agreement for the provision of Solution that is using UAF or its parts
 *     (the "Agreement").
 *   1.2 The provisions of these UAF CLT shall govern the relationship between the Customer and Unicorn regarding
 *     the UAF License granted under the Agreement. For the avoidance of doubt, in case of any conflict between these
 *     UAF CLT and the Agreement, the provisions of the Agreement always prevail.
 *   1.3 The "UAF Components", and each of them individually as "UAF Component", shall mean the components of the Unicorn
 *     Application Framework, which are listed and described in the Attachment I to these UAF CLT.
 *   1.4 "UAF" shall mean the Unicorn Application Framework the scope of which is described in Attachment I, including all
 *     associated documentation and preparatory design materials, in particular blueprints, models, user manuals,
 *     training materials, comprehensive instructions and guidelines for drafting, production, operation and maintenance of
 *     software solutions, reference architecture, ready-made components and tools, use cases and tutorials.
 *   1.5 The "Knowledge Base" shall mean the online materials, internet fora and other resources made available by Unicorn
 *     online with regard to the UAF, intended for the broad customer and developer community.
 *   1.6 The "License" shall mean the binding terms and conditions for use of the UAF by the Customer. The License is
 *     described in Clause 2 and may be further specified or modified by the Agreement.
 *   1.7 The "Solution" shall mean any product or service developed under the Agreement using the UAF or any of
 *     UAF Components or its other parts, further specified in the Agreement.
 * 2. LICENSE GRANT
 *   2.1 The Customer shall be hereby granted a non-exclusive and non-transferable worldwide license to use the UAF for
 *     the purpose of the Solution described in the Agreement. For this purpose, the Customer shall be entitled to modify
 *     the UAF and create derivative works based on the UAF.
 *   2.2 The Customer is entitled to grant third parties a sub-license allowing them to use the UAF or any derivative works
 *     based on the UAF under commercial terms of its choice, provided that:
 *     2.2.1 use of the UAF and any derivative works based on the UAF by third parties is limited to testing, handover and
 *       operation of the Solution or its use as a service,
 *     2.2.2 third parties are not entitled to use the UAF or any derivative works based on the UAF independently of
 *       the Solution,
 *     2.2.3 third parties are not provided access to source code of the UAF unless such right is granted by the Agreement
 *       or if they conclude a commercial license agreement with Unicorn.
 *   2.3 The Solution or its parts based on the UAF shall bear a prominent copyright notice "Based on Unicorn Application
 *     Framework Copyright (c) Unicorn" integrated
 *     2.3.1 in the graphical user interface of the Solution or its relevant part or
 *     2.3.2 in accompanying file if the Solution or its relevant part do not have graphical user interface or
 *     2.3.3 in Solution's documentation.
 *   2.4 The License shall be valid for the whole duration of copyright to the UAF, unless other duration of the License is
 *     specified in the Agreement.
 *   2.5 The Customer is entitled to access the Knowledge Base only if expressly agreed in the Agreement.
 *   2.6 The Unicorn retains all rights to the UAF not covered by the provisions of this Clause 2. Unless explicitly
 *     permitted by applicable law, the Customer may not use the UAF in any other way than provided by the provisions of
 *     this Clause 2 and may not allow such use on its behalf by any of its employees or agents.
 *   2.7 The price for the License is included in the price stipulated in the Agreement.
 * 3. MODIFICATIONS
 *   3.1 The Customer explicitly acknowledges that the UAF is under continuous development and any UAF Component or other
 *     part of the UAF may be modified, replaced or removed by the Unicorn from the UAF in any of its future versions.
 *   3.2 This License covers also any new version of UAF if some parts of the UAF are modified or replaced.
 *   3.3 If any part of the UAF is removed by Unicorn in any of its future versions, the License for such version of
 *     the UAF is reduced appropriately and covers only the remaining parts of UAF. Sub-licenses previously granted to
 *     third parties in accordance with Clause 2.2 remain unaffected.
 * 4. THIRD PARTY LICENSE TERMS
 *   4.1 UAF is using third party software tools (the "Third Party Software") that is an integral part of the UAF. Some of
 *     these tools are free software or open-source SW.
 *   4.2 The list of Third Party Software used in the UAF including its license terms and authors is provided as part of
 *     Attachment I to these UAF CLT.
 *   4.3 For the use of the above mentioned Third Party Software, the Customer acknowledges its license terms referred to
 *     in Attachment I to these UAF CLT.
 * 5. NO TRADEMARK OR PATENT LICENSE
 *   5.1 These UAF CLT cover only copyright use of the UAF. If not expressly agreed otherwise, the Customer shall not be
 *     granted any trademark and/or patent license here under and nothing in these UAF CLT shall be interpreted in a way it
 *     does so.
 * 6. LIMITED WARRANTY
 *   6.1 IF NOT STIPULATED OTHER WISE OR REQUIRED BY APPLICABLE LAW, THE UAF IS PROVIDED ON "AS IS" BASIS,
 *     WITH NO WARRANTY OF, INCLUDING WITHOUT LIMITATION, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE
 *     RISK AS TO THE QUALITY AND PERFORMANCE OF THE UAF IS CARRIED SOLELY BY THE CUSTOMER, UNLESS OTHERWISE AGREED BETWEEN
 *     THE UNICORN AND THE CUSTOMER IN THE AGREEMENT.
 * 7. LIMITATION OF LIABILITY
 *   7.1 TO THE EXTENT PERMITTED BY APPLICABLE LAW, THE UNICORN WILL NOT BE HELD LIABLE FOR ANY DAMAGES CAUSED BY
 *     THE DISTRIBUTION OR USE OF THE UAF. THIS ALSO INCLUDES ANY CONSEQUENTIAL AND/OR INCIDENTAL DAMAGES, MONETARY OR NOT,
 *     THAT ARE CONNECTED WITH THE DISTRIBUTION OR USE OF THE UAF, UNLESS OTHERWISE AGREED BETWEEN THE UNICORN AND
 *     THE CUSTOMER IN THE AGREEMENT.
 * 8. THIRD PARTY CLAIMS
 *   8.1 The Unicorn will defend or settle, at its option and expense, any action brought against the Customer in a member
 *     state of the European Union which concerns an allegation that the UAF provided infringes a patent or copyright or
 *     misappropriates a trade secret in such jurisdiction. The Unicorn shall pay costs and damages finally awarded against
 *     the Customer that are attributable to such action. The Customer declares to understand and agrees that following
 *     conditions must be fulfilled in order to make Unicorn's obligations under this Clause 8 effective and enforceable:
 *     The Customer must (a) notify Unicorn promptly in writing of the action or any reasonable threat of it,
 *     (b) provide the Unicorn with all reasonable information and assistance it will request to settle or defend the action, and
 *     (c) grant the Unicorn sole authority and control of the defense or settlement of the action.
 *   8.2 If a claim is made under Clause 8.1 the Unicorn may, at its sole option and expense:
 *     (a) replace or modify the UAF so that it becomes non-infringing,
 *     (b) procure for the Customer the right to continue using the UAF unmodified.
 *   8.3 The Unicorn shall not be held liable to the Customer if the action is based on:
 *     (a) the combination of UAF with any product not provided by Unicorn,
 *     (b) the modification of the UAF other than by Unicorn,
 *     (c) the use of other than a current unaltered release of the UAF,
 *     (d) a product that the Customer makes, uses, or sells,
 *     (e) infringement by the Customer that is deemed willful. In the case under (e) the Customer shall reimburse
 *     the Unicorn for its reasonable attorney fees and other costs related to the action.
 *   8.4 THIS CLAUSE IS SUBJECT TO CLAUSE 7 AND STATES UNICORN'S ENTIRE LIABILITY, CUSTOMER'S SOLE AND EXCLUSIVE REMEDY,
 *     FOR DEFENSE, SETTLEMENT AND DAMAGES, WITH RESPECT TO ANY ALLEGED PATENT OR COPYRIGHT INFRINGEMENT OR TRADE SECRET
 *     MISAPPROPRIATION BY ANY ITEM PROVIDED UNDER THESE TERMS, UNLESS OTHERWISE AGREEMENT BETWEEN UNICORN AND THE CUSTOMER
 *     IN THE AGREEMENT.
 * 9. GENERAL PROVISIONS
 *   9.1 By entering into the Agreement, the Customer signifies its assent to and acceptance of these UAF CLT.
 *   9.2 The License is effective from the moment of execution of the Agreement, if the Agreement does not specify later
 *     date. Where the provisions of the Agreement regarding the License and provisions of these UAF CLT differ, provisions
 *     of the Agreement shall prevail.
 *   9.3 If any provision of the Agreement regarding the License or these UAF CLT is held by a court of competent
 *     jurisdiction to be void, invalid, unenforceable or illegal, such provision shall be severed from the Agreement or
 *     these UAF CLT and the remaining provisions will remain in full force and effect.
 *   9.4 The provisions of Clauses 7 and 8 shall survive any expiration or termination of the Agreement.
 *   9.5 All rights and obligations between the Unicorn and the Customer arising on the basis of these UAF CLT or
 *     in connection with them are governed by the laws of the Czech Republic with the exclusion of both the rules on
 *     the conflict of laws and the United Nations Convention on Contracts for the International Sale of Goods (CISG).
 *   9.6 The resolution of all disputes arising from or connected here to shall be under sole jurisdiction of the courts of
 *     the Czech Republic.
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("module"));
	else if(typeof define === 'function' && define.amd)
		define("uu_i18ng01", ["module"], factory);
	else if(typeof exports === 'object')
		exports["uu_i18ng01"] = factory(require("module"));
	else
		root["UuI18n"] = factory(root["undefined"]);
})(this, (__WEBPACK_EXTERNAL_MODULE_module__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  get UuDate() {
    return __webpack_require__("./uu-date.js");
  },
  get UuDateTime() {
    return __webpack_require__("./uu-date-time.js");
  }
};

/***/ }),

/***/ "./internal/custom-format.js":
/***/ ((module) => {

function customFormat(uuDateOrTime, formatString, locale, timeZone) {
  let jsDate;
  if (uuDateOrTime.date) {
    jsDate = uuDateOrTime.date; // uuDateOrTime is UuDateTime
  } else {
    jsDate = new Date(uuDateOrTime.toIsoString() + "T00:00:00.000Z"); // uuDateOrTime is UuDate
    timeZone = "UTC";
  }
  let getPart = (intlOptions, partName = Object.keys(intlOptions)[0], skipNornmalize = false) => {
    let formatter = new Intl.DateTimeFormat(locale, {
      timeZone,
      ...intlOptions
    });
    let parts = formatter.formatToParts(jsDate);
    let part = parts.find(it => it.type === partName);
    let value = part ? part.value : null;
    if (!skipNornmalize && value != null && value.match(/^\d+$/)) value = Number(value) + ""; // normalize, because e.g. formatting in en-US with { hour: "numeric" } still returns "02" and we want "2"
    if (value == null && partName === "fractionalSecond") {
      value = (jsDate.getMilliseconds() + "").padStart(3, "0").substr(0, intlOptions.fractionalSecondDigits);
    }
    return value;
  };

  // NOTE Ordering matters. First to match should be sooner in the map.
  // keys are based on moment formats - https://momentjs.com/docs/#/displaying/format/
  let supported = {
    YYYY: () => getPart({
      year: "numeric"
    }),
    YY: () => getPart({
      year: "2-digit"
    }),
    Y: () => getPart({
      year: "numeric"
    }),
    // NOTE There's difference between formatting just month ('leden' in cs-CZ) vs day+month (e.g. '2. ledna') in Intl API.
    // For custom formatting, we'll be consistent with moment - they use month-only ('leden') in all cases.
    MMMM: () => getPart({
      month: "long"
    }),
    MMM: () => getPart({
      month: "short"
    }),
    MM: () => getPart({
      month: "numeric"
    }).padStart(2, "0"),
    M: () => getPart({
      month: "numeric"
    }),
    dddd: () => getPart({
      weekday: "long"
    }),
    ddd: () => getPart({
      weekday: "short"
    }),
    dd: () => getPart({
      weekday: "short"
    }).substring(0, 2),
    DD: () => getPart({
      day: "numeric"
    }).padStart(2, "0"),
    D: () => getPart({
      day: "numeric"
    }),
    WW: () => (uuDateOrTime.getWeek() + "").padStart(2, "0"),
    W: () => uuDateOrTime.getWeek() + "",
    E: () => uuDateOrTime.getWeekDay() + "",
    HH: () => getPart({
      hour: "numeric",
      hourCycle: "h23"
    }).padStart(2, "0"),
    H: () => getPart({
      hour: "numeric",
      hourCycle: "h23"
    }),
    hh: () => getPart({
      hour: "numeric",
      hourCycle: "h12"
    }).padStart(2, "0"),
    h: () => getPart({
      hour: "numeric",
      hourCycle: "h12"
    }),
    KK: () => getPart({
      hour: "numeric",
      hourCycle: "h11"
    }).padStart(2, "0"),
    K: () => getPart({
      hour: "numeric",
      hourCycle: "h11"
    }),
    kk: () => getPart({
      hour: "numeric",
      hourCycle: "h24"
    }).padStart(2, "0"),
    k: () => getPart({
      hour: "numeric",
      hourCycle: "h24"
    }),
    AAA: () => getPart({
      dayPeriod: "long",
      hour: "numeric",
      hourCycle: "h12"
    }).toUpperCase(),
    aaa: () => getPart({
      dayPeriod: "long",
      hour: "numeric",
      hourCycle: "h12"
    }),
    AA: () => getPart({
      dayPeriod: "short",
      hour: "numeric",
      hourCycle: "h12"
    }).toUpperCase(),
    aa: () => getPart({
      dayPeriod: "short",
      hour: "numeric",
      hourCycle: "h12"
    }),
    A: () => getPart({
      dayPeriod: undefined,
      hour: "numeric",
      hourCycle: "h12"
    }),
    a: () => getPart({
      dayPeriod: undefined,
      hour: "numeric",
      hourCycle: "h12"
    }).toLowerCase(),
    mm: () => getPart({
      minute: "numeric"
    }).padStart(2, "0"),
    m: () => getPart({
      minute: "numeric"
    }),
    ss: () => getPart({
      second: "numeric"
    }).padStart(2, "0"),
    s: () => getPart({
      second: "numeric"
    }),
    "S+": m => getPart({
      second: "numeric",
      fractionalSecondDigits: Math.min(3, m.length)
    }, "fractionalSecond", true).padStart(Math.min(3, m.length), "0").padEnd(m.length, "0"),
    "\\[[^\\]]*\\]": m => m.substr(1, m.length - 2) // escaping support - values in brackets are to be left as-is
  };

  let regexp = "(" + Object.keys(supported).join("|") + ")";
  let result = formatString.replace(new RegExp(regexp, "g"), m => {
    let fn = supported[m];
    if (!fn) {
      for (let k in supported) {
        if (m.match(new RegExp("^(" + k + ")$"))) {
          fn = supported[k];
          break;
        }
      }
    }
    let result = fn(m);
    return result == null ? m : result;
  });
  return result;
}
module.exports = {
  customFormat
};

/***/ }),

/***/ "./internal/util.js":
/***/ ((module) => {

const ANY_DATE = new Date(9e8 + 10); // 1970-01-11T10:00:00.010Z
const FORMATTER_OPTIONS = {
  calendar: "iso8601",
  numberingSystem: "latn"
};
const FORMAT_MAP = {
  year: "Y",
  month: "M",
  day: "D",
  h23: "H",
  h24: "k",
  h11: "K",
  h12: "h",
  minute: "m",
  second: "s",
  fractionalSecond: "S",
  dayPeriod: "A"
};

/**
 * Parses the given string as a date. Allows more relaxed date strings, e.g.
 * "15" would be interpreted as 15th of the actual month.
 *
 * @param aString The string to parse as a date.
 * @returns The [year, month, day] numeric array (or null if unable to parse).
 */
function parseDate(dateString, locale, format = undefined) {
  let strTrimmed = dateString != null ? dateString.trim() : dateString;
  if (!strTrimmed) return null;
  let result;
  if (format != null) {
    result = _parseByFormat(strTrimmed, format, locale);
  } else {
    // the most common case
    result = _parseByFormats(strTrimmed, _getFormats(locale, {
      year: "numeric",
      month: "numeric",
      day: "numeric"
    }), locale);
    if (!result) {
      result = _parseByFormats(strTrimmed, _getFormats(locale, {
        month: "numeric",
        day: "numeric"
      }), locale);
    }
    if (!result) result = _parseByFormats(strTrimmed, _getFormats(locale, {
      day: "numeric"
    }), locale);
    if (!result) result = _parseByFormat(strTrimmed, "Y-M-D", locale); // fall back to ISO-like (interpret year as full, not as 2-digit)
    if (!result) result = parseWeekDate(strTrimmed); // fall back to ISO week date
  }

  return result ? result.slice(0, 3) : null;
}

/**
 * Parses the given string as a time. Allows more relaxed date strings, e.g.
 * "15" would be interpreted as 15:00.
 *
 * @param aString The string to parse as a time.
 * @returns The [hour, minute, second, millisecond] numeric array (or null if unable to parse).
 */
function parseTime(timeString, locale, format = undefined) {
  let strTrimmed = timeString != null ? timeString.trim() : timeString;
  if (!strTrimmed) return null;
  let result;
  if (format != null) {
    result = _parseByFormat(strTrimmed, format, locale);
  } else {
    // most-common first
    result = _parseByFormats(strTrimmed, _getFormats(locale, {
      hour: "numeric",
      minute: "numeric"
    }), locale);
    if (!result) {
      result = _parseByFormats(strTrimmed, _getFormats(locale, {
        hour: "numeric",
        minute: "numeric",
        second: "numeric"
      }), locale);
    }
    if (!result) result = _parseByFormats(strTrimmed, _getFormats(locale, {
      hour: "numeric"
    }), locale);
    if (!result) result = _parseByFormat(strTrimmed, "H:m", locale); // fall back to ISO-like as the last resort if nothing matched
    if (!result) result = _parseByFormat(strTrimmed, "H:m:s", locale); // fall back to ISO-like as the last resort if nothing matched
    if (!result) result = _parseByFormat(strTrimmed, "H:m:s.S", locale); // fall back to ISO-like as the last resort if nothing matched
  }

  return result ? result.slice(3) : null;
}
function parseDateTime(dateTimeString, locale, format = undefined) {
  let strTrimmed = dateTimeString != null ? dateTimeString.trim() : dateTimeString;
  if (!strTrimmed) return null;
  let result;
  if (format != null) {
    result = _parseByFormat(strTrimmed, format, locale);
  } else {
    // most-common first
    result = _parseByFormats(strTrimmed, _getFormats(locale, {
      year: "numeric",
      month: "numeric",
      day: "numeric",
      hour: "numeric",
      minute: "numeric"
    }), locale);
    if (!result) {
      result = _parseByFormats(strTrimmed, _getFormats(locale, {
        year: "numeric",
        month: "numeric",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        second: "numeric"
      }), locale);
    }
    if (!result) {
      result = _parseByFormats(strTrimmed, _getFormats(locale, {
        year: "numeric",
        month: "numeric",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        fractionalSecondDigits: 3
      }), locale);
    }
    if (!result) {
      result = _parseByFormats(strTrimmed, _getFormats(locale, {
        month: "numeric",
        day: "numeric",
        hour: "numeric",
        minute: "numeric"
      }), locale);
    }
    if (!result) {
      result = _parseByFormats(strTrimmed, _getFormats(locale, {
        year: "numeric",
        month: "numeric",
        day: "numeric",
        hour: "numeric"
      }), locale);
    }
    if (!result) result = parseDate(dateTimeString, locale);
    if (!result) {
      let spaceIndex = dateTimeString.indexOf(" ");
      if (spaceIndex !== -1 && spaceIndex === dateTimeString.lastIndexOf(" ")) {
        if (!result) result = _parseByFormat(strTrimmed, "Y-M-D H:m", locale); // fall back to ISO-like as the last resort if nothing matched
        if (!result) result = _parseByFormat(strTrimmed, "Y-M-D H", locale); // fall back to ISO-like as the last resort if nothing matched
        if (!result) result = _parseByFormat(strTrimmed, "Y-M-D H:m:s", locale); // fall back to ISO-like as the last resort if nothing matched
        if (!result) result = _parseByFormat(strTrimmed, "Y-M-D H:m:s.S", locale); // fall back to ISO-like as the last resort if nothing matched
      }

      if (!result && spaceIndex !== -1) {
        let dateStr = dateTimeString.slice(0, spaceIndex);
        let timeStr = dateTimeString.slice(spaceIndex + 1).trim();
        let dateResult = parseDate(dateStr, locale);
        if (dateResult) {
          let timeResult = parseTime(timeStr, locale);
          if (timeResult) {
            result = [dateResult[0], dateResult[1], dateResult[2], ...timeResult];
          }
        }
      }
    }
    if (!result) {
      result = parseTime(dateTimeString, locale);
      if (result) {
        let now = new Date(Date.now());
        result = [now.getFullYear(), now.getMonth() + 1, now.getDate(), ...result];
      }
    }
  }
  return result ? result : null;
}
function parseWeekDate(string) {
  let result;
  let match = string.match(/^(\d{4})-W(\d{2})(?:-([1-7]))?$/);
  if (match) {
    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_an_ordinal_or_month_date_from_a_week_date
    let weekYear = Number(match[1]);
    let week = Number(match[2]);
    let weekDay = match[3] ? Number(match[3]) : 1;
    let dayOfYear = week * 7 + weekDay - (getWeekDay(weekYear, 1, 4) + 3);
    let potentialResult = [weekYear, 1, dayOfYear]; // dayOfYear can be <=0 or >356 but that will be normalized by new Date(...) automatically
    // use the result only if it didn't overflow, e.g. disallow 2020-W99-1 (week 99)
    if (getWeekYear(...potentialResult) === weekYear && getWeek(...potentialResult) === week && (!match[3] || getWeekDay(...potentialResult) === weekDay)) {
      result = potentialResult;
    }
  }
  return result;
}
function getWeek(year, month, day, weekStartDay = 1) {
  let d = getJsDate(year, month, day);
  let dayOffset = (d.getDay() || 7) - (weekStartDay - 1);
  if (dayOffset <= 0) dayOffset += 7;
  d.setDate(d.getDate() + 4 - dayOffset);
  return Math.ceil(((d - getJsDate(d.getFullYear())) / 8.64e7 + 1) / 7);
}
function getWeekYear(year, month, day, weekStartDay = 1) {
  let week = getWeek(year, month, day, weekStartDay);
  // for 2022/01/01 it could return year 2022 and week 53
  // or for 2021/12/31 it could return year 2021 and week 01

  // we need to check and fix if it is last week of the last year of first week of the next year
  let weekDay = getWeekDay(year, month, day);
  let dayOffset = weekStartDay - weekDay;
  if (dayOffset > 0) dayOffset -= 7; // if dayOffset is positive then we will shift into the future, but we always need to shift into the past
  let jsDate = getJsDate(year, month, day, 12);
  jsDate.setDate(jsDate.getDate() + dayOffset);
  let startWeekYear = jsDate.getFullYear();
  jsDate.setDate(jsDate.getDate() + 6);
  let endWeekYear = jsDate.getFullYear();
  if (startWeekYear !== endWeekYear) {
    if (startWeekYear === year && week === 1) {
      // it is first week of the next year
      year++;
    } else if (endWeekYear === year && week !== 1) {
      // it is last week of the previous year
      year--;
    }
  }
  return year;
}
function getWeekDay(year, month, day) {
  let date = new Date(getUtcMillis(year, month, day, 12, 0, 0, 0));
  let index = date.getUTCDay(); // 0 <=> Sunday, 1 <=> Monday
  return index || 7; // 7 <=> Sunday, 1 <=> Monday
}

// returns e.g. "d.M.y H:mm" or "M/d/y, h:mm a", depending on locale
function _getFormat(locale, fields) {
  let options = {
    ...FORMATTER_OPTIONS,
    ...fields
  };
  let formatter = new Intl.DateTimeFormat(locale, options);
  let resolvedOptions = formatter.resolvedOptions();
  let parts = formatter.formatToParts(ANY_DATE);
  let strParts = parts.map(({
    type,
    value
  }) => {
    if (type === "literal") return value;
    let fieldOption = fields[type];
    let formatChar = FORMAT_MAP[type === "hour" ? resolvedOptions.hourCycle : type];
    if (!formatChar) {
      if ((typeof process !== "undefined" && process.env && (process.env.NODE_ENV) || "development") === "test") {
        console.warn(`Unrecognized formatting part '${type}' when parsing date/time using locale '${locale}'.`);
      }
      return ""; // shouldn't happen
    }

    let result = fieldOption === "2-digit" ? formatChar + formatChar : formatChar;
    if (type === "month") {
      if (fieldOption === "long") result = "".padStart(4, formatChar);else if (fieldOption === "short") result = "".padStart(3, formatChar);
    }

    // NodeJS < 14.8.0 doesn't support "fractionalSecond" even with full-icu => add it manually
    if (type === "second" && options.fractionalSecondDigits > 0 && !("fractionalSecondDigits" in resolvedOptions)) {
      let numberParts = new Intl.NumberFormat(locale, {
        minimumFractionDigits: 1
      }).formatToParts(0.5);
      let decimalPointPart = numberParts.find(it => it.type === "decimal");
      if (decimalPointPart) result += decimalPointPart.value + FORMAT_MAP["fractionalSecond"];
    }
    return result;
  });
  let result = strParts.join("");
  if (parts.some(it => it.type === "dayPeriod")) result = result.replace(/H+/g, "h");
  return result;
}
function _getFormats(locale, fields) {
  let formatsOpts = [fields];

  // if the format uses "month", we'll try any representation of month (e.g. name too)
  if ("month" in fields) {
    for (let month of ["long", "short", "numeric"]) {
      if (month !== fields.month) formatsOpts.push({
        ...fields,
        month
      });
    }
  }

  // if a format uses "year", we'll try 2-digit variant automatically
  // (and it'll be checked first because otherwise full year would use the value too, as a full year)
  if ("year" in fields && fields.year !== "2-digit") {
    let extra = formatsOpts.map(it => ({
      ...it,
      year: "2-digit"
    }));
    formatsOpts = extra.concat(formatsOpts);
  }
  let result = formatsOpts.map(opts => _getFormat(locale, opts));
  return result;
}
function _parseByFormats(aString, formatList, locale) {
  for (let format of formatList) {
    let result = _parseByFormat(aString, format, locale);
    if (result != null) return result;
  }
  return null;
}
function _parseByFormat(aString, aFormat, locale) {
  let date = new Date(Date.now());
  date.setHours(0, 0, 0, 0);
  // prettier-ignore
  let val = {
    Y: date.getFullYear(),
    M: date.getMonth() + 1,
    D: date.getDate(),
    m: 0,
    s: 0,
    S: 0,
    a: "AM"
  };
  let formatIdx = 0;
  let delimited = true;
  for (var i = 0, len = aString.length; i < len && formatIdx < aFormat.length;) {
    // skip whitespaces and get format portion (e.g. "MMM")
    let iterFormatIdx = formatIdx;
    while (formatIdx < aFormat.length && aFormat.charAt(formatIdx).match(/\s/)) ++formatIdx;
    if (iterFormatIdx === formatIdx && aFormat.substr(formatIdx, 2) === ", " && !aString.substr(i).match(/\s*,/)) {
      // treat "," character in ", " sequence in format string as omittable => continue
      formatIdx += 2;
      while (formatIdx < aFormat.length && aFormat.charAt(formatIdx).match(/\s/)) ++formatIdx;
    }

    // skip whitespaces
    let iterI = i;
    while (i < len && aString.charAt(i).match(/\s/)) ++i;
    if (iterI < i) delimited = true;
    if (i == len) break;

    // if there were whitespaces in format then require at least 1 whitespace in parsed string too
    // (otherwise "D.M.Y H" vs "1.1.2020" would match as 2-digit year and 2-digit hour)
    if (formatIdx - iterFormatIdx > 0 && !delimited) return null;
    delimited = false;
    if (formatIdx == aFormat.length) break;
    let formatLen = formatIdx;
    let formatChar = aFormat.charAt(formatIdx++);
    if (formatChar === "[") {
      let endIndex = aFormat.substr(formatIdx).search(/\]|$/) + formatIdx;
      if (aFormat.charAt(endIndex) !== "]") return null; // unterminated '[...' escaping sequence
      formatLen = endIndex - formatIdx;
    } else {
      while (formatIdx < aFormat.length && aFormat.charAt(formatIdx) == formatChar) ++formatIdx;
      formatLen = formatIdx - formatLen;
    }
    switch (formatChar) {
      case "[":
        {
          if (aString.substr(i, formatLen) !== aFormat.substr(formatIdx, formatLen)) return null; // unmatched escaping sequence
          i += formatLen;
          formatIdx += formatLen + 1;
          delimited = true;
          break;
        }
      case "A":
      case "a":
        {
          let items = [];
          for (let dayPeriod of ["long", "short", "narrow"]) {
            let formatter = new Intl.DateTimeFormat(locale, {
              hourCycle: "h12",
              timeZone: "UTC",
              dayPeriod,
              hour: "numeric"
            });
            items.push({
              value: "AM",
              part: formatter.formatToParts(Date.UTC(2020, 1, 1, 5, 0, 0, 0)).filter(it => it.type === "dayPeriod")[0]
            });
            items.push({
              value: "PM",
              part: formatter.formatToParts(Date.UTC(2020, 1, 1, 17, 0, 0, 0)).filter(it => it.type === "dayPeriod")[0]
            });
          }
          // add "AM", "PM" as fallbacks
          items.push({
            value: "AM",
            part: {
              type: "dayPeriod",
              value: "AM"
            }
          });
          items.push({
            value: "PM",
            part: {
              type: "dayPeriod",
              value: "PM"
            }
          });
          items = items.filter(it => it.part && it.part.value).sort((a, b) => b.part.value.length - a.part.value.length);
          let item = items.find(it => aString.substr(i, it.part.value.length).toLowerCase() === it.part.value.toLowerCase());
          if (!item) return null; // AM/PM (or locale-specific day period) not found
          i += item.part.value.length;
          val.a = item.value;
          break;
        }
      case "d":
        if (formatLen >= 2) {
          let formatter = new Intl.DateTimeFormat(locale, {
            weekday: formatLen >= 4 ? "long" : "short",
            timeZone: "UTC"
          });
          let weekdayNames = new Array(7).fill(0).map((_, index) => {
            let parts = formatter.formatToParts(Date.UTC(2020, index + 6, 1, 12, 0, 0, 0));
            let valuePart = parts.find(it => it.type === "weekday");
            let value = valuePart ? formatLen === 2 ? valuePart.value.substring(0, 2) : valuePart.value : "";
            return {
              index,
              value
            };
          });
          weekdayNames.sort((a, b) => b.value.length - a.value.length); // sort by length descending (we'll be matching by longest)
          let restString = aString.substr(i, weekdayNames[0].length).toLowerCase();
          let item = weekdayNames.find(it => it.value && restString.startsWith(it.value.toLowerCase()));
          if (!item) return null; // weekday name not matched
          i += item.value.length; // value is recognized but it is actually ignored for constructing Date object => skip recognized text
        } else {
          return null; // "d" not supported
        }

        break;
      case "M":
        if (formatLen >= 3) {
          let item;
          let dayOpts = [undefined];
          if (val.D) dayOpts.push({
            day: "numeric"
          }); // formatting month only (e.g. 'leden') vs. day+month (e.g. '2. ledna')
          for (let dayOpt of dayOpts) {
            let formatter = new Intl.DateTimeFormat(locale, {
              month: formatLen === 3 ? "short" : "long",
              timeZone: "UTC",
              ...dayOpt
            });
            let monthNames = new Array(12).fill(0).map((_, index) => {
              let parts = formatter.formatToParts(Date.UTC(2020, index, 1, 12, 0, 0, 0));
              let valuePart = parts.find(it => it.type === "month");
              return {
                index,
                value: valuePart ? valuePart.value : ""
              };
            });
            monthNames.sort((a, b) => b.value.length - a.value.length); // sort by length descending (we'll be matching by longest)
            let restString = aString.substr(i, monthNames[0].length).toLowerCase();
            item = monthNames.find(it => it.value && restString.startsWith(it.value.toLowerCase()));
            if (item) break;
          }
          if (!item) return null; // month name not matched
          val.M = item.index + 1;
          i += item.value.length;
          break;
        }
      // else fall through
      case "Y":
      case "D":
      case "W": // NOTE Parsed as number but ignored.
      case "E": // NOTE Parsed as number but ignored.
      case "H":
      case "h":
      case "k":
      case "K":
      case "m":
      case "s":
      case "S":
        {
          let digitCount = aString.substr(i).search(/\D|$/);
          let nextI = formatLen > 1 ? i + Math.min(formatLen, digitCount) : i + digitCount;
          let s = aString.substr(i, nextI - i);
          if (!s) return null; // expecting number but got no digits
          if (formatLen === 2 && s.length !== 2) return null; // expected 2-digit value but got different digit count
          let n = parseInt(s, 10);
          if (formatChar === "Y" && formatLen === 2) {
            let maxYear = 2050; // based on https://www.fxsitecompat.dev/en-CA/docs/2016/date-parse-handling-of-2-digit-years-has-been-changed-to-be-chrome-compatible/
            let cy = date.getFullYear();
            cy -= cy % 100;
            n = cy + n > maxYear ? cy + n - 100 : cy + n;
          } else if (formatChar === "S") {
            n = parseInt(s.substr(0, 3), 10) * Math.pow(10, Math.max(0, 3 - s.length));
          }
          val[formatChar] = n;
          i = nextI;
          break;
        }
      default:
        if (formatChar === "," && formatLen === 1 && aFormat.charAt(formatIdx) === " ") {
          // treat "," character in ", " sequence in format string as omittable => continue
          if (aString.charAt(i) === ",") i++;
        } else {
          delimited = true;
          for (let j = 0; j < formatLen && i < len; ++i) {
            let c = aString.charAt(i);
            if (c != formatChar) return null; // format contains different character than the input
            ++j;
          }
        }
    }
  }
  if (i < len) return null;
  // allow residual unmatched characters in formatting string such as '.' or ':'
  if (formatIdx < aFormat.length && !aFormat.substr(formatIdx).match(/^[.:,\s]+$/)) {
    return null;
  }

  // check values
  if (!val.M || val.M > 12) return null; // invalid month
  let y = val.Y;
  let monthDays = [31, y % 400 == 0 || y % 4 == 0 && y % 100 != 0 ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  if (!val.D || val.D > monthDays[val.M - 1]) return null; // invalid day
  if (val.H != null && (val.H > 24 || val.H == 24 && (val.m || val.s || val.S))) return null; // invalid hour (0-23, with allowed 24:00:00.000)
  if (val.k != null && (val.k < 1 || val.k > 24)) return null; // invalid hour (1-24)
  if (val.h != null && (val.h < 1 || val.h > 12)) return null; // invalid hour (1-12)
  if (val.K != null && val.K > 11) return null; // invalid hour (0-11)
  if (val.m != null && val.m >= 60) return null;
  if (val.s != null && val.s >= 60) return null;
  if (val.S != null && val.S >= 1000) return null;

  // everything OK => return
  let hour = val.H != null ? val.H : val.k != null ? val.k % 24 : val.h != null ? val.h % 12 + (val.a === "AM" ? 0 : 12) : val.K != null ? val.K + (val.a === "AM" ? 0 : 12) : 0;
  return [val.Y, val.M, val.D, hour, val.m, val.s, val.S];
}
function safeStringify(obj) {
  try {
    return JSON.stringify(obj);
  } catch (e) {
    return e && typeof e.toString === "function" ? e.toString() : e + "";
  }
}
function getUtcMillis(year, month, day, hour, minute, second, millisecond) {
  if (year < 100 && year >= 0) {
    let date = new Date(Date.UTC(year, 0, 1, 0, 0, 0, 0)); // if year < 100 then this actually makes year 1920 which we don't want
    date.setUTCFullYear(year, month - 1, day);
    date.setUTCHours(hour, minute, second, millisecond);
    return date.getTime();
  } else {
    return Date.UTC(year, month - 1, day, hour, minute, second, millisecond);
  }
}
function getJsDate(year, month = 1, day = 1, hour = 0, minute = 0, second = 0, millisecond = 0) {
  let date;
  if (year < 100 && year >= 0) {
    // NOTE Not passing year/month/... to constructor directly because years 0-99 are handled as 1900+year (which we don't want).
    date = new Date(2000, 0, 1, 12, 0, 0, 0);
    date.setFullYear(year, month - 1, day);
    date.setHours(hour, minute, second, millisecond);
  } else {
    date = new Date(year, month - 1, day, hour, minute, second, millisecond);
  }
  return date;
}
module.exports = {
  parseDate,
  parseTime,
  parseDateTime,
  parseWeekDate,
  safeStringify,
  getUtcMillis,
  getJsDate,
  getWeek,
  getWeekDay,
  getWeekYear
};

/***/ }),

/***/ "./uu-date-time.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const UuDate = __webpack_require__("./uu-date.js");
const {
  customFormat
} = __webpack_require__("./internal/custom-format.js");
const {
  parseDate,
  parseTime,
  parseDateTime,
  safeStringify,
  getUtcMillis,
  parseWeekDate
} = __webpack_require__("./internal/util.js");
const INVALID_DATE = new Date("invalid");
const formatterMap = {};
let osTimeZone;
class UuDateTime {
  static now() {
    return new UuDateTime();
  }
  static utc() {
    return new UuDateTime(undefined, "UTC");
  }
  static parse(stringOr2StringArray, locale, timeZone, format = undefined) {
    let parsed;
    if (Array.isArray(stringOr2StringArray)) {
      let date = parseDate(stringOr2StringArray[0], locale, Array.isArray(format) ? format[0] : undefined);
      let time = parseTime(stringOr2StringArray[1], locale, Array.isArray(format) ? format[1] : undefined);
      parsed = date != null && time != null ? date.concat(time) : null;
    } else {
      parsed = parseDateTime(stringOr2StringArray, locale, format);
    }
    return parsed != null ? new UuDateTime(parsed, timeZone) : null;
  }
  static compare(uuDateTime1, uuDateTime2) {
    return uuDateTime1.getTime() - uuDateTime2.getTime();
  }
  constructor(value, timeZone = undefined) {
    let date, year, month, day, hour, minute, second, millisecond, timeZoneSpec;
    let fields;
    if (typeof value === "number") {
      date = new Date(value);
    } else if (value instanceof UuDateTime) {
      date = new Date(value.getTime());
      // if timeZone === null then use OS-specific, use value's timeZone only if ours is undefined
      if (timeZone === undefined) {
        timeZone = value.getTimeZone();
        fields = value._fields ? {
          ...value._fields
        } : undefined;
      }
    } else if (value == null || value instanceof Date) {
      date = value ? new Date(value) : new Date(Date.now());
    } else {
      if (value instanceof UuDate) {
        year = value.getYear();
        month = value.getMonth();
        day = value.getDay();
        hour = minute = second = millisecond = 0;
      } else if (typeof value === "string") {
        let match = value.match(/^(\d{4})(?:-?(\d{2})(?:-?(\d{2})(?:T(\d{2})(?::?(\d{2})(?::?(\d{2})(?:\.(\d{1,3}))?)?)?)?)?)?(Z|[+-]\d{2}(?::?\d{2})?)?$/);
        if (match) {
          [, year, month, day, hour, minute, second, millisecond, timeZoneSpec] = match;
          if (millisecond) millisecond = millisecond.padEnd(3, "0");
          if (timeZoneSpec) {
            date = new Date(this._stringValuesToIso(year, month, day, hour, minute, second, millisecond, timeZoneSpec));
          }
        } else {
          let parsedDate = parseWeekDate(value);
          if (parsedDate) {
            [year, month, day] = parsedDate;
          } else {
            throw new Error("Invalid date string value '" + value + "'. Only ISO format or ISO week date format is supported, e.g. '2020-10-22T10:30:00.000Z' or '2020-W35-1'.");
          }
        }
      } else if (Array.isArray(value)) {
        [year, month, day, hour, minute, second, millisecond] = value;
      } else if (typeof value === "object") {
        ({
          year,
          month,
          day,
          hour,
          minute,
          second,
          millisecond
        } = value);
      } else {
        throw new Error("Unsupported date value: " + value);
      }
    }
    if (!timeZone) timeZone = this._getOsTimeZone();
    if (date == null) {
      [date, fields] = this._dateFromTimeZone(year, month, day, hour, minute, second, millisecond, timeZone);
    }
    if (isNaN(date.getDate())) throw new Error("Invalid date: " + safeStringify(value));
    this.date = date;
    this.timeZone = timeZone;
    this._fields = fields;
  }
  getTimeZone() {
    return this.timeZone;
  }
  setTimeZone(timeZone) {
    let newTimeZone = timeZone || this._getOsTimeZone();
    if (newTimeZone !== this.timeZone) {
      this.timeZone = newTimeZone;
      delete this._fields;
    }
    return this;
  }
  getYear() {
    var _this$_fields;
    (_this$_fields = this._fields) !== null && _this$_fields !== void 0 ? _this$_fields : this._fields = this._getPartsFromFormattedValue(this.date);
    return this._fields.year;
  }
  getMonth() {
    var _this$_fields2;
    (_this$_fields2 = this._fields) !== null && _this$_fields2 !== void 0 ? _this$_fields2 : this._fields = this._getPartsFromFormattedValue(this.date);
    return this._fields.month;
  }
  getDay() {
    var _this$_fields3;
    (_this$_fields3 = this._fields) !== null && _this$_fields3 !== void 0 ? _this$_fields3 : this._fields = this._getPartsFromFormattedValue(this.date);
    return this._fields.day;
  }
  getHour() {
    var _this$_fields4;
    (_this$_fields4 = this._fields) !== null && _this$_fields4 !== void 0 ? _this$_fields4 : this._fields = this._getPartsFromFormattedValue(this.date);
    return this._fields.hour;
  }
  getMinute() {
    var _this$_fields5;
    (_this$_fields5 = this._fields) !== null && _this$_fields5 !== void 0 ? _this$_fields5 : this._fields = this._getPartsFromFormattedValue(this.date);
    return this._fields.minute;
  }
  getSecond() {
    var _this$_fields6;
    (_this$_fields6 = this._fields) !== null && _this$_fields6 !== void 0 ? _this$_fields6 : this._fields = this._getPartsFromFormattedValue(this.date);
    return this._fields.second;
  }
  getMillisecond() {
    var _this$_fields7;
    (_this$_fields7 = this._fields) !== null && _this$_fields7 !== void 0 ? _this$_fields7 : this._fields = this._getPartsFromFormattedValue(this.date);
    return this._fields.millisecond;
  }
  getWeek(weekStartDay = 1) {
    let year = this.getYear();
    let month = this.getMonth();
    let day = this.getDay();
    return new UuDate([year, month, day]).getWeek(weekStartDay);
  }
  getWeekDay() {
    let year = this.getYear();
    let month = this.getMonth();
    let day = this.getDay();
    return new UuDate([year, month, day]).getWeekDay();
  }
  getWeekYear(weekStartDay = 1) {
    let year = this.getYear();
    let month = this.getMonth();
    let day = this.getDay();
    return new UuDate([year, month, day]).getWeekYear(weekStartDay);
  }
  getTime() {
    return this.date.getTime();
  }
  getTimeZoneOffset() {
    return Math.round((getUtcMillis(this.getYear(), this.getMonth(), this.getDay(), this.getHour(), this.getMinute(), this.getSecond(), this.getMillisecond()) - this.getTime()) / 60000);
  }
  isSameYear(uuDateTime) {
    if (!(uuDateTime instanceof UuDateTime)) return false;
    let uuDateTimeInTZ = uuDateTime.timeZone === this.timeZone ? uuDateTime : new UuDateTime(uuDateTime, this.timeZone);
    return this.getYear() === uuDateTimeInTZ.getYear();
  }
  isSameMonth(uuDateTime) {
    if (!(uuDateTime instanceof UuDateTime)) return false;
    let uuDateTimeInTZ = uuDateTime.timeZone === this.timeZone ? uuDateTime : new UuDateTime(uuDateTime, this.timeZone);
    return this.getMonth() === uuDateTimeInTZ.getMonth();
  }
  isSameMonthYear(uuDateTime) {
    if (!(uuDateTime instanceof UuDateTime)) return false;
    let uuDateTimeInTZ = uuDateTime.timeZone === this.timeZone ? uuDateTime : new UuDateTime(uuDateTime, this.timeZone);
    return this.getMonth() === uuDateTimeInTZ.getMonth() && this.getYear() === uuDateTimeInTZ.getYear();
  }
  isSameWeek(uuDateTime, weekStartDay = 1) {
    if (!(uuDateTime instanceof UuDateTime)) return false;
    let uuDateTimeInTZ = uuDateTime.timeZone === this.timeZone ? uuDateTime : new UuDateTime(uuDateTime, this.timeZone);
    return this.getWeek(weekStartDay) === uuDateTimeInTZ.getWeek(weekStartDay);
  }
  isSameWeekYear(uuDateTime, weekStartDay = 1) {
    if (!(uuDateTime instanceof UuDateTime)) return false;
    let uuDateTimeInTZ = uuDateTime.timeZone === this.timeZone ? uuDateTime : new UuDateTime(uuDateTime, this.timeZone);
    let date1 = new UuDate([this.getYear(), this.getMonth(), this.getDay()]);
    let date2 = new UuDate([uuDateTimeInTZ.getYear(), uuDateTimeInTZ.getMonth(), uuDateTimeInTZ.getDay()]);
    return date1.isSameWeekYear(date2, weekStartDay);
  }
  isToday() {
    let today = new UuDateTime(undefined, this.timeZone);
    return this.getDay() === today.getDay() && this.getMonth() === today.getMonth() && this.getYear() === today.getYear();
  }
  setYear(...newValues) {
    let [date, fields] = this._getUpdatedDate(...newValues);
    if (isNaN(date.getDate())) throw new Error("Invalid setYear() parameters: " + safeStringify(newValues));
    this.date = date;
    this._fields = fields;
    return this;
  }
  setMonth(...newValues) {
    let [date, fields] = this._getUpdatedDate(undefined, ...newValues);
    if (isNaN(date.getDate())) throw new Error("Invalid setMonth() parameters: " + safeStringify(newValues));
    this.date = date;
    this._fields = fields;
    return this;
  }
  setDay(...newValues) {
    let [date, fields] = this._getUpdatedDate(undefined, undefined, ...newValues);
    if (isNaN(date.getDate())) throw new Error("Invalid setDay() parameters: " + safeStringify(newValues));
    this.date = date;
    this._fields = fields;
    return this;
  }
  setHour(...newValues) {
    let [date, fields] = this._getUpdatedDate(undefined, undefined, undefined, ...newValues);
    if (isNaN(date.getDate())) throw new Error("Invalid setHour() parameters: " + safeStringify(newValues));
    this.date = date;
    this._fields = fields;
    return this;
  }
  setMinute(...newValues) {
    let [date, fields] = this._getUpdatedDate(undefined, undefined, undefined, undefined, ...newValues);
    if (isNaN(date.getDate())) throw new Error("Invalid setMinute() parameters: " + safeStringify(newValues));
    this.date = date;
    this._fields = fields;
    return this;
  }
  setSecond(second, millisecond) {
    // optimization - assume that second / millisecond have no impact on DST / timeZone offsetting and simply set the values
    if (second >= 0 && second <= 59 && Math.floor(second) === second && (millisecond === undefined || millisecond >= 0 && millisecond <= 999 && Math.floor(millisecond) === millisecond)) {
      let date = new Date(this.date);
      date.setSeconds(second);
      if (this._fields) this._fields.second = second;
      if (millisecond !== undefined) {
        date.setMilliseconds(millisecond);
        if (this._fields) this._fields.millisecond = millisecond;
      }
      this.date = date;
    } else {
      // prettier-ignore
      let [date, fields] = this._getUpdatedDate(undefined, undefined, undefined, undefined, undefined, second, millisecond);
      if (isNaN(date.getDate())) throw new Error("Invalid setSecond() parameters: " + safeStringify([second, millisecond]));
      this.date = date;
      this._fields = fields;
    }
    return this;
  }
  setMillisecond(millisecond) {
    // optimization - assume that second / millisecond have no impact on DST / timeZone offsetting and simply set the values
    // NOTE This optimization is possible because we're always ending up on the upper bound of DST change, i.e.
    // if we have Europe/Prague:
    // a) 2020-03-29 01:59:59.999 +1ms -> 03:00:00.000 (upper bound) +1ms -> 03:00:00.001
    // b) 2020-03-29 01:59:59.999 +1ms -> 02:00:00.000 (lower bound) +1ms -> 03:00:00.001 - this case would need safer optimization
    //    because going from 001 millisecond back to 000 could change hour too.
    // NOTE We're assuming that DST change is rounded to minutes.
    if (millisecond >= 0 && millisecond <= 999 && Math.floor(millisecond) === millisecond) {
      let date = new Date(this.date);
      date.setMilliseconds(millisecond);
      this.date = date;
      if (this._fields) this._fields.millisecond = millisecond;
    } else {
      // prettier-ignore
      let [date, fields] = this._getUpdatedDate(undefined, undefined, undefined, undefined, undefined, undefined, millisecond);
      if (isNaN(date.getDate())) throw new Error("Invalid setMillisecond() parameters: " + safeStringify([millisecond]));
      this.date = date;
      this._fields = fields;
    }
    return this;
  }
  setTime(newValue) {
    let date = new Date(newValue);
    if (isNaN(date.getDate())) throw new Error("Invalid setTime() parameters: " + safeStringify([newValue]));
    this.date = date;
    delete this._fields;
    return this;
  }
  shiftYear(yearOffset) {
    if (typeof yearOffset !== "number") throw new Error("Invalid shift offset (must be number): " + yearOffset);
    let adjustedDateTime = this.clone();
    adjustedDateTime.setYear(adjustedDateTime.getYear() + yearOffset);
    if (adjustedDateTime.getDay() !== this.getDay()) {
      // shifting resulted in invalid date that bled out to next month, e.g. 29.02.2020 + 1year -> 29.02.2021 (i.e. 01.03.2021) => move back
      adjustedDateTime.setDay(0, this.getHour(), this.getMinute(), this.getSecond(), this.getMillisecond());
    }
    this.date = adjustedDateTime.date;
    this._fields = adjustedDateTime._fields;
    return this;
  }
  shiftMonth(monthOffset) {
    if (typeof monthOffset !== "number") throw new Error("Invalid shift offset (must be number): " + monthOffset);
    let adjustedDateTime = this.clone();
    adjustedDateTime.setMonth(adjustedDateTime.getMonth() + monthOffset);
    if (adjustedDateTime.getDay() !== this.getDay()) {
      // shifting resulted in invalid date that bled out to next month, e.g. 31.03. + 1month -> 31.04. (i.e. 01.05.) => move back
      adjustedDateTime.setDay(0, this.getHour(), this.getMinute(), this.getSecond(), this.getMillisecond());
    }
    this.date = adjustedDateTime.date;
    this._fields = adjustedDateTime._fields;
    return this;
  }
  shiftDay(dayOffset) {
    if (typeof dayOffset !== "number") throw new Error("Invalid shift offset (must be number): " + dayOffset);
    return this.setDay(this.getDay() + dayOffset);
  }
  shiftTime(millisOffset) {
    if (typeof millisOffset !== "number") throw new Error("Invalid shift offset (must be number): " + millisOffset);
    return this.setTime(this.getTime() + millisOffset);
  }
  startOfYear() {
    return this.setMonth(1, 1, 0, 0, 0, 0);
  }
  endOfYear() {
    return this.setYear(this.getYear() + 1, 1, 1, 0, 0, 0, -1);
  }
  startOfMonth() {
    return this.setDay(1, 0, 0, 0, 0);
  }
  endOfMonth() {
    return this.setMonth(this.getMonth() + 1, 1, 0, 0, 0, -1);
  }
  startOfDay() {
    return this.setHour(0, 0, 0, 0);
  }
  endOfDay() {
    return this.setDay(this.getDay() + 1, 0, 0, 0, -1);
  }
  startOfWeek(weekStartDay = 1) {
    return this.setDay(this.getDay() - (this.getWeekDay() - weekStartDay + 7) % 7, 0, 0, 0, 0);
  }
  endOfWeek(weekStartDay = 1) {
    return this.setDay(this.getDay() + 7 - (this.getWeekDay() - weekStartDay + 7) % 7, 0, 0, 0, -1);
  }
  clone() {
    return new UuDateTime(this);
  }
  toString() {
    return this.toIsoString();
  }
  toIsoString() {
    return this.date.toISOString();
  }
  format(locale, intlFormatOptions) {
    let result;
    if (intlFormatOptions && typeof intlFormatOptions.format === "string") {
      let uuDateTime = intlFormatOptions.timeZone ? new UuDateTime(this, intlFormatOptions.timeZone) : this;
      result = customFormat(uuDateTime, intlFormatOptions.format, locale, uuDateTime.timeZone);
    } else {
      let hasDateFields = intlFormatOptions && ["year", "month", "day", "hour", "minute", "second", "fractionalSecond", "weekday", "era", "timeZoneName", "timeStyle", "dateStyle"].some(field => field in intlFormatOptions);
      let defaultOptions = {
        timeZone: this.timeZone
      };
      if (!hasDateFields) {
        Object.assign(defaultOptions, {
          year: "numeric",
          month: "numeric",
          day: "numeric",
          hour: "numeric",
          minute: "2-digit"
        });
      }
      result = new Intl.DateTimeFormat(locale, {
        ...defaultOptions,
        ...intlFormatOptions
      }).format(this.date);
    }
    return result;
  }
  toJSON() {
    return this.toIsoString();
  }
  toDate() {
    return new Date(this.date);
  }
  _getUpdatedDate(year = this.getYear(), month = this.getMonth(), day = this.getDay(), hour = this.getHour(), minute = this.getMinute(), second = this.getSecond(), millisecond = this.getMillisecond()) {
    return this._dateFromTimeZone(year, month, day, hour, minute, second, millisecond, this.timeZone);
  }
  _stringValuesToIso(year, month, day, hour, minute, second, millisecond, timezoneSpecifier) {
    let result = `${year}-${month || "01"}-${day || "01"}T${hour || "00"}:${minute || "00"}:${second || "00"}.${millisecond || "000"}${timezoneSpecifier}`;
    return result;
  }
  _dateFromTimeZone(year, month, day, hour, minute, second, millisecond, timeZone) {
    [year, month, day, hour, minute, second, millisecond] = this._normalizeWithDefaults(year, month, day, hour, minute, second, millisecond);
    let date;
    let fields;
    // find time (millis) which when formatted using given timeZone gives values corresponding to year, month, ...
    let utcMillis = getUtcMillis(year, month, day, hour, minute, second, millisecond);
    let utc = new Date(utcMillis);
    if (isNaN(utc.getDate())) {
      date = INVALID_DATE;
    } else {
      let tzFormatter = this._getTimeZoneFormatter(timeZone);
      let [y, m, d, H, M, S, MS] = this._getPartsFromFormattedValueAsArray(utc, tzFormatter);
      let offset = getUtcMillis(y, m, d, H, M, S, MS) - utcMillis;
      let candidateMillis = utcMillis - offset;
      date = new Date(candidateMillis);
      [y, m, d, H, M, S, MS] = this._getPartsFromFormattedValueAsArray(date, tzFormatter);
      let expectedHour = utc.getUTCHours(); // can differ from `hour` if `hour` is outside of 0..23
      let expectedMinute = utc.getUTCMinutes();
      if (H !== expectedHour || M !== expectedMinute) {
        // used timeZone uses dynamic offset (summer/winter time; it may also mean that the target time
        // doesn't exist, e.g. 2020-03-29 02:30 doesn't exist in Europe/Prague timezone)
        // let log = [
        //   `## wanted (TZ: ${timeZone}): `,
        //   JSON.stringify([year, month, day, hour, minute, second, millisecond]),
        //   `\n#1 got    (TZ: ${timeZone}): `,
        //   JSON.stringify([y, m, d, H, M, S, MS]),
        //   `(${candidateMillis})`,
        // ];
        let fallbackCandidateMillis = candidateMillis;
        let diffCorrection = (expectedHour - H) * 60 + (expectedMinute - M);
        // if the mismatch occurred at day boundary, e.g. 1964-05-16T00:10 using "Europe/Instabul"
        // (tz offset changes from 00:00 to 01:00, i.e. 00:10 is invalid) then `expectedHour - H` might be -23 or 23
        // instead of 1 or -1 => handle overflows here
        if (diffCorrection < -12 * 60) diffCorrection += 24 * 60;else if (diffCorrection > 12 * 60) diffCorrection -= 24 * 60;
        candidateMillis += diffCorrection * 60 * 1000;
        date = new Date(candidateMillis);
        let [y2, m2, d2, H2, M2, S2, MS2] = this._getPartsFromFormattedValueAsArray(date, tzFormatter);
        // log.push(`\n#2 got    (TZ: ${timeZone}): `, JSON.stringify([y2, m2, d2, H2, M2, S2, MS2]), `(${candidateMillis})`);

        // fall back to the bigger of the two if it still doesn't match (i.e. time is invalid)
        if (H2 !== expectedHour || M2 !== expectedMinute) {
          candidateMillis = Math.max(candidateMillis, fallbackCandidateMillis);
          //   log.push(
          //     `\n## correction failed (invalid time), falling back to #${
          //       fallbackCandidateMillis === candidateMillis ? "1" : "2"
          //     }`
          //   );
          // } else {
          //   log.push(`\n## correction succeeded, using #${fallbackCandidateMillis === candidateMillis ? "1" : "2"}`);
          date = new Date(candidateMillis);
        }
        if (candidateMillis === fallbackCandidateMillis) {
          fields = {
            year: y,
            month: m,
            day: d,
            hour: H,
            minute: M,
            second: S,
            millisecond: MS
          };
        } else {
          fields = {
            year: y2,
            month: m2,
            day: d2,
            hour: H2,
            minute: M2,
            second: S2,
            millisecond: MS2
          };
        }
        // console.log(...log);
      } else {
        fields = {
          year: y,
          month: m,
          day: d,
          hour: H,
          minute: M,
          second: S,
          millisecond: MS
        };
      }
    }
    return [date, fields];
  }
  _normalizeWithDefaults(year, month, day, hour, minute, second, millisecond) {
    function process(value, defValue) {
      if (typeof value === "number") return value;
      if (value == null) return defValue;
      if (typeof value === "string" && value.match(/^\d+$/)) return Number(value);
      return NaN;
    }
    year = process(year, year);
    month = process(month, 1);
    day = process(day, 1);
    hour = process(hour, 0);
    minute = process(minute, 0);
    second = process(second, 0);
    millisecond = process(millisecond, 0);
    return [year, month, day, hour, minute, second, millisecond];
  }
  _getPartsFromFormattedValueAsArray(date, formatter) {
    let map = this._getPartsFromFormattedValue(date, formatter);
    let {
      year,
      month,
      day,
      hour,
      minute,
      second,
      millisecond
    } = map;
    return [year, month, day, hour, minute, second, millisecond];
  }
  _getPartsFromFormattedValue(date, formatter = this._getTimeZoneFormatter()) {
    let parts = formatter.formatToParts(date);
    let map = {};
    parts.forEach(part => {
      if (part.type !== "literal") map[part.type] = Number(part.value);
    });
    if (map.fractionalSecond != null) {
      map.millisecond = map.fractionalSecond;
      delete map.fractionalSecond;
    } else {
      // NOTE NodeJS (and possibly others) implementations of Intl don't support milliseconds (fractionalSecond) output
      // from formatToParts() yet.
      map.millisecond = date.getMilliseconds();
    }
    return map;
  }
  _getTimeZoneFormatter(timeZone = this.timeZone) {
    let formatter = formatterMap[timeZone];
    if (!formatter) {
      let formatterOptions = {
        calendar: "iso8601",
        numberingSystem: "latn",
        hourCycle: "h23",
        year: "numeric",
        month: "numeric",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        fractionalSecondDigits: 3,
        timeZone
      };
      formatterMap[timeZone] = formatter = new Intl.DateTimeFormat("en-US", formatterOptions);
    }
    return formatter;
  }
  _getOsTimeZone() {
    var _osTimeZone;
    return (_osTimeZone = osTimeZone) !== null && _osTimeZone !== void 0 ? _osTimeZone : osTimeZone = new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
}
module.exports = UuDateTime;

/***/ }),

/***/ "./uu-date.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {
  customFormat
} = __webpack_require__("./internal/custom-format.js");
const {
  parseDate,
  safeStringify,
  parseWeekDate,
  getWeekDay,
  getJsDate,
  getWeekYear,
  getWeek
} = __webpack_require__("./internal/util.js");
class UuDate {
  static now() {
    return new UuDate();
  }
  static utc() {
    let date = new Date(Date.now());
    return new UuDate({
      year: date.getUTCFullYear(),
      month: date.getUTCMonth() + 1,
      day: date.getUTCDate()
    });
  }
  static parse(string, locale, format = undefined) {
    let parsed = parseDate(string, locale, format);
    return parsed ? new UuDate(parsed) : parsed;
  }
  static compare(uuDate1, uuDate2) {
    return uuDate1.getYear() - uuDate2.getYear() || uuDate1.getMonth() - uuDate2.getMonth() || uuDate1.getDay() - uuDate2.getDay();
  }
  constructor(value) {
    let year, month, day, valid;
    if (value instanceof UuDate) {
      day = value.getDay();
      month = value.getMonth();
      year = value.getYear();
    } else if (value == null || value instanceof Date) {
      value = value || new Date(Date.now());
      day = value.getDate();
      month = value.getMonth() + 1;
      year = value.getFullYear();
    } else {
      var _month, _day;
      let allowOverflow;
      if (typeof value === "string") {
        let match = value.match(/^(\d{4})(?:-?(\d{2})(?:-?(\d{2}))?)?$/);
        if (match) {
          [, year, month, day] = match;
          year = Number(year);
          month = Number(month || "01");
          day = Number(day || "01");
          allowOverflow = false;
        } else {
          let parsedDate = parseWeekDate(value);
          if (parsedDate) {
            [year, month, day] = parsedDate;
            allowOverflow = true;
          } else {
            throw new Error("Invalid date string value '" + value + "'. Only ISO date-only format and week date format is supported, e.g. '2020-02-13', '20200201', '2020-W35-1' or '2020-W35'.");
          }
        }
      } else if (Array.isArray(value)) {
        [year, month, day] = value;
        allowOverflow = true;
      } else if (typeof value === "object") {
        ({
          year,
          month,
          day
        } = value);
        allowOverflow = true;
      } else {
        throw new Error("Unsupported date value: " + value);
      }
      ({
        year,
        month,
        day,
        valid
      } = this._computeValid(year, (_month = month) !== null && _month !== void 0 ? _month : 1, (_day = day) !== null && _day !== void 0 ? _day : 1, allowOverflow));
      if (!valid) throw new Error("Invalid date: " + safeStringify(value));
    }
    this.day = day;
    this.month = month;
    this.year = year;
  }
  getDay() {
    return this.day;
  }
  getMonth() {
    return this.month;
  }
  getYear() {
    return this.year;
  }
  getWeek(weekStartDay = 1) {
    return getWeek(this.year, this.month, this.day, weekStartDay);
  }
  getWeekDay() {
    return getWeekDay(this.year, this.month, this.day); // 1 <=> Monday, 7 <=> Sunday
  }

  getWeekYear(weekStartDay = 1) {
    return getWeekYear(this.year, this.month, this.day, weekStartDay);
  }
  isSameDate(uuDate) {
    if (!(uuDate instanceof UuDate)) return false;
    return this.getDay() === uuDate.getDay() && this.getMonth() === uuDate.getMonth() && this.getYear() === uuDate.getYear();
  }
  isSameWeek(uuDate, weekStartDay = 1) {
    if (!(uuDate instanceof UuDate)) return false;
    return this.getWeek(weekStartDay) === uuDate.getWeek(weekStartDay);
  }
  isSameWeekYear(uuDate, weekStartDay = 1) {
    if (!(uuDate instanceof UuDate)) return false;
    let date1 = new UuDate(this);
    let date2 = new UuDate(uuDate);
    date1.startOfWeek(weekStartDay);
    date2.startOfWeek(weekStartDay);
    return date1.isSameDate(date2);
  }
  isSameMonth(uuDate) {
    if (!(uuDate instanceof UuDate)) return false;
    return this.getMonth() === uuDate.getMonth();
  }
  isSameMonthYear(uuDate) {
    if (!(uuDate instanceof UuDate)) return false;
    return this.getMonth() === uuDate.getMonth() && this.getYear() === uuDate.getYear();
  }
  isSameYear(uuDate) {
    if (!(uuDate instanceof UuDate)) return false;
    return this.getYear() === uuDate.getYear();
  }
  setYear(newYear, newMonth = this.month, newDay = this.day) {
    let {
      valid,
      day,
      month,
      year
    } = this._computeValid(newYear, newMonth, newDay, true);
    if (!valid) throw new Error("Invalid year: " + newYear);
    this.day = day;
    this.month = month;
    this.year = year;
    return this;
  }
  setMonth(newMonth, newDay = this.day) {
    let {
      valid,
      day,
      month,
      year
    } = this._computeValid(this.year, newMonth, newDay, true);
    if (!valid) throw new Error("Invalid month: " + newMonth);
    this.day = day;
    this.month = month;
    this.year = year;
    return this;
  }
  setDay(newDay) {
    let {
      valid,
      day,
      month,
      year
    } = this._computeValid(this.year, this.month, newDay, true);
    if (!valid) throw new Error("Invalid day: " + newDay);
    this.day = day;
    this.month = month;
    this.year = year;
    return this;
  }

  /**
   * @deprecated
   */
  shiftDate(dayOffset) {
    return this.shiftDay(dayOffset);
  }
  shiftYear(yearOffset) {
    if (typeof yearOffset !== "number") throw new Error("Invalid shift offset (must be number): " + yearOffset);
    let adjustedDate = new UuDate(this);
    adjustedDate.setYear(adjustedDate.getYear() + yearOffset);
    if (adjustedDate.getDay() !== this.getDay()) {
      // shifting resulted in invalid date that bled out to next month, e.g. 29.02.2020 + 1year -> 29.02.2021 (i.e. 01.03.2021) => move back
      adjustedDate.setDay(0);
    }
    return this.setYear(adjustedDate.getYear(), adjustedDate.getMonth(), adjustedDate.getDay());
  }
  shiftMonth(monthOffset) {
    if (typeof monthOffset !== "number") throw new Error("Invalid shift offset (must be number): " + monthOffset);
    let adjustedDate = new UuDate(this);
    adjustedDate.setMonth(adjustedDate.getMonth() + monthOffset);
    if (adjustedDate.getDay() !== this.getDay()) {
      // shifting resulted in invalid date that bled out to next month, e.g. 31.03. + 1month -> 31.04. (i.e. 01.05.) => move back
      adjustedDate.setDay(0);
    }
    return this.setYear(adjustedDate.getYear(), adjustedDate.getMonth(), adjustedDate.getDay());
  }
  shiftDay(dayOffset) {
    if (typeof dayOffset !== "number") throw new Error("Invalid shift offset (must be number): " + dayOffset);
    return this.setDay(this.day + dayOffset);
  }
  startOfYear() {
    return this.setMonth(1, 1);
  }
  endOfYear() {
    return this.setYear(this.year + 1, 1, 0);
  }
  startOfMonth() {
    return this.setDay(1);
  }
  endOfMonth() {
    return this.setMonth(this.month + 1, 0);
  }
  startOfWeek(weekStartDay = 1) {
    return this.shiftDay(-((this.getWeekDay() - weekStartDay + 7) % 7));
  }
  endOfWeek(weekStartDay = 1) {
    return this.shiftDay(6 - (this.getWeekDay() - weekStartDay + 7) % 7);
  }
  toString() {
    return this.toIsoString();
  }
  toIsoString() {
    return (this.year + "").padStart(4, "0") + "-" + (this.month + "").padStart(2, "0") + "-" + (this.day + "").padStart(2, "0");
  }
  toIsoWeekString(omitDay = false) {
    // Monday is always first day of a ISO week
    return (this.getWeekYear() + "").padStart(4, "0") + "-W" + (this.getWeek() + "").padStart(2, "0") + (!omitDay ? "-" + this.getWeekDay() : "");
  }
  format(locale, intlFormatOptions) {
    let utcDateTime = new Date(this.toIsoString() + "T00:00:00.000Z");
    let result;
    if (intlFormatOptions && typeof intlFormatOptions.format === "string") {
      result = customFormat(this, intlFormatOptions.format, locale);
    } else {
      result = new Intl.DateTimeFormat(locale, {
        ...intlFormatOptions,
        timeZone: "UTC"
      }).format(utcDateTime);
    }
    return result;
  }
  toJSON() {
    return this.toIsoString();
  }
  toDate() {
    return getJsDate(this.year, this.month, this.day, 0, 0, 0, 0);
  }
  _computeValid(year, month, day, allowOverflow = false) {
    function process(value) {
      return value === parseInt(value) ? value : NaN;
    }
    let date = getJsDate(process(year), process(month), process(day), 12, 0, 0, 0);
    let resultDay = date.getDate();
    let resultMonth = date.getMonth() + 1;
    let resultYear = date.getFullYear();
    return {
      valid: !isNaN(resultDay) && (allowOverflow || resultDay === day && resultMonth === month && resultYear === year),
      year: resultYear,
      month: resultMonth,
      day: resultDay
    };
  }
}
module.exports = UuDate;

/***/ }),

/***/ "../target/webpack-tmp/index.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mod = __webpack_require__("module");
var isDoc = typeof document !== "undefined";
var uri = ((mod ? mod.uri : isDoc && (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName("script"), -1)[0] || {}).src) || "").toString();
uri = uri.split(/\//).slice(0, -1).join("/") + "/"; // runtime publicPath configuration required for proper linking of styles, background images, ...
var floatingVersion = "/1.0.0/";
if (uri.substr(-floatingVersion.length) === floatingVersion) uri = uri.substr(0, uri.length - floatingVersion.length) + "/1.6.1/";
__webpack_require__.p = (typeof process !== "undefined" && process.env && (process.env.NODE_ENV) || "development") === "test" && uri === "/" ? "file://" + eval("__filename").replace(/[^/\\]*$/, "") : uri;
module.exports = __webpack_require__("./index.js");
var ex = module.exports;
if (ex && typeof ex === "object") {
  if (!("version" in ex)) Object.defineProperty(ex, "version", {
    configurable: true,
    value: "1.6.1"
  });
  if (!("name" in ex)) Object.defineProperty(ex, "name", {
    configurable: true,
    value: "uu_i18ng01".split(/[\/\\]/).pop()
  });
  if (!("namespace" in ex)) Object.defineProperty(ex, "namespace", {
    configurable: true,
    value: "UuI18n"
  });
}

/***/ }),

/***/ "module":
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_module__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "";
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("../target/webpack-tmp/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});