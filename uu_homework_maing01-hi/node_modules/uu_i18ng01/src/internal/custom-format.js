function customFormat(uuDateOrTime, formatString, locale, timeZone) {
  let jsDate;
  if (uuDateOrTime.date) {
    jsDate = uuDateOrTime.date; // uuDateOrTime is UuDateTime
  } else {
    jsDate = new Date(uuDateOrTime.toIsoString() + "T00:00:00.000Z"); // uuDateOrTime is UuDate
    timeZone = "UTC";
  }

  let getPart = (intlOptions, partName = Object.keys(intlOptions)[0], skipNornmalize = false) => {
    let formatter = new Intl.DateTimeFormat(locale, { timeZone, ...intlOptions });
    let parts = formatter.formatToParts(jsDate);
    let part = parts.find((it) => it.type === partName);
    let value = part ? part.value : null;
    if (!skipNornmalize && value != null && value.match(/^\d+$/)) value = Number(value) + ""; // normalize, because e.g. formatting in en-US with { hour: "numeric" } still returns "02" and we want "2"
    if (value == null && partName === "fractionalSecond") {
      value = (jsDate.getMilliseconds() + "").padStart(3, "0").substr(0, intlOptions.fractionalSecondDigits);
    }
    return value;
  };

  // NOTE Ordering matters. First to match should be sooner in the map.
  // keys are based on moment formats - https://momentjs.com/docs/#/displaying/format/
  let supported = {
    YYYY: () => getPart({ year: "numeric" }),
    YY: () => getPart({ year: "2-digit" }),
    Y: () => getPart({ year: "numeric" }),
    // NOTE There's difference between formatting just month ('leden' in cs-CZ) vs day+month (e.g. '2. ledna') in Intl API.
    // For custom formatting, we'll be consistent with moment - they use month-only ('leden') in all cases.
    MMMM: () => getPart({ month: "long" }),
    MMM: () => getPart({ month: "short" }),
    MM: () => getPart({ month: "numeric" }).padStart(2, "0"),
    M: () => getPart({ month: "numeric" }),
    dddd: () => getPart({ weekday: "long" }),
    ddd: () => getPart({ weekday: "short" }),
    dd: () => getPart({ weekday: "short" }).substring(0, 2),
    DD: () => getPart({ day: "numeric" }).padStart(2, "0"),
    D: () => getPart({ day: "numeric" }),
    WW: () => (uuDateOrTime.getWeek() + "").padStart(2, "0"),
    W: () => uuDateOrTime.getWeek() + "",
    E: () => uuDateOrTime.getWeekDay() + "",
    HH: () => getPart({ hour: "numeric", hourCycle: "h23" }).padStart(2, "0"),
    H: () => getPart({ hour: "numeric", hourCycle: "h23" }),
    hh: () => getPart({ hour: "numeric", hourCycle: "h12" }).padStart(2, "0"),
    h: () => getPart({ hour: "numeric", hourCycle: "h12" }),
    KK: () => getPart({ hour: "numeric", hourCycle: "h11" }).padStart(2, "0"),
    K: () => getPart({ hour: "numeric", hourCycle: "h11" }),
    kk: () => getPart({ hour: "numeric", hourCycle: "h24" }).padStart(2, "0"),
    k: () => getPart({ hour: "numeric", hourCycle: "h24" }),
    AAA: () => getPart({ dayPeriod: "long", hour: "numeric", hourCycle: "h12" }).toUpperCase(),
    aaa: () => getPart({ dayPeriod: "long", hour: "numeric", hourCycle: "h12" }),
    AA: () => getPart({ dayPeriod: "short", hour: "numeric", hourCycle: "h12" }).toUpperCase(),
    aa: () => getPart({ dayPeriod: "short", hour: "numeric", hourCycle: "h12" }),
    A: () => getPart({ dayPeriod: undefined, hour: "numeric", hourCycle: "h12" }),
    a: () => getPart({ dayPeriod: undefined, hour: "numeric", hourCycle: "h12" }).toLowerCase(),
    mm: () => getPart({ minute: "numeric" }).padStart(2, "0"),
    m: () => getPart({ minute: "numeric" }),
    ss: () => getPart({ second: "numeric" }).padStart(2, "0"),
    s: () => getPart({ second: "numeric" }),
    "S+": (m) =>
      getPart({ second: "numeric", fractionalSecondDigits: Math.min(3, m.length) }, "fractionalSecond", true)
        .padStart(Math.min(3, m.length), "0")
        .padEnd(m.length, "0"),
    "\\[[^\\]]*\\]": (m) => m.substr(1, m.length - 2), // escaping support - values in brackets are to be left as-is
  };

  let regexp = "(" + Object.keys(supported).join("|") + ")";
  let result = formatString.replace(new RegExp(regexp, "g"), (m) => {
    let fn = supported[m];
    if (!fn) {
      for (let k in supported) {
        if (m.match(new RegExp("^(" + k + ")$"))) {
          fn = supported[k];
          break;
        }
      }
    }
    let result = fn(m);
    return result == null ? m : result;
  });
  return result;
}

module.exports = { customFormat };
