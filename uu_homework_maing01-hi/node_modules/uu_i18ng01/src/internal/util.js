const ANY_DATE = new Date(9e8 + 10); // 1970-01-11T10:00:00.010Z
const FORMATTER_OPTIONS = {
  calendar: "iso8601",
  numberingSystem: "latn",
};
const FORMAT_MAP = {
  year: "Y",
  month: "M",
  day: "D",
  h23: "H",
  h24: "k",
  h11: "K",
  h12: "h",
  minute: "m",
  second: "s",
  fractionalSecond: "S",
  dayPeriod: "A",
};

/**
 * Parses the given string as a date. Allows more relaxed date strings, e.g.
 * "15" would be interpreted as 15th of the actual month.
 *
 * @param aString The string to parse as a date.
 * @returns The [year, month, day] numeric array (or null if unable to parse).
 */
function parseDate(dateString, locale, format = undefined) {
  let strTrimmed = dateString != null ? dateString.trim() : dateString;
  if (!strTrimmed) return null;

  let result;
  if (format != null) {
    result = _parseByFormat(strTrimmed, format, locale);
  } else {
    // the most common case
    result = _parseByFormats(
      strTrimmed,
      _getFormats(locale, { year: "numeric", month: "numeric", day: "numeric" }),
      locale
    );
    if (!result) {
      result = _parseByFormats(strTrimmed, _getFormats(locale, { month: "numeric", day: "numeric" }), locale);
    }
    if (!result) result = _parseByFormats(strTrimmed, _getFormats(locale, { day: "numeric" }), locale);
    if (!result) result = _parseByFormat(strTrimmed, "Y-M-D", locale); // fall back to ISO-like (interpret year as full, not as 2-digit)
    if (!result) result = parseWeekDate(strTrimmed); // fall back to ISO week date
  }

  return result ? result.slice(0, 3) : null;
}

/**
 * Parses the given string as a time. Allows more relaxed date strings, e.g.
 * "15" would be interpreted as 15:00.
 *
 * @param aString The string to parse as a time.
 * @returns The [hour, minute, second, millisecond] numeric array (or null if unable to parse).
 */
function parseTime(timeString, locale, format = undefined) {
  let strTrimmed = timeString != null ? timeString.trim() : timeString;
  if (!strTrimmed) return null;

  let result;
  if (format != null) {
    result = _parseByFormat(strTrimmed, format, locale);
  } else {
    // most-common first
    result = _parseByFormats(strTrimmed, _getFormats(locale, { hour: "numeric", minute: "numeric" }), locale);
    if (!result) {
      result = _parseByFormats(
        strTrimmed,
        _getFormats(locale, { hour: "numeric", minute: "numeric", second: "numeric" }),
        locale
      );
    }
    if (!result) result = _parseByFormats(strTrimmed, _getFormats(locale, { hour: "numeric" }), locale);
    if (!result) result = _parseByFormat(strTrimmed, "H:m", locale); // fall back to ISO-like as the last resort if nothing matched
    if (!result) result = _parseByFormat(strTrimmed, "H:m:s", locale); // fall back to ISO-like as the last resort if nothing matched
    if (!result) result = _parseByFormat(strTrimmed, "H:m:s.S", locale); // fall back to ISO-like as the last resort if nothing matched
  }
  return result ? result.slice(3) : null;
}

function parseDateTime(dateTimeString, locale, format = undefined) {
  let strTrimmed = dateTimeString != null ? dateTimeString.trim() : dateTimeString;
  if (!strTrimmed) return null;

  let result;
  if (format != null) {
    result = _parseByFormat(strTrimmed, format, locale);
  } else {
    // most-common first
    result = _parseByFormats(
      strTrimmed,
      _getFormats(locale, { year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric" }),
      locale
    );
    if (!result) {
      result = _parseByFormats(
        strTrimmed,
        _getFormats(locale, {
          year: "numeric",
          month: "numeric",
          day: "numeric",
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
        }),
        locale
      );
    }
    if (!result) {
      result = _parseByFormats(
        strTrimmed,
        _getFormats(locale, {
          year: "numeric",
          month: "numeric",
          day: "numeric",
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          fractionalSecondDigits: 3,
        }),
        locale
      );
    }
    if (!result) {
      result = _parseByFormats(
        strTrimmed,
        _getFormats(locale, { month: "numeric", day: "numeric", hour: "numeric", minute: "numeric" }),
        locale
      );
    }
    if (!result) {
      result = _parseByFormats(
        strTrimmed,
        _getFormats(locale, { year: "numeric", month: "numeric", day: "numeric", hour: "numeric" }),
        locale
      );
    }
    if (!result) result = parseDate(dateTimeString, locale);
    if (!result) {
      let spaceIndex = dateTimeString.indexOf(" ");
      if (spaceIndex !== -1 && spaceIndex === dateTimeString.lastIndexOf(" ")) {
        if (!result) result = _parseByFormat(strTrimmed, "Y-M-D H:m", locale); // fall back to ISO-like as the last resort if nothing matched
        if (!result) result = _parseByFormat(strTrimmed, "Y-M-D H", locale); // fall back to ISO-like as the last resort if nothing matched
        if (!result) result = _parseByFormat(strTrimmed, "Y-M-D H:m:s", locale); // fall back to ISO-like as the last resort if nothing matched
        if (!result) result = _parseByFormat(strTrimmed, "Y-M-D H:m:s.S", locale); // fall back to ISO-like as the last resort if nothing matched
      }
      if (!result && spaceIndex !== -1) {
        let dateStr = dateTimeString.slice(0, spaceIndex);
        let timeStr = dateTimeString.slice(spaceIndex + 1).trim();
        let dateResult = parseDate(dateStr, locale);
        if (dateResult) {
          let timeResult = parseTime(timeStr, locale);
          if (timeResult) {
            result = [dateResult[0], dateResult[1], dateResult[2], ...timeResult];
          }
        }
      }
    }
    if (!result) {
      result = parseTime(dateTimeString, locale);
      if (result) {
        let now = new Date(Date.now());
        result = [now.getFullYear(), now.getMonth() + 1, now.getDate(), ...result];
      }
    }
  }
  return result ? result : null;
}

function parseWeekDate(string) {
  let result;
  let match = string.match(/^(\d{4})-W(\d{2})(?:-([1-7]))?$/);
  if (match) {
    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_an_ordinal_or_month_date_from_a_week_date
    let weekYear = Number(match[1]);
    let week = Number(match[2]);
    let weekDay = match[3] ? Number(match[3]) : 1;
    let dayOfYear = week * 7 + weekDay - (getWeekDay(weekYear, 1, 4) + 3);
    let potentialResult = [weekYear, 1, dayOfYear]; // dayOfYear can be <=0 or >356 but that will be normalized by new Date(...) automatically
    // use the result only if it didn't overflow, e.g. disallow 2020-W99-1 (week 99)
    if (
      getWeekYear(...potentialResult) === weekYear &&
      getWeek(...potentialResult) === week &&
      (!match[3] || getWeekDay(...potentialResult) === weekDay)
    ) {
      result = potentialResult;
    }
  }
  return result;
}

function getWeek(year, month, day, weekStartDay = 1) {
  let d = getJsDate(year, month, day);
  let dayOffset = (d.getDay() || 7) - (weekStartDay - 1);
  if (dayOffset <= 0) dayOffset += 7;
  d.setDate(d.getDate() + 4 - dayOffset);
  return Math.ceil(((d - getJsDate(d.getFullYear())) / 8.64e7 + 1) / 7);
}

function getWeekYear(year, month, day, weekStartDay = 1) {
  let week = getWeek(year, month, day, weekStartDay);
  // for 2022/01/01 it could return year 2022 and week 53
  // or for 2021/12/31 it could return year 2021 and week 01

  // we need to check and fix if it is last week of the last year of first week of the next year
  let weekDay = getWeekDay(year, month, day);
  let dayOffset = weekStartDay - weekDay;
  if (dayOffset > 0) dayOffset -= 7; // if dayOffset is positive then we will shift into the future, but we always need to shift into the past
  let jsDate = getJsDate(year, month, day, 12);
  jsDate.setDate(jsDate.getDate() + dayOffset);
  let startWeekYear = jsDate.getFullYear();
  jsDate.setDate(jsDate.getDate() + 6);
  let endWeekYear = jsDate.getFullYear();
  if (startWeekYear !== endWeekYear) {
    if (startWeekYear === year && week === 1) {
      // it is first week of the next year
      year++;
    } else if (endWeekYear === year && week !== 1) {
      // it is last week of the previous year
      year--;
    }
  }

  return year;
}

function getWeekDay(year, month, day) {
  let date = new Date(getUtcMillis(year, month, day, 12, 0, 0, 0));
  let index = date.getUTCDay(); // 0 <=> Sunday, 1 <=> Monday
  return index || 7; // 7 <=> Sunday, 1 <=> Monday
}

// returns e.g. "d.M.y H:mm" or "M/d/y, h:mm a", depending on locale
function _getFormat(locale, fields) {
  let options = { ...FORMATTER_OPTIONS, ...fields };
  let formatter = new Intl.DateTimeFormat(locale, options);
  let resolvedOptions = formatter.resolvedOptions();
  let parts = formatter.formatToParts(ANY_DATE);
  let strParts = parts.map(({ type, value }) => {
    if (type === "literal") return value;
    let fieldOption = fields[type];
    let formatChar = FORMAT_MAP[type === "hour" ? resolvedOptions.hourCycle : type];
    if (!formatChar) {
      if (process.env.NODE_ENV === "test") {
        console.warn(`Unrecognized formatting part '${type}' when parsing date/time using locale '${locale}'.`);
      }
      return ""; // shouldn't happen
    }
    let result = fieldOption === "2-digit" ? formatChar + formatChar : formatChar;
    if (type === "month") {
      if (fieldOption === "long") result = "".padStart(4, formatChar);
      else if (fieldOption === "short") result = "".padStart(3, formatChar);
    }

    // NodeJS < 14.8.0 doesn't support "fractionalSecond" even with full-icu => add it manually
    if (type === "second" && options.fractionalSecondDigits > 0 && !("fractionalSecondDigits" in resolvedOptions)) {
      let numberParts = new Intl.NumberFormat(locale, { minimumFractionDigits: 1 }).formatToParts(0.5);
      let decimalPointPart = numberParts.find((it) => it.type === "decimal");
      if (decimalPointPart) result += decimalPointPart.value + FORMAT_MAP["fractionalSecond"];
    }
    return result;
  });
  let result = strParts.join("");
  if (parts.some((it) => it.type === "dayPeriod")) result = result.replace(/H+/g, "h");
  return result;
}
function _getFormats(locale, fields) {
  let formatsOpts = [fields];

  // if the format uses "month", we'll try any representation of month (e.g. name too)
  if ("month" in fields) {
    for (let month of ["long", "short", "numeric"]) {
      if (month !== fields.month) formatsOpts.push({ ...fields, month });
    }
  }

  // if a format uses "year", we'll try 2-digit variant automatically
  // (and it'll be checked first because otherwise full year would use the value too, as a full year)
  if ("year" in fields && fields.year !== "2-digit") {
    let extra = formatsOpts.map((it) => ({ ...it, year: "2-digit" }));
    formatsOpts = extra.concat(formatsOpts);
  }

  let result = formatsOpts.map((opts) => _getFormat(locale, opts));
  return result;
}

function _parseByFormats(aString, formatList, locale) {
  for (let format of formatList) {
    let result = _parseByFormat(aString, format, locale);
    if (result != null) return result;
  }
  return null;
}

function _parseByFormat(aString, aFormat, locale) {
  let date = new Date(Date.now());
  date.setHours(0, 0, 0, 0);
  // prettier-ignore
  let val = { Y: date.getFullYear(), M: date.getMonth() + 1, D: date.getDate(), m: 0, s: 0, S: 0, a: "AM" };
  let formatIdx = 0;
  let delimited = true;
  for (var i = 0, len = aString.length; i < len && formatIdx < aFormat.length; ) {
    // skip whitespaces and get format portion (e.g. "MMM")
    let iterFormatIdx = formatIdx;
    while (formatIdx < aFormat.length && aFormat.charAt(formatIdx).match(/\s/)) ++formatIdx;
    if (iterFormatIdx === formatIdx && aFormat.substr(formatIdx, 2) === ", " && !aString.substr(i).match(/\s*,/)) {
      // treat "," character in ", " sequence in format string as omittable => continue
      formatIdx += 2;
      while (formatIdx < aFormat.length && aFormat.charAt(formatIdx).match(/\s/)) ++formatIdx;
    }

    // skip whitespaces
    let iterI = i;
    while (i < len && aString.charAt(i).match(/\s/)) ++i;
    if (iterI < i) delimited = true;
    if (i == len) break;

    // if there were whitespaces in format then require at least 1 whitespace in parsed string too
    // (otherwise "D.M.Y H" vs "1.1.2020" would match as 2-digit year and 2-digit hour)
    if (formatIdx - iterFormatIdx > 0 && !delimited) return null;
    delimited = false;

    if (formatIdx == aFormat.length) break;
    let formatLen = formatIdx;
    let formatChar = aFormat.charAt(formatIdx++);
    if (formatChar === "[") {
      let endIndex = aFormat.substr(formatIdx).search(/\]|$/) + formatIdx;
      if (aFormat.charAt(endIndex) !== "]") return null; // unterminated '[...' escaping sequence
      formatLen = endIndex - formatIdx;
    } else {
      while (formatIdx < aFormat.length && aFormat.charAt(formatIdx) == formatChar) ++formatIdx;
      formatLen = formatIdx - formatLen;
    }

    switch (formatChar) {
      case "[": {
        if (aString.substr(i, formatLen) !== aFormat.substr(formatIdx, formatLen)) return null; // unmatched escaping sequence
        i += formatLen;
        formatIdx += formatLen + 1;
        delimited = true;
        break;
      }
      case "A":
      case "a": {
        let items = [];
        for (let dayPeriod of ["long", "short", "narrow"]) {
          let formatter = new Intl.DateTimeFormat(locale, {
            hourCycle: "h12",
            timeZone: "UTC",
            dayPeriod,
            hour: "numeric",
          });
          items.push({
            value: "AM",
            part: formatter.formatToParts(Date.UTC(2020, 1, 1, 5, 0, 0, 0)).filter((it) => it.type === "dayPeriod")[0],
          });
          items.push({
            value: "PM",
            part: formatter.formatToParts(Date.UTC(2020, 1, 1, 17, 0, 0, 0)).filter((it) => it.type === "dayPeriod")[0],
          });
        }
        // add "AM", "PM" as fallbacks
        items.push({ value: "AM", part: { type: "dayPeriod", value: "AM" } });
        items.push({ value: "PM", part: { type: "dayPeriod", value: "PM" } });
        items = items
          .filter((it) => it.part && it.part.value)
          .sort((a, b) => b.part.value.length - a.part.value.length);
        let item = items.find(
          (it) => aString.substr(i, it.part.value.length).toLowerCase() === it.part.value.toLowerCase()
        );
        if (!item) return null; // AM/PM (or locale-specific day period) not found
        i += item.part.value.length;
        val.a = item.value;
        break;
      }

      case "d":
        if (formatLen >= 2) {
          let formatter = new Intl.DateTimeFormat(locale, {
            weekday: formatLen >= 4 ? "long" : "short",
            timeZone: "UTC",
          });
          let weekdayNames = new Array(7).fill(0).map((_, index) => {
            let parts = formatter.formatToParts(Date.UTC(2020, index + 6, 1, 12, 0, 0, 0));
            let valuePart = parts.find((it) => it.type === "weekday");
            let value = valuePart ? (formatLen === 2 ? valuePart.value.substring(0, 2) : valuePart.value) : "";
            return { index, value };
          });
          weekdayNames.sort((a, b) => b.value.length - a.value.length); // sort by length descending (we'll be matching by longest)
          let restString = aString.substr(i, weekdayNames[0].length).toLowerCase();
          let item = weekdayNames.find((it) => it.value && restString.startsWith(it.value.toLowerCase()));
          if (!item) return null; // weekday name not matched
          i += item.value.length; // value is recognized but it is actually ignored for constructing Date object => skip recognized text
        } else {
          return null; // "d" not supported
        }
        break;

      case "M":
        if (formatLen >= 3) {
          let item;
          let dayOpts = [undefined];
          if (val.D) dayOpts.push({ day: "numeric" }); // formatting month only (e.g. 'leden') vs. day+month (e.g. '2. ledna')
          for (let dayOpt of dayOpts) {
            let formatter = new Intl.DateTimeFormat(locale, {
              month: formatLen === 3 ? "short" : "long",
              timeZone: "UTC",
              ...dayOpt,
            });
            let monthNames = new Array(12).fill(0).map((_, index) => {
              let parts = formatter.formatToParts(Date.UTC(2020, index, 1, 12, 0, 0, 0));
              let valuePart = parts.find((it) => it.type === "month");
              return { index, value: valuePart ? valuePart.value : "" };
            });
            monthNames.sort((a, b) => b.value.length - a.value.length); // sort by length descending (we'll be matching by longest)
            let restString = aString.substr(i, monthNames[0].length).toLowerCase();
            item = monthNames.find((it) => it.value && restString.startsWith(it.value.toLowerCase()));
            if (item) break;
          }
          if (!item) return null; // month name not matched
          val.M = item.index + 1;
          i += item.value.length;
          break;
        }
      // else fall through
      case "Y":
      case "D":
      case "W": // NOTE Parsed as number but ignored.
      case "E": // NOTE Parsed as number but ignored.
      case "H":
      case "h":
      case "k":
      case "K":
      case "m":
      case "s":
      case "S": {
        let digitCount = aString.substr(i).search(/\D|$/);
        let nextI = formatLen > 1 ? i + Math.min(formatLen, digitCount) : i + digitCount;
        let s = aString.substr(i, nextI - i);
        if (!s) return null; // expecting number but got no digits
        if (formatLen === 2 && s.length !== 2) return null; // expected 2-digit value but got different digit count
        let n = parseInt(s, 10);
        if (formatChar === "Y" && formatLen === 2) {
          let maxYear = 2050; // based on https://www.fxsitecompat.dev/en-CA/docs/2016/date-parse-handling-of-2-digit-years-has-been-changed-to-be-chrome-compatible/
          let cy = date.getFullYear();
          cy -= cy % 100;
          n = cy + n > maxYear ? cy + n - 100 : cy + n;
        } else if (formatChar === "S") {
          n = parseInt(s.substr(0, 3), 10) * Math.pow(10, Math.max(0, 3 - s.length));
        }
        val[formatChar] = n;
        i = nextI;
        break;
      }
      default:
        if (formatChar === "," && formatLen === 1 && aFormat.charAt(formatIdx) === " ") {
          // treat "," character in ", " sequence in format string as omittable => continue
          if (aString.charAt(i) === ",") i++;
        } else {
          delimited = true;
          for (let j = 0; j < formatLen && i < len; ++i) {
            let c = aString.charAt(i);
            if (c != formatChar) return null; // format contains different character than the input
            ++j;
          }
        }
    }
  }
  if (i < len) return null;
  // allow residual unmatched characters in formatting string such as '.' or ':'
  if (formatIdx < aFormat.length && !aFormat.substr(formatIdx).match(/^[.:,\s]+$/)) {
    return null;
  }

  // check values
  if (!val.M || val.M > 12) return null; // invalid month
  let y = val.Y;
  let monthDays = [31, y % 400 == 0 || (y % 4 == 0 && y % 100 != 0) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  if (!val.D || val.D > monthDays[val.M - 1]) return null; // invalid day
  if (val.H != null && (val.H > 24 || (val.H == 24 && (val.m || val.s || val.S)))) return null; // invalid hour (0-23, with allowed 24:00:00.000)
  if (val.k != null && (val.k < 1 || val.k > 24)) return null; // invalid hour (1-24)
  if (val.h != null && (val.h < 1 || val.h > 12)) return null; // invalid hour (1-12)
  if (val.K != null && val.K > 11) return null; // invalid hour (0-11)
  if (val.m != null && val.m >= 60) return null;
  if (val.s != null && val.s >= 60) return null;
  if (val.S != null && val.S >= 1000) return null;

  // everything OK => return
  let hour =
    val.H != null
      ? val.H
      : val.k != null
      ? val.k % 24
      : val.h != null
      ? (val.h % 12) + (val.a === "AM" ? 0 : 12)
      : val.K != null
      ? val.K + (val.a === "AM" ? 0 : 12)
      : 0;
  return [val.Y, val.M, val.D, hour, val.m, val.s, val.S];
}

function safeStringify(obj) {
  try {
    return JSON.stringify(obj);
  } catch (e) {
    return e && typeof e.toString === "function" ? e.toString() : e + "";
  }
}

function getUtcMillis(year, month, day, hour, minute, second, millisecond) {
  if (year < 100 && year >= 0) {
    let date = new Date(Date.UTC(year, 0, 1, 0, 0, 0, 0)); // if year < 100 then this actually makes year 1920 which we don't want
    date.setUTCFullYear(year, month - 1, day);
    date.setUTCHours(hour, minute, second, millisecond);
    return date.getTime();
  } else {
    return Date.UTC(year, month - 1, day, hour, minute, second, millisecond);
  }
}

function getJsDate(year, month = 1, day = 1, hour = 0, minute = 0, second = 0, millisecond = 0) {
  let date;
  if (year < 100 && year >= 0) {
    // NOTE Not passing year/month/... to constructor directly because years 0-99 are handled as 1900+year (which we don't want).
    date = new Date(2000, 0, 1, 12, 0, 0, 0);
    date.setFullYear(year, month - 1, day);
    date.setHours(hour, minute, second, millisecond);
  } else {
    date = new Date(year, month - 1, day, hour, minute, second, millisecond);
  }
  return date;
}

module.exports = {
  parseDate,
  parseTime,
  parseDateTime,
  parseWeekDate,
  safeStringify,
  getUtcMillis,
  getJsDate,
  getWeek,
  getWeekDay,
  getWeekYear,
};
