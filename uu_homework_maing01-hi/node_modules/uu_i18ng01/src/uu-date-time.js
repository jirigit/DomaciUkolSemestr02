const UuDate = require("./uu-date");
const { customFormat } = require("./internal/custom-format");
const { parseDate, parseTime, parseDateTime, safeStringify, getUtcMillis, parseWeekDate } = require("./internal/util");

const INVALID_DATE = new Date("invalid");

const formatterMap = {};
let osTimeZone;

class UuDateTime {
  static now() {
    return new UuDateTime();
  }

  static utc() {
    return new UuDateTime(undefined, "UTC");
  }

  static parse(stringOr2StringArray, locale, timeZone, format = undefined) {
    let parsed;
    if (Array.isArray(stringOr2StringArray)) {
      let date = parseDate(stringOr2StringArray[0], locale, Array.isArray(format) ? format[0] : undefined);
      let time = parseTime(stringOr2StringArray[1], locale, Array.isArray(format) ? format[1] : undefined);
      parsed = date != null && time != null ? date.concat(time) : null;
    } else {
      parsed = parseDateTime(stringOr2StringArray, locale, format);
    }
    return parsed != null ? new UuDateTime(parsed, timeZone) : null;
  }

  static compare(uuDateTime1, uuDateTime2) {
    return uuDateTime1.getTime() - uuDateTime2.getTime();
  }

  constructor(value, timeZone = undefined) {
    let date, year, month, day, hour, minute, second, millisecond, timeZoneSpec;
    let fields;
    if (typeof value === "number") {
      date = new Date(value);
    } else if (value instanceof UuDateTime) {
      date = new Date(value.getTime());
      // if timeZone === null then use OS-specific, use value's timeZone only if ours is undefined
      if (timeZone === undefined) {
        timeZone = value.getTimeZone();
        fields = value._fields ? { ...value._fields } : undefined;
      }
    } else if (value == null || value instanceof Date) {
      date = value ? new Date(value) : new Date(Date.now());
    } else {
      if (value instanceof UuDate) {
        year = value.getYear();
        month = value.getMonth();
        day = value.getDay();
        hour = minute = second = millisecond = 0;
      } else if (typeof value === "string") {
        let match = value.match(
          /^(\d{4})(?:-?(\d{2})(?:-?(\d{2})(?:T(\d{2})(?::?(\d{2})(?::?(\d{2})(?:\.(\d{1,3}))?)?)?)?)?)?(Z|[+-]\d{2}(?::?\d{2})?)?$/
        );
        if (match) {
          [, year, month, day, hour, minute, second, millisecond, timeZoneSpec] = match;
          if (millisecond) millisecond = millisecond.padEnd(3, "0");
          if (timeZoneSpec) {
            date = new Date(this._stringValuesToIso(year, month, day, hour, minute, second, millisecond, timeZoneSpec));
          }
        } else {
          let parsedDate = parseWeekDate(value);
          if (parsedDate) {
            [year, month, day] = parsedDate;
          } else {
            throw new Error(
              "Invalid date string value '" +
                value +
                "'. Only ISO format or ISO week date format is supported, e.g. '2020-10-22T10:30:00.000Z' or '2020-W35-1'."
            );
          }
        }
      } else if (Array.isArray(value)) {
        [year, month, day, hour, minute, second, millisecond] = value;
      } else if (typeof value === "object") {
        ({ year, month, day, hour, minute, second, millisecond } = value);
      } else {
        throw new Error("Unsupported date value: " + value);
      }
    }
    if (!timeZone) timeZone = this._getOsTimeZone();
    if (date == null) {
      [date, fields] = this._dateFromTimeZone(year, month, day, hour, minute, second, millisecond, timeZone);
    }
    if (isNaN(date.getDate())) throw new Error("Invalid date: " + safeStringify(value));
    this.date = date;
    this.timeZone = timeZone;
    this._fields = fields;
  }

  getTimeZone() {
    return this.timeZone;
  }

  setTimeZone(timeZone) {
    let newTimeZone = timeZone || this._getOsTimeZone();
    if (newTimeZone !== this.timeZone) {
      this.timeZone = newTimeZone;
      delete this._fields;
    }
    return this;
  }

  getYear() {
    this._fields ??= this._getPartsFromFormattedValue(this.date);
    return this._fields.year;
  }

  getMonth() {
    this._fields ??= this._getPartsFromFormattedValue(this.date);
    return this._fields.month;
  }

  getDay() {
    this._fields ??= this._getPartsFromFormattedValue(this.date);
    return this._fields.day;
  }

  getHour() {
    this._fields ??= this._getPartsFromFormattedValue(this.date);
    return this._fields.hour;
  }

  getMinute() {
    this._fields ??= this._getPartsFromFormattedValue(this.date);
    return this._fields.minute;
  }

  getSecond() {
    this._fields ??= this._getPartsFromFormattedValue(this.date);
    return this._fields.second;
  }

  getMillisecond() {
    this._fields ??= this._getPartsFromFormattedValue(this.date);
    return this._fields.millisecond;
  }

  getWeek(weekStartDay = 1) {
    let year = this.getYear();
    let month = this.getMonth();
    let day = this.getDay();
    return new UuDate([year, month, day]).getWeek(weekStartDay);
  }

  getWeekDay() {
    let year = this.getYear();
    let month = this.getMonth();
    let day = this.getDay();
    return new UuDate([year, month, day]).getWeekDay();
  }

  getWeekYear(weekStartDay = 1) {
    let year = this.getYear();
    let month = this.getMonth();
    let day = this.getDay();
    return new UuDate([year, month, day]).getWeekYear(weekStartDay);
  }

  getTime() {
    return this.date.getTime();
  }

  getTimeZoneOffset() {
    return Math.round(
      (getUtcMillis(
        this.getYear(),
        this.getMonth(),
        this.getDay(),
        this.getHour(),
        this.getMinute(),
        this.getSecond(),
        this.getMillisecond()
      ) -
        this.getTime()) /
        60000
    );
  }

  isSameYear(uuDateTime) {
    if (!(uuDateTime instanceof UuDateTime)) return false;
    let uuDateTimeInTZ = uuDateTime.timeZone === this.timeZone ? uuDateTime : new UuDateTime(uuDateTime, this.timeZone);
    return this.getYear() === uuDateTimeInTZ.getYear();
  }

  isSameMonth(uuDateTime) {
    if (!(uuDateTime instanceof UuDateTime)) return false;
    let uuDateTimeInTZ = uuDateTime.timeZone === this.timeZone ? uuDateTime : new UuDateTime(uuDateTime, this.timeZone);
    return this.getMonth() === uuDateTimeInTZ.getMonth();
  }

  isSameMonthYear(uuDateTime) {
    if (!(uuDateTime instanceof UuDateTime)) return false;
    let uuDateTimeInTZ = uuDateTime.timeZone === this.timeZone ? uuDateTime : new UuDateTime(uuDateTime, this.timeZone);
    return this.getMonth() === uuDateTimeInTZ.getMonth() && this.getYear() === uuDateTimeInTZ.getYear();
  }

  isSameWeek(uuDateTime, weekStartDay = 1) {
    if (!(uuDateTime instanceof UuDateTime)) return false;
    let uuDateTimeInTZ = uuDateTime.timeZone === this.timeZone ? uuDateTime : new UuDateTime(uuDateTime, this.timeZone);
    return this.getWeek(weekStartDay) === uuDateTimeInTZ.getWeek(weekStartDay);
  }

  isSameWeekYear(uuDateTime, weekStartDay = 1) {
    if (!(uuDateTime instanceof UuDateTime)) return false;
    let uuDateTimeInTZ = uuDateTime.timeZone === this.timeZone ? uuDateTime : new UuDateTime(uuDateTime, this.timeZone);
    let date1 = new UuDate([this.getYear(), this.getMonth(), this.getDay()]);
    let date2 = new UuDate([uuDateTimeInTZ.getYear(), uuDateTimeInTZ.getMonth(), uuDateTimeInTZ.getDay()]);
    return date1.isSameWeekYear(date2, weekStartDay);
  }

  isToday() {
    let today = new UuDateTime(undefined, this.timeZone);
    return (
      this.getDay() === today.getDay() && this.getMonth() === today.getMonth() && this.getYear() === today.getYear()
    );
  }

  setYear(...newValues) {
    let [date, fields] = this._getUpdatedDate(...newValues);
    if (isNaN(date.getDate())) throw new Error("Invalid setYear() parameters: " + safeStringify(newValues));
    this.date = date;
    this._fields = fields;
    return this;
  }

  setMonth(...newValues) {
    let [date, fields] = this._getUpdatedDate(undefined, ...newValues);
    if (isNaN(date.getDate())) throw new Error("Invalid setMonth() parameters: " + safeStringify(newValues));
    this.date = date;
    this._fields = fields;
    return this;
  }

  setDay(...newValues) {
    let [date, fields] = this._getUpdatedDate(undefined, undefined, ...newValues);
    if (isNaN(date.getDate())) throw new Error("Invalid setDay() parameters: " + safeStringify(newValues));
    this.date = date;
    this._fields = fields;
    return this;
  }

  setHour(...newValues) {
    let [date, fields] = this._getUpdatedDate(undefined, undefined, undefined, ...newValues);
    if (isNaN(date.getDate())) throw new Error("Invalid setHour() parameters: " + safeStringify(newValues));
    this.date = date;
    this._fields = fields;
    return this;
  }

  setMinute(...newValues) {
    let [date, fields] = this._getUpdatedDate(undefined, undefined, undefined, undefined, ...newValues);
    if (isNaN(date.getDate())) throw new Error("Invalid setMinute() parameters: " + safeStringify(newValues));
    this.date = date;
    this._fields = fields;
    return this;
  }

  setSecond(second, millisecond) {
    // optimization - assume that second / millisecond have no impact on DST / timeZone offsetting and simply set the values
    if (
      second >= 0 &&
      second <= 59 &&
      Math.floor(second) === second &&
      (millisecond === undefined || (millisecond >= 0 && millisecond <= 999 && Math.floor(millisecond) === millisecond))
    ) {
      let date = new Date(this.date);
      date.setSeconds(second);
      if (this._fields) this._fields.second = second;
      if (millisecond !== undefined) {
        date.setMilliseconds(millisecond);
        if (this._fields) this._fields.millisecond = millisecond;
      }
      this.date = date;
    } else {
      // prettier-ignore
      let [date, fields] = this._getUpdatedDate(undefined, undefined, undefined, undefined, undefined, second, millisecond);
      if (isNaN(date.getDate()))
        throw new Error("Invalid setSecond() parameters: " + safeStringify([second, millisecond]));
      this.date = date;
      this._fields = fields;
    }
    return this;
  }

  setMillisecond(millisecond) {
    // optimization - assume that second / millisecond have no impact on DST / timeZone offsetting and simply set the values
    // NOTE This optimization is possible because we're always ending up on the upper bound of DST change, i.e.
    // if we have Europe/Prague:
    // a) 2020-03-29 01:59:59.999 +1ms -> 03:00:00.000 (upper bound) +1ms -> 03:00:00.001
    // b) 2020-03-29 01:59:59.999 +1ms -> 02:00:00.000 (lower bound) +1ms -> 03:00:00.001 - this case would need safer optimization
    //    because going from 001 millisecond back to 000 could change hour too.
    // NOTE We're assuming that DST change is rounded to minutes.
    if (millisecond >= 0 && millisecond <= 999 && Math.floor(millisecond) === millisecond) {
      let date = new Date(this.date);
      date.setMilliseconds(millisecond);
      this.date = date;
      if (this._fields) this._fields.millisecond = millisecond;
    } else {
      // prettier-ignore
      let [date, fields] = this._getUpdatedDate(undefined, undefined, undefined, undefined, undefined, undefined, millisecond);
      if (isNaN(date.getDate()))
        throw new Error("Invalid setMillisecond() parameters: " + safeStringify([millisecond]));
      this.date = date;
      this._fields = fields;
    }
    return this;
  }

  setTime(newValue) {
    let date = new Date(newValue);
    if (isNaN(date.getDate())) throw new Error("Invalid setTime() parameters: " + safeStringify([newValue]));
    this.date = date;
    delete this._fields;
    return this;
  }

  shiftYear(yearOffset) {
    if (typeof yearOffset !== "number") throw new Error("Invalid shift offset (must be number): " + yearOffset);
    let adjustedDateTime = this.clone();
    adjustedDateTime.setYear(adjustedDateTime.getYear() + yearOffset);
    if (adjustedDateTime.getDay() !== this.getDay()) {
      // shifting resulted in invalid date that bled out to next month, e.g. 29.02.2020 + 1year -> 29.02.2021 (i.e. 01.03.2021) => move back
      adjustedDateTime.setDay(0, this.getHour(), this.getMinute(), this.getSecond(), this.getMillisecond());
    }
    this.date = adjustedDateTime.date;
    this._fields = adjustedDateTime._fields;
    return this;
  }

  shiftMonth(monthOffset) {
    if (typeof monthOffset !== "number") throw new Error("Invalid shift offset (must be number): " + monthOffset);
    let adjustedDateTime = this.clone();
    adjustedDateTime.setMonth(adjustedDateTime.getMonth() + monthOffset);
    if (adjustedDateTime.getDay() !== this.getDay()) {
      // shifting resulted in invalid date that bled out to next month, e.g. 31.03. + 1month -> 31.04. (i.e. 01.05.) => move back
      adjustedDateTime.setDay(0, this.getHour(), this.getMinute(), this.getSecond(), this.getMillisecond());
    }
    this.date = adjustedDateTime.date;
    this._fields = adjustedDateTime._fields;
    return this;
  }

  shiftDay(dayOffset) {
    if (typeof dayOffset !== "number") throw new Error("Invalid shift offset (must be number): " + dayOffset);
    return this.setDay(this.getDay() + dayOffset);
  }

  shiftTime(millisOffset) {
    if (typeof millisOffset !== "number") throw new Error("Invalid shift offset (must be number): " + millisOffset);
    return this.setTime(this.getTime() + millisOffset);
  }

  startOfYear() {
    return this.setMonth(1, 1, 0, 0, 0, 0);
  }

  endOfYear() {
    return this.setYear(this.getYear() + 1, 1, 1, 0, 0, 0, -1);
  }

  startOfMonth() {
    return this.setDay(1, 0, 0, 0, 0);
  }

  endOfMonth() {
    return this.setMonth(this.getMonth() + 1, 1, 0, 0, 0, -1);
  }

  startOfDay() {
    return this.setHour(0, 0, 0, 0);
  }

  endOfDay() {
    return this.setDay(this.getDay() + 1, 0, 0, 0, -1);
  }

  startOfWeek(weekStartDay = 1) {
    return this.setDay(this.getDay() - ((this.getWeekDay() - weekStartDay + 7) % 7), 0, 0, 0, 0);
  }

  endOfWeek(weekStartDay = 1) {
    return this.setDay(this.getDay() + 7 - ((this.getWeekDay() - weekStartDay + 7) % 7), 0, 0, 0, -1);
  }

  clone() {
    return new UuDateTime(this);
  }

  toString() {
    return this.toIsoString();
  }

  toIsoString() {
    return this.date.toISOString();
  }

  format(locale, intlFormatOptions) {
    let result;
    if (intlFormatOptions && typeof intlFormatOptions.format === "string") {
      let uuDateTime = intlFormatOptions.timeZone ? new UuDateTime(this, intlFormatOptions.timeZone) : this;
      result = customFormat(uuDateTime, intlFormatOptions.format, locale, uuDateTime.timeZone);
    } else {
      let hasDateFields =
        intlFormatOptions &&
        [
          "year",
          "month",
          "day",
          "hour",
          "minute",
          "second",
          "fractionalSecond",
          "weekday",
          "era",
          "timeZoneName",
          "timeStyle",
          "dateStyle",
        ].some((field) => field in intlFormatOptions);
      let defaultOptions = { timeZone: this.timeZone };
      if (!hasDateFields) {
        Object.assign(defaultOptions, {
          year: "numeric",
          month: "numeric",
          day: "numeric",
          hour: "numeric",
          minute: "2-digit",
        });
      }
      result = new Intl.DateTimeFormat(locale, { ...defaultOptions, ...intlFormatOptions }).format(this.date);
    }
    return result;
  }

  toJSON() {
    return this.toIsoString();
  }

  toDate() {
    return new Date(this.date);
  }

  _getUpdatedDate(
    year = this.getYear(),
    month = this.getMonth(),
    day = this.getDay(),
    hour = this.getHour(),
    minute = this.getMinute(),
    second = this.getSecond(),
    millisecond = this.getMillisecond()
  ) {
    return this._dateFromTimeZone(year, month, day, hour, minute, second, millisecond, this.timeZone);
  }

  _stringValuesToIso(year, month, day, hour, minute, second, millisecond, timezoneSpecifier) {
    let result = `${year}-${month || "01"}-${day || "01"}T${hour || "00"}:${minute || "00"}:${second || "00"}.${
      millisecond || "000"
    }${timezoneSpecifier}`;
    return result;
  }

  _dateFromTimeZone(year, month, day, hour, minute, second, millisecond, timeZone) {
    [year, month, day, hour, minute, second, millisecond] = this._normalizeWithDefaults(
      year,
      month,
      day,
      hour,
      minute,
      second,
      millisecond
    );
    let date;
    let fields;
    // find time (millis) which when formatted using given timeZone gives values corresponding to year, month, ...
    let utcMillis = getUtcMillis(year, month, day, hour, minute, second, millisecond);
    let utc = new Date(utcMillis);
    if (isNaN(utc.getDate())) {
      date = INVALID_DATE;
    } else {
      let tzFormatter = this._getTimeZoneFormatter(timeZone);
      let [y, m, d, H, M, S, MS] = this._getPartsFromFormattedValueAsArray(utc, tzFormatter);
      let offset = getUtcMillis(y, m, d, H, M, S, MS) - utcMillis;
      let candidateMillis = utcMillis - offset;
      date = new Date(candidateMillis);
      [y, m, d, H, M, S, MS] = this._getPartsFromFormattedValueAsArray(date, tzFormatter);
      let expectedHour = utc.getUTCHours(); // can differ from `hour` if `hour` is outside of 0..23
      let expectedMinute = utc.getUTCMinutes();
      if (H !== expectedHour || M !== expectedMinute) {
        // used timeZone uses dynamic offset (summer/winter time; it may also mean that the target time
        // doesn't exist, e.g. 2020-03-29 02:30 doesn't exist in Europe/Prague timezone)
        // let log = [
        //   `## wanted (TZ: ${timeZone}): `,
        //   JSON.stringify([year, month, day, hour, minute, second, millisecond]),
        //   `\n#1 got    (TZ: ${timeZone}): `,
        //   JSON.stringify([y, m, d, H, M, S, MS]),
        //   `(${candidateMillis})`,
        // ];
        let fallbackCandidateMillis = candidateMillis;
        let diffCorrection = (expectedHour - H) * 60 + (expectedMinute - M);
        // if the mismatch occurred at day boundary, e.g. 1964-05-16T00:10 using "Europe/Instabul"
        // (tz offset changes from 00:00 to 01:00, i.e. 00:10 is invalid) then `expectedHour - H` might be -23 or 23
        // instead of 1 or -1 => handle overflows here
        if (diffCorrection < -12 * 60) diffCorrection += 24 * 60;
        else if (diffCorrection > 12 * 60) diffCorrection -= 24 * 60;
        candidateMillis += diffCorrection * 60 * 1000;
        date = new Date(candidateMillis);
        let [y2, m2, d2, H2, M2, S2, MS2] = this._getPartsFromFormattedValueAsArray(date, tzFormatter);
        // log.push(`\n#2 got    (TZ: ${timeZone}): `, JSON.stringify([y2, m2, d2, H2, M2, S2, MS2]), `(${candidateMillis})`);

        // fall back to the bigger of the two if it still doesn't match (i.e. time is invalid)
        if (H2 !== expectedHour || M2 !== expectedMinute) {
          candidateMillis = Math.max(candidateMillis, fallbackCandidateMillis);
          //   log.push(
          //     `\n## correction failed (invalid time), falling back to #${
          //       fallbackCandidateMillis === candidateMillis ? "1" : "2"
          //     }`
          //   );
          // } else {
          //   log.push(`\n## correction succeeded, using #${fallbackCandidateMillis === candidateMillis ? "1" : "2"}`);
          date = new Date(candidateMillis);
        }
        if (candidateMillis === fallbackCandidateMillis) {
          fields = { year: y, month: m, day: d, hour: H, minute: M, second: S, millisecond: MS };
        } else {
          fields = { year: y2, month: m2, day: d2, hour: H2, minute: M2, second: S2, millisecond: MS2 };
        }
        // console.log(...log);
      } else {
        fields = { year: y, month: m, day: d, hour: H, minute: M, second: S, millisecond: MS };
      }
    }
    return [date, fields];
  }

  _normalizeWithDefaults(year, month, day, hour, minute, second, millisecond) {
    function process(value, defValue) {
      if (typeof value === "number") return value;
      if (value == null) return defValue;
      if (typeof value === "string" && value.match(/^\d+$/)) return Number(value);
      return NaN;
    }
    year = process(year, year);
    month = process(month, 1);
    day = process(day, 1);
    hour = process(hour, 0);
    minute = process(minute, 0);
    second = process(second, 0);
    millisecond = process(millisecond, 0);
    return [year, month, day, hour, minute, second, millisecond];
  }

  _getPartsFromFormattedValueAsArray(date, formatter) {
    let map = this._getPartsFromFormattedValue(date, formatter);
    let { year, month, day, hour, minute, second, millisecond } = map;
    return [year, month, day, hour, minute, second, millisecond];
  }

  _getPartsFromFormattedValue(date, formatter = this._getTimeZoneFormatter()) {
    let parts = formatter.formatToParts(date);
    let map = {};
    parts.forEach((part) => {
      if (part.type !== "literal") map[part.type] = Number(part.value);
    });
    if (map.fractionalSecond != null) {
      map.millisecond = map.fractionalSecond;
      delete map.fractionalSecond;
    } else {
      // NOTE NodeJS (and possibly others) implementations of Intl don't support milliseconds (fractionalSecond) output
      // from formatToParts() yet.
      map.millisecond = date.getMilliseconds();
    }
    return map;
  }

  _getTimeZoneFormatter(timeZone = this.timeZone) {
    let formatter = formatterMap[timeZone];
    if (!formatter) {
      let formatterOptions = {
        calendar: "iso8601",
        numberingSystem: "latn",
        hourCycle: "h23",
        year: "numeric",
        month: "numeric",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        fractionalSecondDigits: 3,
        timeZone,
      };
      formatterMap[timeZone] = formatter = new Intl.DateTimeFormat("en-US", formatterOptions);
    }
    return formatter;
  }

  _getOsTimeZone() {
    return (osTimeZone ??= new Intl.DateTimeFormat().resolvedOptions().timeZone);
  }
}

module.exports = UuDateTime;
