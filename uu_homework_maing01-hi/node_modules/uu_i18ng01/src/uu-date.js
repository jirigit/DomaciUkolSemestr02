const { customFormat } = require("./internal/custom-format");
const {
  parseDate,
  safeStringify,
  parseWeekDate,
  getWeekDay,
  getJsDate,
  getWeekYear,
  getWeek,
} = require("./internal/util");

class UuDate {
  static now() {
    return new UuDate();
  }

  static utc() {
    let date = new Date(Date.now());
    return new UuDate({ year: date.getUTCFullYear(), month: date.getUTCMonth() + 1, day: date.getUTCDate() });
  }

  static parse(string, locale, format = undefined) {
    let parsed = parseDate(string, locale, format);
    return parsed ? new UuDate(parsed) : parsed;
  }

  static compare(uuDate1, uuDate2) {
    return (
      uuDate1.getYear() - uuDate2.getYear() ||
      uuDate1.getMonth() - uuDate2.getMonth() ||
      uuDate1.getDay() - uuDate2.getDay()
    );
  }

  constructor(value) {
    let year, month, day, valid;
    if (value instanceof UuDate) {
      day = value.getDay();
      month = value.getMonth();
      year = value.getYear();
    } else if (value == null || value instanceof Date) {
      value = value || new Date(Date.now());
      day = value.getDate();
      month = value.getMonth() + 1;
      year = value.getFullYear();
    } else {
      let allowOverflow;
      if (typeof value === "string") {
        let match = value.match(/^(\d{4})(?:-?(\d{2})(?:-?(\d{2}))?)?$/);
        if (match) {
          [, year, month, day] = match;
          year = Number(year);
          month = Number(month || "01");
          day = Number(day || "01");
          allowOverflow = false;
        } else {
          let parsedDate = parseWeekDate(value);
          if (parsedDate) {
            [year, month, day] = parsedDate;
            allowOverflow = true;
          } else {
            throw new Error(
              "Invalid date string value '" +
                value +
                "'. Only ISO date-only format and week date format is supported, e.g. '2020-02-13', '20200201', '2020-W35-1' or '2020-W35'."
            );
          }
        }
      } else if (Array.isArray(value)) {
        [year, month, day] = value;
        allowOverflow = true;
      } else if (typeof value === "object") {
        ({ year, month, day } = value);
        allowOverflow = true;
      } else {
        throw new Error("Unsupported date value: " + value);
      }
      ({ year, month, day, valid } = this._computeValid(year, month ?? 1, day ?? 1, allowOverflow));
      if (!valid) throw new Error("Invalid date: " + safeStringify(value));
    }
    this.day = day;
    this.month = month;
    this.year = year;
  }

  getDay() {
    return this.day;
  }

  getMonth() {
    return this.month;
  }

  getYear() {
    return this.year;
  }

  getWeek(weekStartDay = 1) {
    return getWeek(this.year, this.month, this.day, weekStartDay);
  }

  getWeekDay() {
    return getWeekDay(this.year, this.month, this.day); // 1 <=> Monday, 7 <=> Sunday
  }

  getWeekYear(weekStartDay = 1) {
    return getWeekYear(this.year, this.month, this.day, weekStartDay);
  }

  isSameDate(uuDate) {
    if (!(uuDate instanceof UuDate)) return false;
    return (
      this.getDay() === uuDate.getDay() && this.getMonth() === uuDate.getMonth() && this.getYear() === uuDate.getYear()
    );
  }

  isSameWeek(uuDate, weekStartDay = 1) {
    if (!(uuDate instanceof UuDate)) return false;
    return this.getWeek(weekStartDay) === uuDate.getWeek(weekStartDay);
  }

  isSameWeekYear(uuDate, weekStartDay = 1) {
    if (!(uuDate instanceof UuDate)) return false;
    let date1 = new UuDate(this);
    let date2 = new UuDate(uuDate);
    date1.startOfWeek(weekStartDay);
    date2.startOfWeek(weekStartDay);
    return date1.isSameDate(date2);
  }

  isSameMonth(uuDate) {
    if (!(uuDate instanceof UuDate)) return false;
    return this.getMonth() === uuDate.getMonth();
  }

  isSameMonthYear(uuDate) {
    if (!(uuDate instanceof UuDate)) return false;
    return this.getMonth() === uuDate.getMonth() && this.getYear() === uuDate.getYear();
  }

  isSameYear(uuDate) {
    if (!(uuDate instanceof UuDate)) return false;
    return this.getYear() === uuDate.getYear();
  }

  setYear(newYear, newMonth = this.month, newDay = this.day) {
    let { valid, day, month, year } = this._computeValid(newYear, newMonth, newDay, true);
    if (!valid) throw new Error("Invalid year: " + newYear);
    this.day = day;
    this.month = month;
    this.year = year;
    return this;
  }

  setMonth(newMonth, newDay = this.day) {
    let { valid, day, month, year } = this._computeValid(this.year, newMonth, newDay, true);
    if (!valid) throw new Error("Invalid month: " + newMonth);
    this.day = day;
    this.month = month;
    this.year = year;
    return this;
  }

  setDay(newDay) {
    let { valid, day, month, year } = this._computeValid(this.year, this.month, newDay, true);
    if (!valid) throw new Error("Invalid day: " + newDay);
    this.day = day;
    this.month = month;
    this.year = year;
    return this;
  }

  /**
   * @deprecated
   */
  shiftDate(dayOffset) {
    return this.shiftDay(dayOffset);
  }

  shiftYear(yearOffset) {
    if (typeof yearOffset !== "number") throw new Error("Invalid shift offset (must be number): " + yearOffset);
    let adjustedDate = new UuDate(this);
    adjustedDate.setYear(adjustedDate.getYear() + yearOffset);
    if (adjustedDate.getDay() !== this.getDay()) {
      // shifting resulted in invalid date that bled out to next month, e.g. 29.02.2020 + 1year -> 29.02.2021 (i.e. 01.03.2021) => move back
      adjustedDate.setDay(0);
    }
    return this.setYear(adjustedDate.getYear(), adjustedDate.getMonth(), adjustedDate.getDay());
  }

  shiftMonth(monthOffset) {
    if (typeof monthOffset !== "number") throw new Error("Invalid shift offset (must be number): " + monthOffset);
    let adjustedDate = new UuDate(this);
    adjustedDate.setMonth(adjustedDate.getMonth() + monthOffset);
    if (adjustedDate.getDay() !== this.getDay()) {
      // shifting resulted in invalid date that bled out to next month, e.g. 31.03. + 1month -> 31.04. (i.e. 01.05.) => move back
      adjustedDate.setDay(0);
    }
    return this.setYear(adjustedDate.getYear(), adjustedDate.getMonth(), adjustedDate.getDay());
  }

  shiftDay(dayOffset) {
    if (typeof dayOffset !== "number") throw new Error("Invalid shift offset (must be number): " + dayOffset);
    return this.setDay(this.day + dayOffset);
  }

  startOfYear() {
    return this.setMonth(1, 1);
  }

  endOfYear() {
    return this.setYear(this.year + 1, 1, 0);
  }

  startOfMonth() {
    return this.setDay(1);
  }

  endOfMonth() {
    return this.setMonth(this.month + 1, 0);
  }

  startOfWeek(weekStartDay = 1) {
    return this.shiftDay(-((this.getWeekDay() - weekStartDay + 7) % 7));
  }

  endOfWeek(weekStartDay = 1) {
    return this.shiftDay(6 - ((this.getWeekDay() - weekStartDay + 7) % 7));
  }

  toString() {
    return this.toIsoString();
  }

  toIsoString() {
    return (
      (this.year + "").padStart(4, "0") +
      "-" +
      (this.month + "").padStart(2, "0") +
      "-" +
      (this.day + "").padStart(2, "0")
    );
  }

  toIsoWeekString(omitDay = false) {
    // Monday is always first day of a ISO week
    return (
      (this.getWeekYear() + "").padStart(4, "0") +
      "-W" +
      (this.getWeek() + "").padStart(2, "0") +
      (!omitDay ? "-" + this.getWeekDay() : "")
    );
  }

  format(locale, intlFormatOptions) {
    let utcDateTime = new Date(this.toIsoString() + "T00:00:00.000Z");
    let result;
    if (intlFormatOptions && typeof intlFormatOptions.format === "string") {
      result = customFormat(this, intlFormatOptions.format, locale);
    } else {
      result = new Intl.DateTimeFormat(locale, { ...intlFormatOptions, timeZone: "UTC" }).format(utcDateTime);
    }
    return result;
  }

  toJSON() {
    return this.toIsoString();
  }

  toDate() {
    return getJsDate(this.year, this.month, this.day, 0, 0, 0, 0);
  }

  _computeValid(year, month, day, allowOverflow = false) {
    function process(value) {
      return value === parseInt(value) ? value : NaN;
    }
    let date = getJsDate(process(year), process(month), process(day), 12, 0, 0, 0);
    let resultDay = date.getDate();
    let resultMonth = date.getMonth() + 1;
    let resultYear = date.getFullYear();
    return {
      valid:
        !isNaN(resultDay) && (allowOverflow || (resultDay === day && resultMonth === month && resultYear === year)),
      year: resultYear,
      month: resultMonth,
      day: resultDay,
    };
  }
}

module.exports = UuDate;
